
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ScreenType
 * 
 */
export type ScreenType = $Result.DefaultSelection<Prisma.$ScreenTypePayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Placement
 * 
 */
export type Placement = $Result.DefaultSelection<Prisma.$PlacementPayload>
/**
 * Model Option
 * 
 */
export type Option = $Result.DefaultSelection<Prisma.$OptionPayload>
/**
 * Model Sensor
 * 
 */
export type Sensor = $Result.DefaultSelection<Prisma.$SensorPayload>
/**
 * Model ControlType
 * 
 */
export type ControlType = $Result.DefaultSelection<Prisma.$ControlTypePayload>
/**
 * Model Pitch
 * 
 */
export type Pitch = $Result.DefaultSelection<Prisma.$PitchPayload>
/**
 * Model RefreshRate
 * 
 */
export type RefreshRate = $Result.DefaultSelection<Prisma.$RefreshRatePayload>
/**
 * Model Brightness
 * 
 */
export type Brightness = $Result.DefaultSelection<Prisma.$BrightnessPayload>
/**
 * Model Manufacturer
 * 
 */
export type Manufacturer = $Result.DefaultSelection<Prisma.$ManufacturerPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model IpProtection
 * 
 */
export type IpProtection = $Result.DefaultSelection<Prisma.$IpProtectionPayload>
/**
 * Model ModuleSize
 * 
 */
export type ModuleSize = $Result.DefaultSelection<Prisma.$ModuleSizePayload>
/**
 * Model CabinetSize
 * 
 */
export type CabinetSize = $Result.DefaultSelection<Prisma.$CabinetSizePayload>
/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model ItemSubcategory
 * 
 */
export type ItemSubcategory = $Result.DefaultSelection<Prisma.$ItemSubcategoryPayload>
/**
 * Model Cabinet
 * 
 */
export type Cabinet = $Result.DefaultSelection<Prisma.$CabinetPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ScreenTypeOption
 * 
 */
export type ScreenTypeOption = $Result.DefaultSelection<Prisma.$ScreenTypeOptionPayload>
/**
 * Model ScreenTypeControlType
 * 
 */
export type ScreenTypeControlType = $Result.DefaultSelection<Prisma.$ScreenTypeControlTypePayload>
/**
 * Model ScreenTypeSensor
 * 
 */
export type ScreenTypeSensor = $Result.DefaultSelection<Prisma.$ScreenTypeSensorPayload>
/**
 * Model ItemCategoryRelation
 * 
 */
export type ItemCategoryRelation = $Result.DefaultSelection<Prisma.$ItemCategoryRelationPayload>
/**
 * Model ItemSubcategoryRelation
 * 
 */
export type ItemSubcategoryRelation = $Result.DefaultSelection<Prisma.$ItemSubcategoryRelationPayload>
/**
 * Model ItemPrice
 * 
 */
export type ItemPrice = $Result.DefaultSelection<Prisma.$ItemPricePayload>
/**
 * Model ItemSupplier
 * 
 */
export type ItemSupplier = $Result.DefaultSelection<Prisma.$ItemSupplierPayload>
/**
 * Model ItemCategorySubcategory
 * 
 */
export type ItemCategorySubcategory = $Result.DefaultSelection<Prisma.$ItemCategorySubcategoryPayload>
/**
 * Model CabinetCategory
 * 
 */
export type CabinetCategory = $Result.DefaultSelection<Prisma.$CabinetCategoryPayload>
/**
 * Model CabinetSubcategory
 * 
 */
export type CabinetSubcategory = $Result.DefaultSelection<Prisma.$CabinetSubcategoryPayload>
/**
 * Model CabinetLocation
 * 
 */
export type CabinetLocation = $Result.DefaultSelection<Prisma.$CabinetLocationPayload>
/**
 * Model CabinetPlacement
 * 
 */
export type CabinetPlacement = $Result.DefaultSelection<Prisma.$CabinetPlacementPayload>
/**
 * Model CabinetMaterial
 * 
 */
export type CabinetMaterial = $Result.DefaultSelection<Prisma.$CabinetMaterialPayload>
/**
 * Model CabinetCabinetSize
 * 
 */
export type CabinetCabinetSize = $Result.DefaultSelection<Prisma.$CabinetCabinetSizePayload>
/**
 * Model CabinetPitch
 * 
 */
export type CabinetPitch = $Result.DefaultSelection<Prisma.$CabinetPitchPayload>
/**
 * Model CabinetManufacturer
 * 
 */
export type CabinetManufacturer = $Result.DefaultSelection<Prisma.$CabinetManufacturerPayload>
/**
 * Model CabinetSupplier
 * 
 */
export type CabinetSupplier = $Result.DefaultSelection<Prisma.$CabinetSupplierPayload>
/**
 * Model CabinetItemComponent
 * 
 */
export type CabinetItemComponent = $Result.DefaultSelection<Prisma.$CabinetItemComponentPayload>
/**
 * Model CabinetPrice
 * 
 */
export type CabinetPrice = $Result.DefaultSelection<Prisma.$CabinetPricePayload>
/**
 * Model ModuleCategory
 * 
 */
export type ModuleCategory = $Result.DefaultSelection<Prisma.$ModuleCategoryPayload>
/**
 * Model ModuleSubcategory
 * 
 */
export type ModuleSubcategory = $Result.DefaultSelection<Prisma.$ModuleSubcategoryPayload>
/**
 * Model ModuleLocation
 * 
 */
export type ModuleLocation = $Result.DefaultSelection<Prisma.$ModuleLocationPayload>
/**
 * Model ModuleRefreshRate
 * 
 */
export type ModuleRefreshRate = $Result.DefaultSelection<Prisma.$ModuleRefreshRatePayload>
/**
 * Model ModuleBrightness
 * 
 */
export type ModuleBrightness = $Result.DefaultSelection<Prisma.$ModuleBrightnessPayload>
/**
 * Model ModuleModuleSize
 * 
 */
export type ModuleModuleSize = $Result.DefaultSelection<Prisma.$ModuleModuleSizePayload>
/**
 * Model ModulePitch
 * 
 */
export type ModulePitch = $Result.DefaultSelection<Prisma.$ModulePitchPayload>
/**
 * Model ModuleManufacturer
 * 
 */
export type ModuleManufacturer = $Result.DefaultSelection<Prisma.$ModuleManufacturerPayload>
/**
 * Model ModuleItemComponent
 * 
 */
export type ModuleItemComponent = $Result.DefaultSelection<Prisma.$ModuleItemComponentPayload>
/**
 * Model ModuleOption
 * 
 */
export type ModuleOption = $Result.DefaultSelection<Prisma.$ModuleOptionPayload>
/**
 * Model ModulePrice
 * 
 */
export type ModulePrice = $Result.DefaultSelection<Prisma.$ModulePricePayload>
/**
 * Model CabinetSizeModuleSize
 * 
 */
export type CabinetSizeModuleSize = $Result.DefaultSelection<Prisma.$CabinetSizeModuleSizePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenType`: Exposes CRUD operations for the **ScreenType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenTypes
    * const screenTypes = await prisma.screenType.findMany()
    * ```
    */
  get screenType(): Prisma.ScreenTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placement`: Exposes CRUD operations for the **Placement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Placements
    * const placements = await prisma.placement.findMany()
    * ```
    */
  get placement(): Prisma.PlacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sensor`: Exposes CRUD operations for the **Sensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sensors
    * const sensors = await prisma.sensor.findMany()
    * ```
    */
  get sensor(): Prisma.SensorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.controlType`: Exposes CRUD operations for the **ControlType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ControlTypes
    * const controlTypes = await prisma.controlType.findMany()
    * ```
    */
  get controlType(): Prisma.ControlTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pitch`: Exposes CRUD operations for the **Pitch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pitches
    * const pitches = await prisma.pitch.findMany()
    * ```
    */
  get pitch(): Prisma.PitchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshRate`: Exposes CRUD operations for the **RefreshRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshRates
    * const refreshRates = await prisma.refreshRate.findMany()
    * ```
    */
  get refreshRate(): Prisma.RefreshRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brightness`: Exposes CRUD operations for the **Brightness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brightnesses
    * const brightnesses = await prisma.brightness.findMany()
    * ```
    */
  get brightness(): Prisma.BrightnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manufacturer`: Exposes CRUD operations for the **Manufacturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manufacturers
    * const manufacturers = await prisma.manufacturer.findMany()
    * ```
    */
  get manufacturer(): Prisma.ManufacturerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ipProtection`: Exposes CRUD operations for the **IpProtection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IpProtections
    * const ipProtections = await prisma.ipProtection.findMany()
    * ```
    */
  get ipProtection(): Prisma.IpProtectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleSize`: Exposes CRUD operations for the **ModuleSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleSizes
    * const moduleSizes = await prisma.moduleSize.findMany()
    * ```
    */
  get moduleSize(): Prisma.ModuleSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetSize`: Exposes CRUD operations for the **CabinetSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetSizes
    * const cabinetSizes = await prisma.cabinetSize.findMany()
    * ```
    */
  get cabinetSize(): Prisma.CabinetSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemSubcategory`: Exposes CRUD operations for the **ItemSubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemSubcategories
    * const itemSubcategories = await prisma.itemSubcategory.findMany()
    * ```
    */
  get itemSubcategory(): Prisma.ItemSubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinet`: Exposes CRUD operations for the **Cabinet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cabinets
    * const cabinets = await prisma.cabinet.findMany()
    * ```
    */
  get cabinet(): Prisma.CabinetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenTypeOption`: Exposes CRUD operations for the **ScreenTypeOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenTypeOptions
    * const screenTypeOptions = await prisma.screenTypeOption.findMany()
    * ```
    */
  get screenTypeOption(): Prisma.ScreenTypeOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenTypeControlType`: Exposes CRUD operations for the **ScreenTypeControlType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenTypeControlTypes
    * const screenTypeControlTypes = await prisma.screenTypeControlType.findMany()
    * ```
    */
  get screenTypeControlType(): Prisma.ScreenTypeControlTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenTypeSensor`: Exposes CRUD operations for the **ScreenTypeSensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenTypeSensors
    * const screenTypeSensors = await prisma.screenTypeSensor.findMany()
    * ```
    */
  get screenTypeSensor(): Prisma.ScreenTypeSensorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategoryRelation`: Exposes CRUD operations for the **ItemCategoryRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategoryRelations
    * const itemCategoryRelations = await prisma.itemCategoryRelation.findMany()
    * ```
    */
  get itemCategoryRelation(): Prisma.ItemCategoryRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemSubcategoryRelation`: Exposes CRUD operations for the **ItemSubcategoryRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemSubcategoryRelations
    * const itemSubcategoryRelations = await prisma.itemSubcategoryRelation.findMany()
    * ```
    */
  get itemSubcategoryRelation(): Prisma.ItemSubcategoryRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemPrice`: Exposes CRUD operations for the **ItemPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemPrices
    * const itemPrices = await prisma.itemPrice.findMany()
    * ```
    */
  get itemPrice(): Prisma.ItemPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemSupplier`: Exposes CRUD operations for the **ItemSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemSuppliers
    * const itemSuppliers = await prisma.itemSupplier.findMany()
    * ```
    */
  get itemSupplier(): Prisma.ItemSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategorySubcategory`: Exposes CRUD operations for the **ItemCategorySubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategorySubcategories
    * const itemCategorySubcategories = await prisma.itemCategorySubcategory.findMany()
    * ```
    */
  get itemCategorySubcategory(): Prisma.ItemCategorySubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetCategory`: Exposes CRUD operations for the **CabinetCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetCategories
    * const cabinetCategories = await prisma.cabinetCategory.findMany()
    * ```
    */
  get cabinetCategory(): Prisma.CabinetCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetSubcategory`: Exposes CRUD operations for the **CabinetSubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetSubcategories
    * const cabinetSubcategories = await prisma.cabinetSubcategory.findMany()
    * ```
    */
  get cabinetSubcategory(): Prisma.CabinetSubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetLocation`: Exposes CRUD operations for the **CabinetLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetLocations
    * const cabinetLocations = await prisma.cabinetLocation.findMany()
    * ```
    */
  get cabinetLocation(): Prisma.CabinetLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetPlacement`: Exposes CRUD operations for the **CabinetPlacement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetPlacements
    * const cabinetPlacements = await prisma.cabinetPlacement.findMany()
    * ```
    */
  get cabinetPlacement(): Prisma.CabinetPlacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetMaterial`: Exposes CRUD operations for the **CabinetMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetMaterials
    * const cabinetMaterials = await prisma.cabinetMaterial.findMany()
    * ```
    */
  get cabinetMaterial(): Prisma.CabinetMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetCabinetSize`: Exposes CRUD operations for the **CabinetCabinetSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetCabinetSizes
    * const cabinetCabinetSizes = await prisma.cabinetCabinetSize.findMany()
    * ```
    */
  get cabinetCabinetSize(): Prisma.CabinetCabinetSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetPitch`: Exposes CRUD operations for the **CabinetPitch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetPitches
    * const cabinetPitches = await prisma.cabinetPitch.findMany()
    * ```
    */
  get cabinetPitch(): Prisma.CabinetPitchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetManufacturer`: Exposes CRUD operations for the **CabinetManufacturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetManufacturers
    * const cabinetManufacturers = await prisma.cabinetManufacturer.findMany()
    * ```
    */
  get cabinetManufacturer(): Prisma.CabinetManufacturerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetSupplier`: Exposes CRUD operations for the **CabinetSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetSuppliers
    * const cabinetSuppliers = await prisma.cabinetSupplier.findMany()
    * ```
    */
  get cabinetSupplier(): Prisma.CabinetSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetItemComponent`: Exposes CRUD operations for the **CabinetItemComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetItemComponents
    * const cabinetItemComponents = await prisma.cabinetItemComponent.findMany()
    * ```
    */
  get cabinetItemComponent(): Prisma.CabinetItemComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetPrice`: Exposes CRUD operations for the **CabinetPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetPrices
    * const cabinetPrices = await prisma.cabinetPrice.findMany()
    * ```
    */
  get cabinetPrice(): Prisma.CabinetPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleCategory`: Exposes CRUD operations for the **ModuleCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleCategories
    * const moduleCategories = await prisma.moduleCategory.findMany()
    * ```
    */
  get moduleCategory(): Prisma.ModuleCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleSubcategory`: Exposes CRUD operations for the **ModuleSubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleSubcategories
    * const moduleSubcategories = await prisma.moduleSubcategory.findMany()
    * ```
    */
  get moduleSubcategory(): Prisma.ModuleSubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleLocation`: Exposes CRUD operations for the **ModuleLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleLocations
    * const moduleLocations = await prisma.moduleLocation.findMany()
    * ```
    */
  get moduleLocation(): Prisma.ModuleLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleRefreshRate`: Exposes CRUD operations for the **ModuleRefreshRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleRefreshRates
    * const moduleRefreshRates = await prisma.moduleRefreshRate.findMany()
    * ```
    */
  get moduleRefreshRate(): Prisma.ModuleRefreshRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleBrightness`: Exposes CRUD operations for the **ModuleBrightness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleBrightnesses
    * const moduleBrightnesses = await prisma.moduleBrightness.findMany()
    * ```
    */
  get moduleBrightness(): Prisma.ModuleBrightnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleModuleSize`: Exposes CRUD operations for the **ModuleModuleSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleModuleSizes
    * const moduleModuleSizes = await prisma.moduleModuleSize.findMany()
    * ```
    */
  get moduleModuleSize(): Prisma.ModuleModuleSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulePitch`: Exposes CRUD operations for the **ModulePitch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModulePitches
    * const modulePitches = await prisma.modulePitch.findMany()
    * ```
    */
  get modulePitch(): Prisma.ModulePitchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleManufacturer`: Exposes CRUD operations for the **ModuleManufacturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleManufacturers
    * const moduleManufacturers = await prisma.moduleManufacturer.findMany()
    * ```
    */
  get moduleManufacturer(): Prisma.ModuleManufacturerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleItemComponent`: Exposes CRUD operations for the **ModuleItemComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleItemComponents
    * const moduleItemComponents = await prisma.moduleItemComponent.findMany()
    * ```
    */
  get moduleItemComponent(): Prisma.ModuleItemComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleOption`: Exposes CRUD operations for the **ModuleOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleOptions
    * const moduleOptions = await prisma.moduleOption.findMany()
    * ```
    */
  get moduleOption(): Prisma.ModuleOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulePrice`: Exposes CRUD operations for the **ModulePrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModulePrices
    * const modulePrices = await prisma.modulePrice.findMany()
    * ```
    */
  get modulePrice(): Prisma.ModulePriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetSizeModuleSize`: Exposes CRUD operations for the **CabinetSizeModuleSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetSizeModuleSizes
    * const cabinetSizeModuleSizes = await prisma.cabinetSizeModuleSize.findMany()
    * ```
    */
  get cabinetSizeModuleSize(): Prisma.CabinetSizeModuleSizeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ScreenType: 'ScreenType',
    Material: 'Material',
    Location: 'Location',
    Placement: 'Placement',
    Option: 'Option',
    Sensor: 'Sensor',
    ControlType: 'ControlType',
    Pitch: 'Pitch',
    RefreshRate: 'RefreshRate',
    Brightness: 'Brightness',
    Manufacturer: 'Manufacturer',
    Supplier: 'Supplier',
    IpProtection: 'IpProtection',
    ModuleSize: 'ModuleSize',
    CabinetSize: 'CabinetSize',
    ItemCategory: 'ItemCategory',
    ItemSubcategory: 'ItemSubcategory',
    Cabinet: 'Cabinet',
    Module: 'Module',
    Item: 'Item',
    ScreenTypeOption: 'ScreenTypeOption',
    ScreenTypeControlType: 'ScreenTypeControlType',
    ScreenTypeSensor: 'ScreenTypeSensor',
    ItemCategoryRelation: 'ItemCategoryRelation',
    ItemSubcategoryRelation: 'ItemSubcategoryRelation',
    ItemPrice: 'ItemPrice',
    ItemSupplier: 'ItemSupplier',
    ItemCategorySubcategory: 'ItemCategorySubcategory',
    CabinetCategory: 'CabinetCategory',
    CabinetSubcategory: 'CabinetSubcategory',
    CabinetLocation: 'CabinetLocation',
    CabinetPlacement: 'CabinetPlacement',
    CabinetMaterial: 'CabinetMaterial',
    CabinetCabinetSize: 'CabinetCabinetSize',
    CabinetPitch: 'CabinetPitch',
    CabinetManufacturer: 'CabinetManufacturer',
    CabinetSupplier: 'CabinetSupplier',
    CabinetItemComponent: 'CabinetItemComponent',
    CabinetPrice: 'CabinetPrice',
    ModuleCategory: 'ModuleCategory',
    ModuleSubcategory: 'ModuleSubcategory',
    ModuleLocation: 'ModuleLocation',
    ModuleRefreshRate: 'ModuleRefreshRate',
    ModuleBrightness: 'ModuleBrightness',
    ModuleModuleSize: 'ModuleModuleSize',
    ModulePitch: 'ModulePitch',
    ModuleManufacturer: 'ModuleManufacturer',
    ModuleItemComponent: 'ModuleItemComponent',
    ModuleOption: 'ModuleOption',
    ModulePrice: 'ModulePrice',
    CabinetSizeModuleSize: 'CabinetSizeModuleSize'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "screenType" | "material" | "location" | "placement" | "option" | "sensor" | "controlType" | "pitch" | "refreshRate" | "brightness" | "manufacturer" | "supplier" | "ipProtection" | "moduleSize" | "cabinetSize" | "itemCategory" | "itemSubcategory" | "cabinet" | "module" | "item" | "screenTypeOption" | "screenTypeControlType" | "screenTypeSensor" | "itemCategoryRelation" | "itemSubcategoryRelation" | "itemPrice" | "itemSupplier" | "itemCategorySubcategory" | "cabinetCategory" | "cabinetSubcategory" | "cabinetLocation" | "cabinetPlacement" | "cabinetMaterial" | "cabinetCabinetSize" | "cabinetPitch" | "cabinetManufacturer" | "cabinetSupplier" | "cabinetItemComponent" | "cabinetPrice" | "moduleCategory" | "moduleSubcategory" | "moduleLocation" | "moduleRefreshRate" | "moduleBrightness" | "moduleModuleSize" | "modulePitch" | "moduleManufacturer" | "moduleItemComponent" | "moduleOption" | "modulePrice" | "cabinetSizeModuleSize"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ScreenType: {
        payload: Prisma.$ScreenTypePayload<ExtArgs>
        fields: Prisma.ScreenTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          findFirst: {
            args: Prisma.ScreenTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          findMany: {
            args: Prisma.ScreenTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>[]
          }
          create: {
            args: Prisma.ScreenTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          createMany: {
            args: Prisma.ScreenTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>[]
          }
          delete: {
            args: Prisma.ScreenTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          update: {
            args: Prisma.ScreenTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          deleteMany: {
            args: Prisma.ScreenTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>[]
          }
          upsert: {
            args: Prisma.ScreenTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypePayload>
          }
          aggregate: {
            args: Prisma.ScreenTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenType>
          }
          groupBy: {
            args: Prisma.ScreenTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Placement: {
        payload: Prisma.$PlacementPayload<ExtArgs>
        fields: Prisma.PlacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          findFirst: {
            args: Prisma.PlacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          findMany: {
            args: Prisma.PlacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[]
          }
          create: {
            args: Prisma.PlacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          createMany: {
            args: Prisma.PlacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlacementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[]
          }
          delete: {
            args: Prisma.PlacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          update: {
            args: Prisma.PlacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          deleteMany: {
            args: Prisma.PlacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlacementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[]
          }
          upsert: {
            args: Prisma.PlacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          aggregate: {
            args: Prisma.PlacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlacement>
          }
          groupBy: {
            args: Prisma.PlacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementCountArgs<ExtArgs>
            result: $Utils.Optional<PlacementCountAggregateOutputType> | number
          }
        }
      }
      Option: {
        payload: Prisma.$OptionPayload<ExtArgs>
        fields: Prisma.OptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findFirst: {
            args: Prisma.OptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findMany: {
            args: Prisma.OptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          create: {
            args: Prisma.OptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          createMany: {
            args: Prisma.OptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          delete: {
            args: Prisma.OptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          update: {
            args: Prisma.OptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          deleteMany: {
            args: Prisma.OptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          upsert: {
            args: Prisma.OptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.OptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      Sensor: {
        payload: Prisma.$SensorPayload<ExtArgs>
        fields: Prisma.SensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findFirst: {
            args: Prisma.SensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findMany: {
            args: Prisma.SensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          create: {
            args: Prisma.SensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          createMany: {
            args: Prisma.SensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          delete: {
            args: Prisma.SensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          update: {
            args: Prisma.SensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          deleteMany: {
            args: Prisma.SensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SensorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          upsert: {
            args: Prisma.SensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          aggregate: {
            args: Prisma.SensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensor>
          }
          groupBy: {
            args: Prisma.SensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorCountArgs<ExtArgs>
            result: $Utils.Optional<SensorCountAggregateOutputType> | number
          }
        }
      }
      ControlType: {
        payload: Prisma.$ControlTypePayload<ExtArgs>
        fields: Prisma.ControlTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ControlTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ControlTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          findFirst: {
            args: Prisma.ControlTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ControlTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          findMany: {
            args: Prisma.ControlTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>[]
          }
          create: {
            args: Prisma.ControlTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          createMany: {
            args: Prisma.ControlTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ControlTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>[]
          }
          delete: {
            args: Prisma.ControlTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          update: {
            args: Prisma.ControlTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          deleteMany: {
            args: Prisma.ControlTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ControlTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ControlTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>[]
          }
          upsert: {
            args: Prisma.ControlTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlTypePayload>
          }
          aggregate: {
            args: Prisma.ControlTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateControlType>
          }
          groupBy: {
            args: Prisma.ControlTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ControlTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ControlTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ControlTypeCountAggregateOutputType> | number
          }
        }
      }
      Pitch: {
        payload: Prisma.$PitchPayload<ExtArgs>
        fields: Prisma.PitchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PitchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PitchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          findFirst: {
            args: Prisma.PitchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PitchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          findMany: {
            args: Prisma.PitchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>[]
          }
          create: {
            args: Prisma.PitchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          createMany: {
            args: Prisma.PitchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PitchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>[]
          }
          delete: {
            args: Prisma.PitchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          update: {
            args: Prisma.PitchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          deleteMany: {
            args: Prisma.PitchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PitchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PitchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>[]
          }
          upsert: {
            args: Prisma.PitchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PitchPayload>
          }
          aggregate: {
            args: Prisma.PitchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePitch>
          }
          groupBy: {
            args: Prisma.PitchGroupByArgs<ExtArgs>
            result: $Utils.Optional<PitchGroupByOutputType>[]
          }
          count: {
            args: Prisma.PitchCountArgs<ExtArgs>
            result: $Utils.Optional<PitchCountAggregateOutputType> | number
          }
        }
      }
      RefreshRate: {
        payload: Prisma.$RefreshRatePayload<ExtArgs>
        fields: Prisma.RefreshRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          findFirst: {
            args: Prisma.RefreshRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          findMany: {
            args: Prisma.RefreshRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>[]
          }
          create: {
            args: Prisma.RefreshRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          createMany: {
            args: Prisma.RefreshRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>[]
          }
          delete: {
            args: Prisma.RefreshRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          update: {
            args: Prisma.RefreshRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          deleteMany: {
            args: Prisma.RefreshRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>[]
          }
          upsert: {
            args: Prisma.RefreshRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshRatePayload>
          }
          aggregate: {
            args: Prisma.RefreshRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshRate>
          }
          groupBy: {
            args: Prisma.RefreshRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshRateCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshRateCountAggregateOutputType> | number
          }
        }
      }
      Brightness: {
        payload: Prisma.$BrightnessPayload<ExtArgs>
        fields: Prisma.BrightnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrightnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrightnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          findFirst: {
            args: Prisma.BrightnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrightnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          findMany: {
            args: Prisma.BrightnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>[]
          }
          create: {
            args: Prisma.BrightnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          createMany: {
            args: Prisma.BrightnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrightnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>[]
          }
          delete: {
            args: Prisma.BrightnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          update: {
            args: Prisma.BrightnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          deleteMany: {
            args: Prisma.BrightnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrightnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrightnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>[]
          }
          upsert: {
            args: Prisma.BrightnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrightnessPayload>
          }
          aggregate: {
            args: Prisma.BrightnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrightness>
          }
          groupBy: {
            args: Prisma.BrightnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrightnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrightnessCountArgs<ExtArgs>
            result: $Utils.Optional<BrightnessCountAggregateOutputType> | number
          }
        }
      }
      Manufacturer: {
        payload: Prisma.$ManufacturerPayload<ExtArgs>
        fields: Prisma.ManufacturerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManufacturerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManufacturerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          findFirst: {
            args: Prisma.ManufacturerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManufacturerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          findMany: {
            args: Prisma.ManufacturerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
          }
          create: {
            args: Prisma.ManufacturerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          createMany: {
            args: Prisma.ManufacturerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManufacturerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
          }
          delete: {
            args: Prisma.ManufacturerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          update: {
            args: Prisma.ManufacturerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          deleteMany: {
            args: Prisma.ManufacturerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManufacturerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManufacturerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>[]
          }
          upsert: {
            args: Prisma.ManufacturerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturerPayload>
          }
          aggregate: {
            args: Prisma.ManufacturerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManufacturer>
          }
          groupBy: {
            args: Prisma.ManufacturerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManufacturerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManufacturerCountArgs<ExtArgs>
            result: $Utils.Optional<ManufacturerCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      IpProtection: {
        payload: Prisma.$IpProtectionPayload<ExtArgs>
        fields: Prisma.IpProtectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IpProtectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IpProtectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          findFirst: {
            args: Prisma.IpProtectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IpProtectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          findMany: {
            args: Prisma.IpProtectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>[]
          }
          create: {
            args: Prisma.IpProtectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          createMany: {
            args: Prisma.IpProtectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IpProtectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>[]
          }
          delete: {
            args: Prisma.IpProtectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          update: {
            args: Prisma.IpProtectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          deleteMany: {
            args: Prisma.IpProtectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IpProtectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IpProtectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>[]
          }
          upsert: {
            args: Prisma.IpProtectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpProtectionPayload>
          }
          aggregate: {
            args: Prisma.IpProtectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIpProtection>
          }
          groupBy: {
            args: Prisma.IpProtectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpProtectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IpProtectionCountArgs<ExtArgs>
            result: $Utils.Optional<IpProtectionCountAggregateOutputType> | number
          }
        }
      }
      ModuleSize: {
        payload: Prisma.$ModuleSizePayload<ExtArgs>
        fields: Prisma.ModuleSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          findFirst: {
            args: Prisma.ModuleSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          findMany: {
            args: Prisma.ModuleSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>[]
          }
          create: {
            args: Prisma.ModuleSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          createMany: {
            args: Prisma.ModuleSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>[]
          }
          delete: {
            args: Prisma.ModuleSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          update: {
            args: Prisma.ModuleSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          deleteMany: {
            args: Prisma.ModuleSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>[]
          }
          upsert: {
            args: Prisma.ModuleSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSizePayload>
          }
          aggregate: {
            args: Prisma.ModuleSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleSize>
          }
          groupBy: {
            args: Prisma.ModuleSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleSizeCountAggregateOutputType> | number
          }
        }
      }
      CabinetSize: {
        payload: Prisma.$CabinetSizePayload<ExtArgs>
        fields: Prisma.CabinetSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          findFirst: {
            args: Prisma.CabinetSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          findMany: {
            args: Prisma.CabinetSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>[]
          }
          create: {
            args: Prisma.CabinetSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          createMany: {
            args: Prisma.CabinetSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>[]
          }
          delete: {
            args: Prisma.CabinetSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          update: {
            args: Prisma.CabinetSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          deleteMany: {
            args: Prisma.CabinetSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>[]
          }
          upsert: {
            args: Prisma.CabinetSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizePayload>
          }
          aggregate: {
            args: Prisma.CabinetSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetSize>
          }
          groupBy: {
            args: Prisma.CabinetSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetSizeCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetSizeCountAggregateOutputType> | number
          }
        }
      }
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      ItemSubcategory: {
        payload: Prisma.$ItemSubcategoryPayload<ExtArgs>
        fields: Prisma.ItemSubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemSubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemSubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemSubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemSubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          findMany: {
            args: Prisma.ItemSubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>[]
          }
          create: {
            args: Prisma.ItemSubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          createMany: {
            args: Prisma.ItemSubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemSubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemSubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          update: {
            args: Prisma.ItemSubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemSubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemSubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemSubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemSubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemSubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemSubcategory>
          }
          groupBy: {
            args: Prisma.ItemSubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemSubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemSubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemSubcategoryCountAggregateOutputType> | number
          }
        }
      }
      Cabinet: {
        payload: Prisma.$CabinetPayload<ExtArgs>
        fields: Prisma.CabinetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          findFirst: {
            args: Prisma.CabinetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          findMany: {
            args: Prisma.CabinetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>[]
          }
          create: {
            args: Prisma.CabinetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          createMany: {
            args: Prisma.CabinetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>[]
          }
          delete: {
            args: Prisma.CabinetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          update: {
            args: Prisma.CabinetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          deleteMany: {
            args: Prisma.CabinetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>[]
          }
          upsert: {
            args: Prisma.CabinetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPayload>
          }
          aggregate: {
            args: Prisma.CabinetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinet>
          }
          groupBy: {
            args: Prisma.CabinetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ScreenTypeOption: {
        payload: Prisma.$ScreenTypeOptionPayload<ExtArgs>
        fields: Prisma.ScreenTypeOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenTypeOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenTypeOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          findFirst: {
            args: Prisma.ScreenTypeOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenTypeOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          findMany: {
            args: Prisma.ScreenTypeOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>[]
          }
          create: {
            args: Prisma.ScreenTypeOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          createMany: {
            args: Prisma.ScreenTypeOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenTypeOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>[]
          }
          delete: {
            args: Prisma.ScreenTypeOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          update: {
            args: Prisma.ScreenTypeOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          deleteMany: {
            args: Prisma.ScreenTypeOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenTypeOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenTypeOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>[]
          }
          upsert: {
            args: Prisma.ScreenTypeOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeOptionPayload>
          }
          aggregate: {
            args: Prisma.ScreenTypeOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenTypeOption>
          }
          groupBy: {
            args: Prisma.ScreenTypeOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenTypeOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeOptionCountAggregateOutputType> | number
          }
        }
      }
      ScreenTypeControlType: {
        payload: Prisma.$ScreenTypeControlTypePayload<ExtArgs>
        fields: Prisma.ScreenTypeControlTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenTypeControlTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenTypeControlTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          findFirst: {
            args: Prisma.ScreenTypeControlTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenTypeControlTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          findMany: {
            args: Prisma.ScreenTypeControlTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>[]
          }
          create: {
            args: Prisma.ScreenTypeControlTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          createMany: {
            args: Prisma.ScreenTypeControlTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenTypeControlTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>[]
          }
          delete: {
            args: Prisma.ScreenTypeControlTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          update: {
            args: Prisma.ScreenTypeControlTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          deleteMany: {
            args: Prisma.ScreenTypeControlTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenTypeControlTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenTypeControlTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>[]
          }
          upsert: {
            args: Prisma.ScreenTypeControlTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeControlTypePayload>
          }
          aggregate: {
            args: Prisma.ScreenTypeControlTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenTypeControlType>
          }
          groupBy: {
            args: Prisma.ScreenTypeControlTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeControlTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenTypeControlTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeControlTypeCountAggregateOutputType> | number
          }
        }
      }
      ScreenTypeSensor: {
        payload: Prisma.$ScreenTypeSensorPayload<ExtArgs>
        fields: Prisma.ScreenTypeSensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenTypeSensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenTypeSensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          findFirst: {
            args: Prisma.ScreenTypeSensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenTypeSensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          findMany: {
            args: Prisma.ScreenTypeSensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>[]
          }
          create: {
            args: Prisma.ScreenTypeSensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          createMany: {
            args: Prisma.ScreenTypeSensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenTypeSensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>[]
          }
          delete: {
            args: Prisma.ScreenTypeSensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          update: {
            args: Prisma.ScreenTypeSensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          deleteMany: {
            args: Prisma.ScreenTypeSensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenTypeSensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenTypeSensorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>[]
          }
          upsert: {
            args: Prisma.ScreenTypeSensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTypeSensorPayload>
          }
          aggregate: {
            args: Prisma.ScreenTypeSensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenTypeSensor>
          }
          groupBy: {
            args: Prisma.ScreenTypeSensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeSensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenTypeSensorCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenTypeSensorCountAggregateOutputType> | number
          }
        }
      }
      ItemCategoryRelation: {
        payload: Prisma.$ItemCategoryRelationPayload<ExtArgs>
        fields: Prisma.ItemCategoryRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          update: {
            args: Prisma.ItemCategoryRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryRelationPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategoryRelation>
          }
          groupBy: {
            args: Prisma.ItemCategoryRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryRelationCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryRelationCountAggregateOutputType> | number
          }
        }
      }
      ItemSubcategoryRelation: {
        payload: Prisma.$ItemSubcategoryRelationPayload<ExtArgs>
        fields: Prisma.ItemSubcategoryRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemSubcategoryRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemSubcategoryRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          findFirst: {
            args: Prisma.ItemSubcategoryRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemSubcategoryRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          findMany: {
            args: Prisma.ItemSubcategoryRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>[]
          }
          create: {
            args: Prisma.ItemSubcategoryRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          createMany: {
            args: Prisma.ItemSubcategoryRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemSubcategoryRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>[]
          }
          delete: {
            args: Prisma.ItemSubcategoryRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          update: {
            args: Prisma.ItemSubcategoryRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          deleteMany: {
            args: Prisma.ItemSubcategoryRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemSubcategoryRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemSubcategoryRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>[]
          }
          upsert: {
            args: Prisma.ItemSubcategoryRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSubcategoryRelationPayload>
          }
          aggregate: {
            args: Prisma.ItemSubcategoryRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemSubcategoryRelation>
          }
          groupBy: {
            args: Prisma.ItemSubcategoryRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemSubcategoryRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemSubcategoryRelationCountArgs<ExtArgs>
            result: $Utils.Optional<ItemSubcategoryRelationCountAggregateOutputType> | number
          }
        }
      }
      ItemPrice: {
        payload: Prisma.$ItemPricePayload<ExtArgs>
        fields: Prisma.ItemPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          findFirst: {
            args: Prisma.ItemPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          findMany: {
            args: Prisma.ItemPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>[]
          }
          create: {
            args: Prisma.ItemPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          createMany: {
            args: Prisma.ItemPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>[]
          }
          delete: {
            args: Prisma.ItemPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          update: {
            args: Prisma.ItemPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          deleteMany: {
            args: Prisma.ItemPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>[]
          }
          upsert: {
            args: Prisma.ItemPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPricePayload>
          }
          aggregate: {
            args: Prisma.ItemPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemPrice>
          }
          groupBy: {
            args: Prisma.ItemPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemPriceCountArgs<ExtArgs>
            result: $Utils.Optional<ItemPriceCountAggregateOutputType> | number
          }
        }
      }
      ItemSupplier: {
        payload: Prisma.$ItemSupplierPayload<ExtArgs>
        fields: Prisma.ItemSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          findFirst: {
            args: Prisma.ItemSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          findMany: {
            args: Prisma.ItemSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          create: {
            args: Prisma.ItemSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          createMany: {
            args: Prisma.ItemSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          delete: {
            args: Prisma.ItemSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          update: {
            args: Prisma.ItemSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          deleteMany: {
            args: Prisma.ItemSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          upsert: {
            args: Prisma.ItemSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          aggregate: {
            args: Prisma.ItemSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemSupplier>
          }
          groupBy: {
            args: Prisma.ItemSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<ItemSupplierCountAggregateOutputType> | number
          }
        }
      }
      ItemCategorySubcategory: {
        payload: Prisma.$ItemCategorySubcategoryPayload<ExtArgs>
        fields: Prisma.ItemCategorySubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategorySubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategorySubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategorySubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategorySubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategorySubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategorySubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategorySubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategorySubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategorySubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          update: {
            args: Prisma.ItemCategorySubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategorySubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategorySubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategorySubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategorySubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategorySubcategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategorySubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategorySubcategory>
          }
          groupBy: {
            args: Prisma.ItemCategorySubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategorySubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategorySubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategorySubcategoryCountAggregateOutputType> | number
          }
        }
      }
      CabinetCategory: {
        payload: Prisma.$CabinetCategoryPayload<ExtArgs>
        fields: Prisma.CabinetCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          findFirst: {
            args: Prisma.CabinetCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          findMany: {
            args: Prisma.CabinetCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>[]
          }
          create: {
            args: Prisma.CabinetCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          createMany: {
            args: Prisma.CabinetCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>[]
          }
          delete: {
            args: Prisma.CabinetCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          update: {
            args: Prisma.CabinetCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CabinetCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>[]
          }
          upsert: {
            args: Prisma.CabinetCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCategoryPayload>
          }
          aggregate: {
            args: Prisma.CabinetCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetCategory>
          }
          groupBy: {
            args: Prisma.CabinetCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetCategoryCountAggregateOutputType> | number
          }
        }
      }
      CabinetSubcategory: {
        payload: Prisma.$CabinetSubcategoryPayload<ExtArgs>
        fields: Prisma.CabinetSubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetSubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetSubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          findFirst: {
            args: Prisma.CabinetSubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetSubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          findMany: {
            args: Prisma.CabinetSubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>[]
          }
          create: {
            args: Prisma.CabinetSubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          createMany: {
            args: Prisma.CabinetSubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetSubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>[]
          }
          delete: {
            args: Prisma.CabinetSubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          update: {
            args: Prisma.CabinetSubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.CabinetSubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetSubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetSubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.CabinetSubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSubcategoryPayload>
          }
          aggregate: {
            args: Prisma.CabinetSubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetSubcategory>
          }
          groupBy: {
            args: Prisma.CabinetSubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetSubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetSubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetSubcategoryCountAggregateOutputType> | number
          }
        }
      }
      CabinetLocation: {
        payload: Prisma.$CabinetLocationPayload<ExtArgs>
        fields: Prisma.CabinetLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          findFirst: {
            args: Prisma.CabinetLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          findMany: {
            args: Prisma.CabinetLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>[]
          }
          create: {
            args: Prisma.CabinetLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          createMany: {
            args: Prisma.CabinetLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>[]
          }
          delete: {
            args: Prisma.CabinetLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          update: {
            args: Prisma.CabinetLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          deleteMany: {
            args: Prisma.CabinetLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>[]
          }
          upsert: {
            args: Prisma.CabinetLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetLocationPayload>
          }
          aggregate: {
            args: Prisma.CabinetLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetLocation>
          }
          groupBy: {
            args: Prisma.CabinetLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetLocationCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetLocationCountAggregateOutputType> | number
          }
        }
      }
      CabinetPlacement: {
        payload: Prisma.$CabinetPlacementPayload<ExtArgs>
        fields: Prisma.CabinetPlacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetPlacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetPlacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          findFirst: {
            args: Prisma.CabinetPlacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetPlacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          findMany: {
            args: Prisma.CabinetPlacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>[]
          }
          create: {
            args: Prisma.CabinetPlacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          createMany: {
            args: Prisma.CabinetPlacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetPlacementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>[]
          }
          delete: {
            args: Prisma.CabinetPlacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          update: {
            args: Prisma.CabinetPlacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          deleteMany: {
            args: Prisma.CabinetPlacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetPlacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetPlacementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>[]
          }
          upsert: {
            args: Prisma.CabinetPlacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPlacementPayload>
          }
          aggregate: {
            args: Prisma.CabinetPlacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetPlacement>
          }
          groupBy: {
            args: Prisma.CabinetPlacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetPlacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetPlacementCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetPlacementCountAggregateOutputType> | number
          }
        }
      }
      CabinetMaterial: {
        payload: Prisma.$CabinetMaterialPayload<ExtArgs>
        fields: Prisma.CabinetMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          findFirst: {
            args: Prisma.CabinetMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          findMany: {
            args: Prisma.CabinetMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>[]
          }
          create: {
            args: Prisma.CabinetMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          createMany: {
            args: Prisma.CabinetMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>[]
          }
          delete: {
            args: Prisma.CabinetMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          update: {
            args: Prisma.CabinetMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          deleteMany: {
            args: Prisma.CabinetMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>[]
          }
          upsert: {
            args: Prisma.CabinetMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetMaterialPayload>
          }
          aggregate: {
            args: Prisma.CabinetMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetMaterial>
          }
          groupBy: {
            args: Prisma.CabinetMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetMaterialCountAggregateOutputType> | number
          }
        }
      }
      CabinetCabinetSize: {
        payload: Prisma.$CabinetCabinetSizePayload<ExtArgs>
        fields: Prisma.CabinetCabinetSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetCabinetSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetCabinetSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          findFirst: {
            args: Prisma.CabinetCabinetSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetCabinetSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          findMany: {
            args: Prisma.CabinetCabinetSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>[]
          }
          create: {
            args: Prisma.CabinetCabinetSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          createMany: {
            args: Prisma.CabinetCabinetSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetCabinetSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>[]
          }
          delete: {
            args: Prisma.CabinetCabinetSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          update: {
            args: Prisma.CabinetCabinetSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          deleteMany: {
            args: Prisma.CabinetCabinetSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetCabinetSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetCabinetSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>[]
          }
          upsert: {
            args: Prisma.CabinetCabinetSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetCabinetSizePayload>
          }
          aggregate: {
            args: Prisma.CabinetCabinetSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetCabinetSize>
          }
          groupBy: {
            args: Prisma.CabinetCabinetSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetCabinetSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetCabinetSizeCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetCabinetSizeCountAggregateOutputType> | number
          }
        }
      }
      CabinetPitch: {
        payload: Prisma.$CabinetPitchPayload<ExtArgs>
        fields: Prisma.CabinetPitchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetPitchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetPitchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          findFirst: {
            args: Prisma.CabinetPitchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetPitchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          findMany: {
            args: Prisma.CabinetPitchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>[]
          }
          create: {
            args: Prisma.CabinetPitchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          createMany: {
            args: Prisma.CabinetPitchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetPitchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>[]
          }
          delete: {
            args: Prisma.CabinetPitchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          update: {
            args: Prisma.CabinetPitchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          deleteMany: {
            args: Prisma.CabinetPitchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetPitchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetPitchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>[]
          }
          upsert: {
            args: Prisma.CabinetPitchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPitchPayload>
          }
          aggregate: {
            args: Prisma.CabinetPitchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetPitch>
          }
          groupBy: {
            args: Prisma.CabinetPitchGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetPitchGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetPitchCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetPitchCountAggregateOutputType> | number
          }
        }
      }
      CabinetManufacturer: {
        payload: Prisma.$CabinetManufacturerPayload<ExtArgs>
        fields: Prisma.CabinetManufacturerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetManufacturerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetManufacturerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          findFirst: {
            args: Prisma.CabinetManufacturerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetManufacturerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          findMany: {
            args: Prisma.CabinetManufacturerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>[]
          }
          create: {
            args: Prisma.CabinetManufacturerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          createMany: {
            args: Prisma.CabinetManufacturerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetManufacturerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>[]
          }
          delete: {
            args: Prisma.CabinetManufacturerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          update: {
            args: Prisma.CabinetManufacturerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          deleteMany: {
            args: Prisma.CabinetManufacturerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetManufacturerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetManufacturerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>[]
          }
          upsert: {
            args: Prisma.CabinetManufacturerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetManufacturerPayload>
          }
          aggregate: {
            args: Prisma.CabinetManufacturerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetManufacturer>
          }
          groupBy: {
            args: Prisma.CabinetManufacturerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetManufacturerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetManufacturerCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetManufacturerCountAggregateOutputType> | number
          }
        }
      }
      CabinetSupplier: {
        payload: Prisma.$CabinetSupplierPayload<ExtArgs>
        fields: Prisma.CabinetSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          findFirst: {
            args: Prisma.CabinetSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          findMany: {
            args: Prisma.CabinetSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>[]
          }
          create: {
            args: Prisma.CabinetSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          createMany: {
            args: Prisma.CabinetSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>[]
          }
          delete: {
            args: Prisma.CabinetSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          update: {
            args: Prisma.CabinetSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          deleteMany: {
            args: Prisma.CabinetSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>[]
          }
          upsert: {
            args: Prisma.CabinetSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSupplierPayload>
          }
          aggregate: {
            args: Prisma.CabinetSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetSupplier>
          }
          groupBy: {
            args: Prisma.CabinetSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetSupplierCountAggregateOutputType> | number
          }
        }
      }
      CabinetItemComponent: {
        payload: Prisma.$CabinetItemComponentPayload<ExtArgs>
        fields: Prisma.CabinetItemComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetItemComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetItemComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          findFirst: {
            args: Prisma.CabinetItemComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetItemComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          findMany: {
            args: Prisma.CabinetItemComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>[]
          }
          create: {
            args: Prisma.CabinetItemComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          createMany: {
            args: Prisma.CabinetItemComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetItemComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>[]
          }
          delete: {
            args: Prisma.CabinetItemComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          update: {
            args: Prisma.CabinetItemComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          deleteMany: {
            args: Prisma.CabinetItemComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetItemComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetItemComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>[]
          }
          upsert: {
            args: Prisma.CabinetItemComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetItemComponentPayload>
          }
          aggregate: {
            args: Prisma.CabinetItemComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetItemComponent>
          }
          groupBy: {
            args: Prisma.CabinetItemComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetItemComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetItemComponentCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetItemComponentCountAggregateOutputType> | number
          }
        }
      }
      CabinetPrice: {
        payload: Prisma.$CabinetPricePayload<ExtArgs>
        fields: Prisma.CabinetPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          findFirst: {
            args: Prisma.CabinetPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          findMany: {
            args: Prisma.CabinetPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>[]
          }
          create: {
            args: Prisma.CabinetPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          createMany: {
            args: Prisma.CabinetPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>[]
          }
          delete: {
            args: Prisma.CabinetPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          update: {
            args: Prisma.CabinetPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          deleteMany: {
            args: Prisma.CabinetPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>[]
          }
          upsert: {
            args: Prisma.CabinetPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetPricePayload>
          }
          aggregate: {
            args: Prisma.CabinetPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetPrice>
          }
          groupBy: {
            args: Prisma.CabinetPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetPriceCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetPriceCountAggregateOutputType> | number
          }
        }
      }
      ModuleCategory: {
        payload: Prisma.$ModuleCategoryPayload<ExtArgs>
        fields: Prisma.ModuleCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          findFirst: {
            args: Prisma.ModuleCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          findMany: {
            args: Prisma.ModuleCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>[]
          }
          create: {
            args: Prisma.ModuleCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          createMany: {
            args: Prisma.ModuleCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>[]
          }
          delete: {
            args: Prisma.ModuleCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          update: {
            args: Prisma.ModuleCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ModuleCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ModuleCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleCategoryPayload>
          }
          aggregate: {
            args: Prisma.ModuleCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleCategory>
          }
          groupBy: {
            args: Prisma.ModuleCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCategoryCountAggregateOutputType> | number
          }
        }
      }
      ModuleSubcategory: {
        payload: Prisma.$ModuleSubcategoryPayload<ExtArgs>
        fields: Prisma.ModuleSubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleSubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleSubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          findFirst: {
            args: Prisma.ModuleSubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleSubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          findMany: {
            args: Prisma.ModuleSubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>[]
          }
          create: {
            args: Prisma.ModuleSubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          createMany: {
            args: Prisma.ModuleSubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleSubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>[]
          }
          delete: {
            args: Prisma.ModuleSubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          update: {
            args: Prisma.ModuleSubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.ModuleSubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleSubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleSubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.ModuleSubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleSubcategoryPayload>
          }
          aggregate: {
            args: Prisma.ModuleSubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleSubcategory>
          }
          groupBy: {
            args: Prisma.ModuleSubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleSubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleSubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleSubcategoryCountAggregateOutputType> | number
          }
        }
      }
      ModuleLocation: {
        payload: Prisma.$ModuleLocationPayload<ExtArgs>
        fields: Prisma.ModuleLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          findFirst: {
            args: Prisma.ModuleLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          findMany: {
            args: Prisma.ModuleLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>[]
          }
          create: {
            args: Prisma.ModuleLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          createMany: {
            args: Prisma.ModuleLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>[]
          }
          delete: {
            args: Prisma.ModuleLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          update: {
            args: Prisma.ModuleLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          deleteMany: {
            args: Prisma.ModuleLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>[]
          }
          upsert: {
            args: Prisma.ModuleLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleLocationPayload>
          }
          aggregate: {
            args: Prisma.ModuleLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleLocation>
          }
          groupBy: {
            args: Prisma.ModuleLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleLocationCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleLocationCountAggregateOutputType> | number
          }
        }
      }
      ModuleRefreshRate: {
        payload: Prisma.$ModuleRefreshRatePayload<ExtArgs>
        fields: Prisma.ModuleRefreshRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleRefreshRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleRefreshRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          findFirst: {
            args: Prisma.ModuleRefreshRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleRefreshRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          findMany: {
            args: Prisma.ModuleRefreshRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>[]
          }
          create: {
            args: Prisma.ModuleRefreshRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          createMany: {
            args: Prisma.ModuleRefreshRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleRefreshRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>[]
          }
          delete: {
            args: Prisma.ModuleRefreshRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          update: {
            args: Prisma.ModuleRefreshRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          deleteMany: {
            args: Prisma.ModuleRefreshRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleRefreshRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleRefreshRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>[]
          }
          upsert: {
            args: Prisma.ModuleRefreshRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleRefreshRatePayload>
          }
          aggregate: {
            args: Prisma.ModuleRefreshRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleRefreshRate>
          }
          groupBy: {
            args: Prisma.ModuleRefreshRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleRefreshRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleRefreshRateCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleRefreshRateCountAggregateOutputType> | number
          }
        }
      }
      ModuleBrightness: {
        payload: Prisma.$ModuleBrightnessPayload<ExtArgs>
        fields: Prisma.ModuleBrightnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleBrightnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleBrightnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          findFirst: {
            args: Prisma.ModuleBrightnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleBrightnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          findMany: {
            args: Prisma.ModuleBrightnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>[]
          }
          create: {
            args: Prisma.ModuleBrightnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          createMany: {
            args: Prisma.ModuleBrightnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleBrightnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>[]
          }
          delete: {
            args: Prisma.ModuleBrightnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          update: {
            args: Prisma.ModuleBrightnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          deleteMany: {
            args: Prisma.ModuleBrightnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleBrightnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleBrightnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>[]
          }
          upsert: {
            args: Prisma.ModuleBrightnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleBrightnessPayload>
          }
          aggregate: {
            args: Prisma.ModuleBrightnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleBrightness>
          }
          groupBy: {
            args: Prisma.ModuleBrightnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleBrightnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleBrightnessCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleBrightnessCountAggregateOutputType> | number
          }
        }
      }
      ModuleModuleSize: {
        payload: Prisma.$ModuleModuleSizePayload<ExtArgs>
        fields: Prisma.ModuleModuleSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleModuleSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleModuleSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          findFirst: {
            args: Prisma.ModuleModuleSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleModuleSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          findMany: {
            args: Prisma.ModuleModuleSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>[]
          }
          create: {
            args: Prisma.ModuleModuleSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          createMany: {
            args: Prisma.ModuleModuleSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleModuleSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>[]
          }
          delete: {
            args: Prisma.ModuleModuleSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          update: {
            args: Prisma.ModuleModuleSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          deleteMany: {
            args: Prisma.ModuleModuleSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleModuleSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleModuleSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>[]
          }
          upsert: {
            args: Prisma.ModuleModuleSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleModuleSizePayload>
          }
          aggregate: {
            args: Prisma.ModuleModuleSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleModuleSize>
          }
          groupBy: {
            args: Prisma.ModuleModuleSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleModuleSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleModuleSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleModuleSizeCountAggregateOutputType> | number
          }
        }
      }
      ModulePitch: {
        payload: Prisma.$ModulePitchPayload<ExtArgs>
        fields: Prisma.ModulePitchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModulePitchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModulePitchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          findFirst: {
            args: Prisma.ModulePitchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModulePitchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          findMany: {
            args: Prisma.ModulePitchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>[]
          }
          create: {
            args: Prisma.ModulePitchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          createMany: {
            args: Prisma.ModulePitchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModulePitchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>[]
          }
          delete: {
            args: Prisma.ModulePitchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          update: {
            args: Prisma.ModulePitchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          deleteMany: {
            args: Prisma.ModulePitchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModulePitchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModulePitchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>[]
          }
          upsert: {
            args: Prisma.ModulePitchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePitchPayload>
          }
          aggregate: {
            args: Prisma.ModulePitchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulePitch>
          }
          groupBy: {
            args: Prisma.ModulePitchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulePitchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModulePitchCountArgs<ExtArgs>
            result: $Utils.Optional<ModulePitchCountAggregateOutputType> | number
          }
        }
      }
      ModuleManufacturer: {
        payload: Prisma.$ModuleManufacturerPayload<ExtArgs>
        fields: Prisma.ModuleManufacturerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleManufacturerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleManufacturerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          findFirst: {
            args: Prisma.ModuleManufacturerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleManufacturerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          findMany: {
            args: Prisma.ModuleManufacturerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>[]
          }
          create: {
            args: Prisma.ModuleManufacturerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          createMany: {
            args: Prisma.ModuleManufacturerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleManufacturerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>[]
          }
          delete: {
            args: Prisma.ModuleManufacturerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          update: {
            args: Prisma.ModuleManufacturerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          deleteMany: {
            args: Prisma.ModuleManufacturerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleManufacturerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleManufacturerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>[]
          }
          upsert: {
            args: Prisma.ModuleManufacturerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleManufacturerPayload>
          }
          aggregate: {
            args: Prisma.ModuleManufacturerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleManufacturer>
          }
          groupBy: {
            args: Prisma.ModuleManufacturerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleManufacturerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleManufacturerCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleManufacturerCountAggregateOutputType> | number
          }
        }
      }
      ModuleItemComponent: {
        payload: Prisma.$ModuleItemComponentPayload<ExtArgs>
        fields: Prisma.ModuleItemComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleItemComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleItemComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          findFirst: {
            args: Prisma.ModuleItemComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleItemComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          findMany: {
            args: Prisma.ModuleItemComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>[]
          }
          create: {
            args: Prisma.ModuleItemComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          createMany: {
            args: Prisma.ModuleItemComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleItemComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>[]
          }
          delete: {
            args: Prisma.ModuleItemComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          update: {
            args: Prisma.ModuleItemComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          deleteMany: {
            args: Prisma.ModuleItemComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleItemComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleItemComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>[]
          }
          upsert: {
            args: Prisma.ModuleItemComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleItemComponentPayload>
          }
          aggregate: {
            args: Prisma.ModuleItemComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleItemComponent>
          }
          groupBy: {
            args: Prisma.ModuleItemComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleItemComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleItemComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleItemComponentCountAggregateOutputType> | number
          }
        }
      }
      ModuleOption: {
        payload: Prisma.$ModuleOptionPayload<ExtArgs>
        fields: Prisma.ModuleOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          findFirst: {
            args: Prisma.ModuleOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          findMany: {
            args: Prisma.ModuleOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>[]
          }
          create: {
            args: Prisma.ModuleOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          createMany: {
            args: Prisma.ModuleOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>[]
          }
          delete: {
            args: Prisma.ModuleOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          update: {
            args: Prisma.ModuleOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          deleteMany: {
            args: Prisma.ModuleOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>[]
          }
          upsert: {
            args: Prisma.ModuleOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleOptionPayload>
          }
          aggregate: {
            args: Prisma.ModuleOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleOption>
          }
          groupBy: {
            args: Prisma.ModuleOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleOptionCountAggregateOutputType> | number
          }
        }
      }
      ModulePrice: {
        payload: Prisma.$ModulePricePayload<ExtArgs>
        fields: Prisma.ModulePriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModulePriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModulePriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          findFirst: {
            args: Prisma.ModulePriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModulePriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          findMany: {
            args: Prisma.ModulePriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>[]
          }
          create: {
            args: Prisma.ModulePriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          createMany: {
            args: Prisma.ModulePriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModulePriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>[]
          }
          delete: {
            args: Prisma.ModulePriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          update: {
            args: Prisma.ModulePriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          deleteMany: {
            args: Prisma.ModulePriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModulePriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModulePriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>[]
          }
          upsert: {
            args: Prisma.ModulePriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePricePayload>
          }
          aggregate: {
            args: Prisma.ModulePriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulePrice>
          }
          groupBy: {
            args: Prisma.ModulePriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulePriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModulePriceCountArgs<ExtArgs>
            result: $Utils.Optional<ModulePriceCountAggregateOutputType> | number
          }
        }
      }
      CabinetSizeModuleSize: {
        payload: Prisma.$CabinetSizeModuleSizePayload<ExtArgs>
        fields: Prisma.CabinetSizeModuleSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetSizeModuleSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetSizeModuleSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          findFirst: {
            args: Prisma.CabinetSizeModuleSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetSizeModuleSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          findMany: {
            args: Prisma.CabinetSizeModuleSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>[]
          }
          create: {
            args: Prisma.CabinetSizeModuleSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          createMany: {
            args: Prisma.CabinetSizeModuleSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetSizeModuleSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>[]
          }
          delete: {
            args: Prisma.CabinetSizeModuleSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          update: {
            args: Prisma.CabinetSizeModuleSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          deleteMany: {
            args: Prisma.CabinetSizeModuleSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetSizeModuleSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetSizeModuleSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>[]
          }
          upsert: {
            args: Prisma.CabinetSizeModuleSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetSizeModuleSizePayload>
          }
          aggregate: {
            args: Prisma.CabinetSizeModuleSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetSizeModuleSize>
          }
          groupBy: {
            args: Prisma.CabinetSizeModuleSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetSizeModuleSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetSizeModuleSizeCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetSizeModuleSizeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    screenType?: ScreenTypeOmit
    material?: MaterialOmit
    location?: LocationOmit
    placement?: PlacementOmit
    option?: OptionOmit
    sensor?: SensorOmit
    controlType?: ControlTypeOmit
    pitch?: PitchOmit
    refreshRate?: RefreshRateOmit
    brightness?: BrightnessOmit
    manufacturer?: ManufacturerOmit
    supplier?: SupplierOmit
    ipProtection?: IpProtectionOmit
    moduleSize?: ModuleSizeOmit
    cabinetSize?: CabinetSizeOmit
    itemCategory?: ItemCategoryOmit
    itemSubcategory?: ItemSubcategoryOmit
    cabinet?: CabinetOmit
    module?: ModuleOmit
    item?: ItemOmit
    screenTypeOption?: ScreenTypeOptionOmit
    screenTypeControlType?: ScreenTypeControlTypeOmit
    screenTypeSensor?: ScreenTypeSensorOmit
    itemCategoryRelation?: ItemCategoryRelationOmit
    itemSubcategoryRelation?: ItemSubcategoryRelationOmit
    itemPrice?: ItemPriceOmit
    itemSupplier?: ItemSupplierOmit
    itemCategorySubcategory?: ItemCategorySubcategoryOmit
    cabinetCategory?: CabinetCategoryOmit
    cabinetSubcategory?: CabinetSubcategoryOmit
    cabinetLocation?: CabinetLocationOmit
    cabinetPlacement?: CabinetPlacementOmit
    cabinetMaterial?: CabinetMaterialOmit
    cabinetCabinetSize?: CabinetCabinetSizeOmit
    cabinetPitch?: CabinetPitchOmit
    cabinetManufacturer?: CabinetManufacturerOmit
    cabinetSupplier?: CabinetSupplierOmit
    cabinetItemComponent?: CabinetItemComponentOmit
    cabinetPrice?: CabinetPriceOmit
    moduleCategory?: ModuleCategoryOmit
    moduleSubcategory?: ModuleSubcategoryOmit
    moduleLocation?: ModuleLocationOmit
    moduleRefreshRate?: ModuleRefreshRateOmit
    moduleBrightness?: ModuleBrightnessOmit
    moduleModuleSize?: ModuleModuleSizeOmit
    modulePitch?: ModulePitchOmit
    moduleManufacturer?: ModuleManufacturerOmit
    moduleItemComponent?: ModuleItemComponentOmit
    moduleOption?: ModuleOptionOmit
    modulePrice?: ModulePriceOmit
    cabinetSizeModuleSize?: CabinetSizeModuleSizeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ScreenTypeCountOutputType
   */

  export type ScreenTypeCountOutputType = {
    options: number
    controlTypes: number
    sensors: number
  }

  export type ScreenTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ScreenTypeCountOutputTypeCountOptionsArgs
    controlTypes?: boolean | ScreenTypeCountOutputTypeCountControlTypesArgs
    sensors?: boolean | ScreenTypeCountOutputTypeCountSensorsArgs
  }

  // Custom InputTypes
  /**
   * ScreenTypeCountOutputType without action
   */
  export type ScreenTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeCountOutputType
     */
    select?: ScreenTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScreenTypeCountOutputType without action
   */
  export type ScreenTypeCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeOptionWhereInput
  }

  /**
   * ScreenTypeCountOutputType without action
   */
  export type ScreenTypeCountOutputTypeCountControlTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeControlTypeWhereInput
  }

  /**
   * ScreenTypeCountOutputType without action
   */
  export type ScreenTypeCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeSensorWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    cabinets: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | MaterialCountOutputTypeCountCabinetsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetMaterialWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    cabinets: number
    modules: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | LocationCountOutputTypeCountCabinetsArgs
    modules?: boolean | LocationCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetLocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleLocationWhereInput
  }


  /**
   * Count Type PlacementCountOutputType
   */

  export type PlacementCountOutputType = {
    cabinets: number
  }

  export type PlacementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | PlacementCountOutputTypeCountCabinetsArgs
  }

  // Custom InputTypes
  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementCountOutputType
     */
    select?: PlacementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPlacementWhereInput
  }


  /**
   * Count Type OptionCountOutputType
   */

  export type OptionCountOutputType = {
    screenTypes: number
    modules: number
  }

  export type OptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | OptionCountOutputTypeCountScreenTypesArgs
    modules?: boolean | OptionCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     */
    select?: OptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountScreenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeOptionWhereInput
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleOptionWhereInput
  }


  /**
   * Count Type SensorCountOutputType
   */

  export type SensorCountOutputType = {
    screenTypes: number
  }

  export type SensorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | SensorCountOutputTypeCountScreenTypesArgs
  }

  // Custom InputTypes
  /**
   * SensorCountOutputType without action
   */
  export type SensorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorCountOutputType
     */
    select?: SensorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SensorCountOutputType without action
   */
  export type SensorCountOutputTypeCountScreenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeSensorWhereInput
  }


  /**
   * Count Type ControlTypeCountOutputType
   */

  export type ControlTypeCountOutputType = {
    screenTypes: number
  }

  export type ControlTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | ControlTypeCountOutputTypeCountScreenTypesArgs
  }

  // Custom InputTypes
  /**
   * ControlTypeCountOutputType without action
   */
  export type ControlTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlTypeCountOutputType
     */
    select?: ControlTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ControlTypeCountOutputType without action
   */
  export type ControlTypeCountOutputTypeCountScreenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeControlTypeWhereInput
  }


  /**
   * Count Type PitchCountOutputType
   */

  export type PitchCountOutputType = {
    cabinets: number
    modules: number
  }

  export type PitchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | PitchCountOutputTypeCountCabinetsArgs
    modules?: boolean | PitchCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * PitchCountOutputType without action
   */
  export type PitchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PitchCountOutputType
     */
    select?: PitchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PitchCountOutputType without action
   */
  export type PitchCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPitchWhereInput
  }

  /**
   * PitchCountOutputType without action
   */
  export type PitchCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePitchWhereInput
  }


  /**
   * Count Type RefreshRateCountOutputType
   */

  export type RefreshRateCountOutputType = {
    modules: number
  }

  export type RefreshRateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | RefreshRateCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * RefreshRateCountOutputType without action
   */
  export type RefreshRateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRateCountOutputType
     */
    select?: RefreshRateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RefreshRateCountOutputType without action
   */
  export type RefreshRateCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleRefreshRateWhereInput
  }


  /**
   * Count Type BrightnessCountOutputType
   */

  export type BrightnessCountOutputType = {
    modules: number
  }

  export type BrightnessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | BrightnessCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * BrightnessCountOutputType without action
   */
  export type BrightnessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrightnessCountOutputType
     */
    select?: BrightnessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrightnessCountOutputType without action
   */
  export type BrightnessCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleBrightnessWhereInput
  }


  /**
   * Count Type ManufacturerCountOutputType
   */

  export type ManufacturerCountOutputType = {
    cabinets: number
    modules: number
  }

  export type ManufacturerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | ManufacturerCountOutputTypeCountCabinetsArgs
    modules?: boolean | ManufacturerCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ManufacturerCountOutputType without action
   */
  export type ManufacturerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturerCountOutputType
     */
    select?: ManufacturerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManufacturerCountOutputType without action
   */
  export type ManufacturerCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetManufacturerWhereInput
  }

  /**
   * ManufacturerCountOutputType without action
   */
  export type ManufacturerCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleManufacturerWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    cabinets: number
    items: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | SupplierCountOutputTypeCountCabinetsArgs
    items?: boolean | SupplierCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSupplierWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
  }


  /**
   * Count Type ModuleSizeCountOutputType
   */

  export type ModuleSizeCountOutputType = {
    modules: number
    cabinetSizes: number
  }

  export type ModuleSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | ModuleSizeCountOutputTypeCountModulesArgs
    cabinetSizes?: boolean | ModuleSizeCountOutputTypeCountCabinetSizesArgs
  }

  // Custom InputTypes
  /**
   * ModuleSizeCountOutputType without action
   */
  export type ModuleSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSizeCountOutputType
     */
    select?: ModuleSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleSizeCountOutputType without action
   */
  export type ModuleSizeCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleModuleSizeWhereInput
  }

  /**
   * ModuleSizeCountOutputType without action
   */
  export type ModuleSizeCountOutputTypeCountCabinetSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSizeModuleSizeWhereInput
  }


  /**
   * Count Type CabinetSizeCountOutputType
   */

  export type CabinetSizeCountOutputType = {
    cabinets: number
    moduleSizes: number
  }

  export type CabinetSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | CabinetSizeCountOutputTypeCountCabinetsArgs
    moduleSizes?: boolean | CabinetSizeCountOutputTypeCountModuleSizesArgs
  }

  // Custom InputTypes
  /**
   * CabinetSizeCountOutputType without action
   */
  export type CabinetSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeCountOutputType
     */
    select?: CabinetSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CabinetSizeCountOutputType without action
   */
  export type CabinetSizeCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCabinetSizeWhereInput
  }

  /**
   * CabinetSizeCountOutputType without action
   */
  export type CabinetSizeCountOutputTypeCountModuleSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSizeModuleSizeWhereInput
  }


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    subcategories: number
    items: number
    cabinets: number
    modules: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategories?: boolean | ItemCategoryCountOutputTypeCountSubcategoriesArgs
    items?: boolean | ItemCategoryCountOutputTypeCountItemsArgs
    cabinets?: boolean | ItemCategoryCountOutputTypeCountCabinetsArgs
    modules?: boolean | ItemCategoryCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategorySubcategoryWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryRelationWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCategoryWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleCategoryWhereInput
  }


  /**
   * Count Type ItemSubcategoryCountOutputType
   */

  export type ItemSubcategoryCountOutputType = {
    categories: number
    items: number
    cabinets: number
    modules: number
  }

  export type ItemSubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ItemSubcategoryCountOutputTypeCountCategoriesArgs
    items?: boolean | ItemSubcategoryCountOutputTypeCountItemsArgs
    cabinets?: boolean | ItemSubcategoryCountOutputTypeCountCabinetsArgs
    modules?: boolean | ItemSubcategoryCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ItemSubcategoryCountOutputType without action
   */
  export type ItemSubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryCountOutputType
     */
    select?: ItemSubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemSubcategoryCountOutputType without action
   */
  export type ItemSubcategoryCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategorySubcategoryWhereInput
  }

  /**
   * ItemSubcategoryCountOutputType without action
   */
  export type ItemSubcategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSubcategoryRelationWhereInput
  }

  /**
   * ItemSubcategoryCountOutputType without action
   */
  export type ItemSubcategoryCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSubcategoryWhereInput
  }

  /**
   * ItemSubcategoryCountOutputType without action
   */
  export type ItemSubcategoryCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleSubcategoryWhereInput
  }


  /**
   * Count Type CabinetCountOutputType
   */

  export type CabinetCountOutputType = {
    categories: number
    subcategories: number
    locations: number
    placements: number
    materials: number
    sizes: number
    pitches: number
    manufacturers: number
    suppliers: number
    items: number
    prices: number
  }

  export type CabinetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | CabinetCountOutputTypeCountCategoriesArgs
    subcategories?: boolean | CabinetCountOutputTypeCountSubcategoriesArgs
    locations?: boolean | CabinetCountOutputTypeCountLocationsArgs
    placements?: boolean | CabinetCountOutputTypeCountPlacementsArgs
    materials?: boolean | CabinetCountOutputTypeCountMaterialsArgs
    sizes?: boolean | CabinetCountOutputTypeCountSizesArgs
    pitches?: boolean | CabinetCountOutputTypeCountPitchesArgs
    manufacturers?: boolean | CabinetCountOutputTypeCountManufacturersArgs
    suppliers?: boolean | CabinetCountOutputTypeCountSuppliersArgs
    items?: boolean | CabinetCountOutputTypeCountItemsArgs
    prices?: boolean | CabinetCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCountOutputType
     */
    select?: CabinetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCategoryWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSubcategoryWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetLocationWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPlacementWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetMaterialWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCabinetSizeWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountPitchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPitchWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountManufacturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetManufacturerWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSupplierWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetItemComponentWhereInput
  }

  /**
   * CabinetCountOutputType without action
   */
  export type CabinetCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPriceWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    categories: number
    subcategories: number
    locations: number
    refreshRates: number
    brightnesses: number
    sizes: number
    pitches: number
    manufacturers: number
    items: number
    options: number
    prices: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ModuleCountOutputTypeCountCategoriesArgs
    subcategories?: boolean | ModuleCountOutputTypeCountSubcategoriesArgs
    locations?: boolean | ModuleCountOutputTypeCountLocationsArgs
    refreshRates?: boolean | ModuleCountOutputTypeCountRefreshRatesArgs
    brightnesses?: boolean | ModuleCountOutputTypeCountBrightnessesArgs
    sizes?: boolean | ModuleCountOutputTypeCountSizesArgs
    pitches?: boolean | ModuleCountOutputTypeCountPitchesArgs
    manufacturers?: boolean | ModuleCountOutputTypeCountManufacturersArgs
    items?: boolean | ModuleCountOutputTypeCountItemsArgs
    options?: boolean | ModuleCountOutputTypeCountOptionsArgs
    prices?: boolean | ModuleCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleCategoryWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleSubcategoryWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleLocationWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountRefreshRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleRefreshRateWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountBrightnessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleBrightnessWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleModuleSizeWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountPitchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePitchWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountManufacturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleManufacturerWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleItemComponentWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleOptionWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePriceWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    categories: number
    subcategories: number
    prices: number
    suppliers: number
    cabinets: number
    modules: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ItemCountOutputTypeCountCategoriesArgs
    subcategories?: boolean | ItemCountOutputTypeCountSubcategoriesArgs
    prices?: boolean | ItemCountOutputTypeCountPricesArgs
    suppliers?: boolean | ItemCountOutputTypeCountSuppliersArgs
    cabinets?: boolean | ItemCountOutputTypeCountCabinetsArgs
    modules?: boolean | ItemCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryRelationWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSubcategoryRelationWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemPriceWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetItemComponentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleItemComponentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    name: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    name: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    name: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    name?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    name?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    name?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    name: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    name?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "createdAt" | "name", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
      name: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model ScreenType
   */

  export type AggregateScreenType = {
    _count: ScreenTypeCountAggregateOutputType | null
    _avg: ScreenTypeAvgAggregateOutputType | null
    _sum: ScreenTypeSumAggregateOutputType | null
    _min: ScreenTypeMinAggregateOutputType | null
    _max: ScreenTypeMaxAggregateOutputType | null
  }

  export type ScreenTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ScreenTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ScreenTypeMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScreenTypeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScreenTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScreenTypeAvgAggregateInputType = {
    id?: true
  }

  export type ScreenTypeSumAggregateInputType = {
    id?: true
  }

  export type ScreenTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScreenTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScreenTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScreenTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenType to aggregate.
     */
    where?: ScreenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypes to fetch.
     */
    orderBy?: ScreenTypeOrderByWithRelationInput | ScreenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenTypes
    **/
    _count?: true | ScreenTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScreenTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScreenTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenTypeMaxAggregateInputType
  }

  export type GetScreenTypeAggregateType<T extends ScreenTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenType[P]>
      : GetScalarType<T[P], AggregateScreenType[P]>
  }




  export type ScreenTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeWhereInput
    orderBy?: ScreenTypeOrderByWithAggregationInput | ScreenTypeOrderByWithAggregationInput[]
    by: ScreenTypeScalarFieldEnum[] | ScreenTypeScalarFieldEnum
    having?: ScreenTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenTypeCountAggregateInputType | true
    _avg?: ScreenTypeAvgAggregateInputType
    _sum?: ScreenTypeSumAggregateInputType
    _min?: ScreenTypeMinAggregateInputType
    _max?: ScreenTypeMaxAggregateInputType
  }

  export type ScreenTypeGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScreenTypeCountAggregateOutputType | null
    _avg: ScreenTypeAvgAggregateOutputType | null
    _sum: ScreenTypeSumAggregateOutputType | null
    _min: ScreenTypeMinAggregateOutputType | null
    _max: ScreenTypeMaxAggregateOutputType | null
  }

  type GetScreenTypeGroupByPayload<T extends ScreenTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenTypeGroupByOutputType[P]>
        }
      >
    >


  export type ScreenTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    options?: boolean | ScreenType$optionsArgs<ExtArgs>
    controlTypes?: boolean | ScreenType$controlTypesArgs<ExtArgs>
    sensors?: boolean | ScreenType$sensorsArgs<ExtArgs>
    _count?: boolean | ScreenTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenType"]>

  export type ScreenTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["screenType"]>

  export type ScreenTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["screenType"]>

  export type ScreenTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScreenTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["screenType"]>
  export type ScreenTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ScreenType$optionsArgs<ExtArgs>
    controlTypes?: boolean | ScreenType$controlTypesArgs<ExtArgs>
    sensors?: boolean | ScreenType$sensorsArgs<ExtArgs>
    _count?: boolean | ScreenTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScreenTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ScreenTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ScreenTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenType"
    objects: {
      options: Prisma.$ScreenTypeOptionPayload<ExtArgs>[]
      controlTypes: Prisma.$ScreenTypeControlTypePayload<ExtArgs>[]
      sensors: Prisma.$ScreenTypeSensorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["screenType"]>
    composites: {}
  }

  type ScreenTypeGetPayload<S extends boolean | null | undefined | ScreenTypeDefaultArgs> = $Result.GetResult<Prisma.$ScreenTypePayload, S>

  type ScreenTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenTypeCountAggregateInputType | true
    }

  export interface ScreenTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenType'], meta: { name: 'ScreenType' } }
    /**
     * Find zero or one ScreenType that matches the filter.
     * @param {ScreenTypeFindUniqueArgs} args - Arguments to find a ScreenType
     * @example
     * // Get one ScreenType
     * const screenType = await prisma.screenType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenTypeFindUniqueArgs>(args: SelectSubset<T, ScreenTypeFindUniqueArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenTypeFindUniqueOrThrowArgs} args - Arguments to find a ScreenType
     * @example
     * // Get one ScreenType
     * const screenType = await prisma.screenType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeFindFirstArgs} args - Arguments to find a ScreenType
     * @example
     * // Get one ScreenType
     * const screenType = await prisma.screenType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenTypeFindFirstArgs>(args?: SelectSubset<T, ScreenTypeFindFirstArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeFindFirstOrThrowArgs} args - Arguments to find a ScreenType
     * @example
     * // Get one ScreenType
     * const screenType = await prisma.screenType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenTypes
     * const screenTypes = await prisma.screenType.findMany()
     * 
     * // Get first 10 ScreenTypes
     * const screenTypes = await prisma.screenType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenTypeWithIdOnly = await prisma.screenType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenTypeFindManyArgs>(args?: SelectSubset<T, ScreenTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenType.
     * @param {ScreenTypeCreateArgs} args - Arguments to create a ScreenType.
     * @example
     * // Create one ScreenType
     * const ScreenType = await prisma.screenType.create({
     *   data: {
     *     // ... data to create a ScreenType
     *   }
     * })
     * 
     */
    create<T extends ScreenTypeCreateArgs>(args: SelectSubset<T, ScreenTypeCreateArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenTypes.
     * @param {ScreenTypeCreateManyArgs} args - Arguments to create many ScreenTypes.
     * @example
     * // Create many ScreenTypes
     * const screenType = await prisma.screenType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenTypeCreateManyArgs>(args?: SelectSubset<T, ScreenTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenTypes and returns the data saved in the database.
     * @param {ScreenTypeCreateManyAndReturnArgs} args - Arguments to create many ScreenTypes.
     * @example
     * // Create many ScreenTypes
     * const screenType = await prisma.screenType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenTypes and only return the `id`
     * const screenTypeWithIdOnly = await prisma.screenType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenType.
     * @param {ScreenTypeDeleteArgs} args - Arguments to delete one ScreenType.
     * @example
     * // Delete one ScreenType
     * const ScreenType = await prisma.screenType.delete({
     *   where: {
     *     // ... filter to delete one ScreenType
     *   }
     * })
     * 
     */
    delete<T extends ScreenTypeDeleteArgs>(args: SelectSubset<T, ScreenTypeDeleteArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenType.
     * @param {ScreenTypeUpdateArgs} args - Arguments to update one ScreenType.
     * @example
     * // Update one ScreenType
     * const screenType = await prisma.screenType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenTypeUpdateArgs>(args: SelectSubset<T, ScreenTypeUpdateArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenTypes.
     * @param {ScreenTypeDeleteManyArgs} args - Arguments to filter ScreenTypes to delete.
     * @example
     * // Delete a few ScreenTypes
     * const { count } = await prisma.screenType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenTypeDeleteManyArgs>(args?: SelectSubset<T, ScreenTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenTypes
     * const screenType = await prisma.screenType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenTypeUpdateManyArgs>(args: SelectSubset<T, ScreenTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypes and returns the data updated in the database.
     * @param {ScreenTypeUpdateManyAndReturnArgs} args - Arguments to update many ScreenTypes.
     * @example
     * // Update many ScreenTypes
     * const screenType = await prisma.screenType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenTypes and only return the `id`
     * const screenTypeWithIdOnly = await prisma.screenType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenType.
     * @param {ScreenTypeUpsertArgs} args - Arguments to update or create a ScreenType.
     * @example
     * // Update or create a ScreenType
     * const screenType = await prisma.screenType.upsert({
     *   create: {
     *     // ... data to create a ScreenType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenType we want to update
     *   }
     * })
     */
    upsert<T extends ScreenTypeUpsertArgs>(args: SelectSubset<T, ScreenTypeUpsertArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeCountArgs} args - Arguments to filter ScreenTypes to count.
     * @example
     * // Count the number of ScreenTypes
     * const count = await prisma.screenType.count({
     *   where: {
     *     // ... the filter for the ScreenTypes we want to count
     *   }
     * })
    **/
    count<T extends ScreenTypeCountArgs>(
      args?: Subset<T, ScreenTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenTypeAggregateArgs>(args: Subset<T, ScreenTypeAggregateArgs>): Prisma.PrismaPromise<GetScreenTypeAggregateType<T>>

    /**
     * Group by ScreenType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenTypeGroupByArgs['orderBy'] }
        : { orderBy?: ScreenTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenType model
   */
  readonly fields: ScreenTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    options<T extends ScreenType$optionsArgs<ExtArgs> = {}>(args?: Subset<T, ScreenType$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    controlTypes<T extends ScreenType$controlTypesArgs<ExtArgs> = {}>(args?: Subset<T, ScreenType$controlTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sensors<T extends ScreenType$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, ScreenType$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenType model
   */
  interface ScreenTypeFieldRefs {
    readonly id: FieldRef<"ScreenType", 'Int'>
    readonly code: FieldRef<"ScreenType", 'String'>
    readonly name: FieldRef<"ScreenType", 'String'>
    readonly active: FieldRef<"ScreenType", 'Boolean'>
    readonly createdAt: FieldRef<"ScreenType", 'DateTime'>
    readonly updatedAt: FieldRef<"ScreenType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScreenType findUnique
   */
  export type ScreenTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenType to fetch.
     */
    where: ScreenTypeWhereUniqueInput
  }

  /**
   * ScreenType findUniqueOrThrow
   */
  export type ScreenTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenType to fetch.
     */
    where: ScreenTypeWhereUniqueInput
  }

  /**
   * ScreenType findFirst
   */
  export type ScreenTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenType to fetch.
     */
    where?: ScreenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypes to fetch.
     */
    orderBy?: ScreenTypeOrderByWithRelationInput | ScreenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypes.
     */
    cursor?: ScreenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypes.
     */
    distinct?: ScreenTypeScalarFieldEnum | ScreenTypeScalarFieldEnum[]
  }

  /**
   * ScreenType findFirstOrThrow
   */
  export type ScreenTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenType to fetch.
     */
    where?: ScreenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypes to fetch.
     */
    orderBy?: ScreenTypeOrderByWithRelationInput | ScreenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypes.
     */
    cursor?: ScreenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypes.
     */
    distinct?: ScreenTypeScalarFieldEnum | ScreenTypeScalarFieldEnum[]
  }

  /**
   * ScreenType findMany
   */
  export type ScreenTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypes to fetch.
     */
    where?: ScreenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypes to fetch.
     */
    orderBy?: ScreenTypeOrderByWithRelationInput | ScreenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenTypes.
     */
    cursor?: ScreenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypes.
     */
    skip?: number
    distinct?: ScreenTypeScalarFieldEnum | ScreenTypeScalarFieldEnum[]
  }

  /**
   * ScreenType create
   */
  export type ScreenTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenType.
     */
    data: XOR<ScreenTypeCreateInput, ScreenTypeUncheckedCreateInput>
  }

  /**
   * ScreenType createMany
   */
  export type ScreenTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenTypes.
     */
    data: ScreenTypeCreateManyInput | ScreenTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenType createManyAndReturn
   */
  export type ScreenTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenTypes.
     */
    data: ScreenTypeCreateManyInput | ScreenTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenType update
   */
  export type ScreenTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenType.
     */
    data: XOR<ScreenTypeUpdateInput, ScreenTypeUncheckedUpdateInput>
    /**
     * Choose, which ScreenType to update.
     */
    where: ScreenTypeWhereUniqueInput
  }

  /**
   * ScreenType updateMany
   */
  export type ScreenTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenTypes.
     */
    data: XOR<ScreenTypeUpdateManyMutationInput, ScreenTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypes to update
     */
    where?: ScreenTypeWhereInput
    /**
     * Limit how many ScreenTypes to update.
     */
    limit?: number
  }

  /**
   * ScreenType updateManyAndReturn
   */
  export type ScreenTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * The data used to update ScreenTypes.
     */
    data: XOR<ScreenTypeUpdateManyMutationInput, ScreenTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypes to update
     */
    where?: ScreenTypeWhereInput
    /**
     * Limit how many ScreenTypes to update.
     */
    limit?: number
  }

  /**
   * ScreenType upsert
   */
  export type ScreenTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenType to update in case it exists.
     */
    where: ScreenTypeWhereUniqueInput
    /**
     * In case the ScreenType found by the `where` argument doesn't exist, create a new ScreenType with this data.
     */
    create: XOR<ScreenTypeCreateInput, ScreenTypeUncheckedCreateInput>
    /**
     * In case the ScreenType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenTypeUpdateInput, ScreenTypeUncheckedUpdateInput>
  }

  /**
   * ScreenType delete
   */
  export type ScreenTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
    /**
     * Filter which ScreenType to delete.
     */
    where: ScreenTypeWhereUniqueInput
  }

  /**
   * ScreenType deleteMany
   */
  export type ScreenTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypes to delete
     */
    where?: ScreenTypeWhereInput
    /**
     * Limit how many ScreenTypes to delete.
     */
    limit?: number
  }

  /**
   * ScreenType.options
   */
  export type ScreenType$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    where?: ScreenTypeOptionWhereInput
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    cursor?: ScreenTypeOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeOptionScalarFieldEnum | ScreenTypeOptionScalarFieldEnum[]
  }

  /**
   * ScreenType.controlTypes
   */
  export type ScreenType$controlTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    where?: ScreenTypeControlTypeWhereInput
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeControlTypeScalarFieldEnum | ScreenTypeControlTypeScalarFieldEnum[]
  }

  /**
   * ScreenType.sensors
   */
  export type ScreenType$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    where?: ScreenTypeSensorWhereInput
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    cursor?: ScreenTypeSensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeSensorScalarFieldEnum | ScreenTypeSensorScalarFieldEnum[]
  }

  /**
   * ScreenType without action
   */
  export type ScreenTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenType
     */
    select?: ScreenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenType
     */
    omit?: ScreenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Material$cabinetsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Material$cabinetsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      cabinets: Prisma.$CabinetMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Material$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Material$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly code: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly active: FieldRef<"Material", 'Boolean'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.cabinets
   */
  export type Material$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    where?: CabinetMaterialWhereInput
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    cursor?: CabinetMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetMaterialScalarFieldEnum | CabinetMaterialScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Location$cabinetsArgs<ExtArgs>
    modules?: boolean | Location$modulesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Location$cabinetsArgs<ExtArgs>
    modules?: boolean | Location$modulesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      cabinets: Prisma.$CabinetLocationPayload<ExtArgs>[]
      modules: Prisma.$ModuleLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Location$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Location$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Location$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Location$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly code: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly active: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.cabinets
   */
  export type Location$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    where?: CabinetLocationWhereInput
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    cursor?: CabinetLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetLocationScalarFieldEnum | CabinetLocationScalarFieldEnum[]
  }

  /**
   * Location.modules
   */
  export type Location$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    where?: ModuleLocationWhereInput
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    cursor?: ModuleLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleLocationScalarFieldEnum | ModuleLocationScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Placement
   */

  export type AggregatePlacement = {
    _count: PlacementCountAggregateOutputType | null
    _avg: PlacementAvgAggregateOutputType | null
    _sum: PlacementSumAggregateOutputType | null
    _min: PlacementMinAggregateOutputType | null
    _max: PlacementMaxAggregateOutputType | null
  }

  export type PlacementAvgAggregateOutputType = {
    id: number | null
  }

  export type PlacementSumAggregateOutputType = {
    id: number | null
  }

  export type PlacementMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlacementMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlacementCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlacementAvgAggregateInputType = {
    id?: true
  }

  export type PlacementSumAggregateInputType = {
    id?: true
  }

  export type PlacementMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlacementMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlacementCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placement to aggregate.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Placements
    **/
    _count?: true | PlacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementMaxAggregateInputType
  }

  export type GetPlacementAggregateType<T extends PlacementAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacement[P]>
      : GetScalarType<T[P], AggregatePlacement[P]>
  }




  export type PlacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementWhereInput
    orderBy?: PlacementOrderByWithAggregationInput | PlacementOrderByWithAggregationInput[]
    by: PlacementScalarFieldEnum[] | PlacementScalarFieldEnum
    having?: PlacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementCountAggregateInputType | true
    _avg?: PlacementAvgAggregateInputType
    _sum?: PlacementSumAggregateInputType
    _min?: PlacementMinAggregateInputType
    _max?: PlacementMaxAggregateInputType
  }

  export type PlacementGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlacementCountAggregateOutputType | null
    _avg: PlacementAvgAggregateOutputType | null
    _sum: PlacementSumAggregateOutputType | null
    _min: PlacementMinAggregateOutputType | null
    _max: PlacementMaxAggregateOutputType | null
  }

  type GetPlacementGroupByPayload<T extends PlacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementGroupByOutputType[P]>
        }
      >
    >


  export type PlacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Placement$cabinetsArgs<ExtArgs>
    _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placement"]>

  export type PlacementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["placement"]>

  export type PlacementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["placement"]>

  export type PlacementSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlacementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["placement"]>
  export type PlacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Placement$cabinetsArgs<ExtArgs>
    _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlacementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlacementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Placement"
    objects: {
      cabinets: Prisma.$CabinetPlacementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["placement"]>
    composites: {}
  }

  type PlacementGetPayload<S extends boolean | null | undefined | PlacementDefaultArgs> = $Result.GetResult<Prisma.$PlacementPayload, S>

  type PlacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlacementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlacementCountAggregateInputType | true
    }

  export interface PlacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Placement'], meta: { name: 'Placement' } }
    /**
     * Find zero or one Placement that matches the filter.
     * @param {PlacementFindUniqueArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlacementFindUniqueArgs>(args: SelectSubset<T, PlacementFindUniqueArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Placement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlacementFindUniqueOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlacementFindUniqueOrThrowArgs>(args: SelectSubset<T, PlacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Placement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlacementFindFirstArgs>(args?: SelectSubset<T, PlacementFindFirstArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Placement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlacementFindFirstOrThrowArgs>(args?: SelectSubset<T, PlacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Placements
     * const placements = await prisma.placement.findMany()
     * 
     * // Get first 10 Placements
     * const placements = await prisma.placement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placementWithIdOnly = await prisma.placement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlacementFindManyArgs>(args?: SelectSubset<T, PlacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Placement.
     * @param {PlacementCreateArgs} args - Arguments to create a Placement.
     * @example
     * // Create one Placement
     * const Placement = await prisma.placement.create({
     *   data: {
     *     // ... data to create a Placement
     *   }
     * })
     * 
     */
    create<T extends PlacementCreateArgs>(args: SelectSubset<T, PlacementCreateArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Placements.
     * @param {PlacementCreateManyArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlacementCreateManyArgs>(args?: SelectSubset<T, PlacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Placements and returns the data saved in the database.
     * @param {PlacementCreateManyAndReturnArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Placements and only return the `id`
     * const placementWithIdOnly = await prisma.placement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlacementCreateManyAndReturnArgs>(args?: SelectSubset<T, PlacementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Placement.
     * @param {PlacementDeleteArgs} args - Arguments to delete one Placement.
     * @example
     * // Delete one Placement
     * const Placement = await prisma.placement.delete({
     *   where: {
     *     // ... filter to delete one Placement
     *   }
     * })
     * 
     */
    delete<T extends PlacementDeleteArgs>(args: SelectSubset<T, PlacementDeleteArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Placement.
     * @param {PlacementUpdateArgs} args - Arguments to update one Placement.
     * @example
     * // Update one Placement
     * const placement = await prisma.placement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlacementUpdateArgs>(args: SelectSubset<T, PlacementUpdateArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Placements.
     * @param {PlacementDeleteManyArgs} args - Arguments to filter Placements to delete.
     * @example
     * // Delete a few Placements
     * const { count } = await prisma.placement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlacementDeleteManyArgs>(args?: SelectSubset<T, PlacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Placements
     * const placement = await prisma.placement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlacementUpdateManyArgs>(args: SelectSubset<T, PlacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Placements and returns the data updated in the database.
     * @param {PlacementUpdateManyAndReturnArgs} args - Arguments to update many Placements.
     * @example
     * // Update many Placements
     * const placement = await prisma.placement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Placements and only return the `id`
     * const placementWithIdOnly = await prisma.placement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlacementUpdateManyAndReturnArgs>(args: SelectSubset<T, PlacementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Placement.
     * @param {PlacementUpsertArgs} args - Arguments to update or create a Placement.
     * @example
     * // Update or create a Placement
     * const placement = await prisma.placement.upsert({
     *   create: {
     *     // ... data to create a Placement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Placement we want to update
     *   }
     * })
     */
    upsert<T extends PlacementUpsertArgs>(args: SelectSubset<T, PlacementUpsertArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementCountArgs} args - Arguments to filter Placements to count.
     * @example
     * // Count the number of Placements
     * const count = await prisma.placement.count({
     *   where: {
     *     // ... the filter for the Placements we want to count
     *   }
     * })
    **/
    count<T extends PlacementCountArgs>(
      args?: Subset<T, PlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementAggregateArgs>(args: Subset<T, PlacementAggregateArgs>): Prisma.PrismaPromise<GetPlacementAggregateType<T>>

    /**
     * Group by Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementGroupByArgs['orderBy'] }
        : { orderBy?: PlacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Placement model
   */
  readonly fields: PlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Placement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Placement$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Placement$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Placement model
   */
  interface PlacementFieldRefs {
    readonly id: FieldRef<"Placement", 'Int'>
    readonly code: FieldRef<"Placement", 'String'>
    readonly name: FieldRef<"Placement", 'String'>
    readonly active: FieldRef<"Placement", 'Boolean'>
    readonly createdAt: FieldRef<"Placement", 'DateTime'>
    readonly updatedAt: FieldRef<"Placement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Placement findUnique
   */
  export type PlacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement findUniqueOrThrow
   */
  export type PlacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement findFirst
   */
  export type PlacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement findFirstOrThrow
   */
  export type PlacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement findMany
   */
  export type PlacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement create
   */
  export type PlacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The data needed to create a Placement.
     */
    data: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>
  }

  /**
   * Placement createMany
   */
  export type PlacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Placement createManyAndReturn
   */
  export type PlacementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Placement update
   */
  export type PlacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The data needed to update a Placement.
     */
    data: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>
    /**
     * Choose, which Placement to update.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement updateMany
   */
  export type PlacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Placements.
     */
    data: XOR<PlacementUpdateManyMutationInput, PlacementUncheckedUpdateManyInput>
    /**
     * Filter which Placements to update
     */
    where?: PlacementWhereInput
    /**
     * Limit how many Placements to update.
     */
    limit?: number
  }

  /**
   * Placement updateManyAndReturn
   */
  export type PlacementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * The data used to update Placements.
     */
    data: XOR<PlacementUpdateManyMutationInput, PlacementUncheckedUpdateManyInput>
    /**
     * Filter which Placements to update
     */
    where?: PlacementWhereInput
    /**
     * Limit how many Placements to update.
     */
    limit?: number
  }

  /**
   * Placement upsert
   */
  export type PlacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The filter to search for the Placement to update in case it exists.
     */
    where: PlacementWhereUniqueInput
    /**
     * In case the Placement found by the `where` argument doesn't exist, create a new Placement with this data.
     */
    create: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>
    /**
     * In case the Placement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>
  }

  /**
   * Placement delete
   */
  export type PlacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter which Placement to delete.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement deleteMany
   */
  export type PlacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to delete
     */
    where?: PlacementWhereInput
    /**
     * Limit how many Placements to delete.
     */
    limit?: number
  }

  /**
   * Placement.cabinets
   */
  export type Placement$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    where?: CabinetPlacementWhereInput
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    cursor?: CabinetPlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetPlacementScalarFieldEnum | CabinetPlacementScalarFieldEnum[]
  }

  /**
   * Placement without action
   */
  export type PlacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
  }


  /**
   * Model Option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionAvgAggregateOutputType = {
    id: number | null
  }

  export type OptionSumAggregateOutputType = {
    id: number | null
  }

  export type OptionMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OptionAvgAggregateInputType = {
    id?: true
  }

  export type OptionSumAggregateInputType = {
    id?: true
  }

  export type OptionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Option to aggregate.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithAggregationInput | OptionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _avg?: OptionAvgAggregateInputType
    _sum?: OptionSumAggregateInputType
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    screenTypes?: boolean | Option$screenTypesArgs<ExtArgs>
    modules?: boolean | Option$modulesArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["option"]>

  export type OptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["option"]>

  export type OptionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["option"]>
  export type OptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | Option$screenTypesArgs<ExtArgs>
    modules?: boolean | Option$modulesArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Option"
    objects: {
      screenTypes: Prisma.$ScreenTypeOptionPayload<ExtArgs>[]
      modules: Prisma.$ModuleOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type OptionGetPayload<S extends boolean | null | undefined | OptionDefaultArgs> = $Result.GetResult<Prisma.$OptionPayload, S>

  type OptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface OptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Option'], meta: { name: 'Option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionFindUniqueArgs>(args: SelectSubset<T, OptionFindUniqueArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionFindFirstArgs>(args?: SelectSubset<T, OptionFindFirstArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionFindManyArgs>(args?: SelectSubset<T, OptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends OptionCreateArgs>(args: SelectSubset<T, OptionCreateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Options.
     * @param {OptionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionCreateManyArgs>(args?: SelectSubset<T, OptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Options and returns the data saved in the database.
     * @param {OptionCreateManyAndReturnArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends OptionDeleteArgs>(args: SelectSubset<T, OptionDeleteArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionUpdateArgs>(args: SelectSubset<T, OptionUpdateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionDeleteManyArgs>(args?: SelectSubset<T, OptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionUpdateManyArgs>(args: SelectSubset<T, OptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options and returns the data updated in the database.
     * @param {OptionUpdateManyAndReturnArgs} args - Arguments to update many Options.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptionUpdateManyAndReturnArgs>(args: SelectSubset<T, OptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends OptionUpsertArgs>(args: SelectSubset<T, OptionUpsertArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Option model
   */
  readonly fields: OptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenTypes<T extends Option$screenTypesArgs<ExtArgs> = {}>(args?: Subset<T, Option$screenTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Option$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Option$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Option model
   */
  interface OptionFieldRefs {
    readonly id: FieldRef<"Option", 'Int'>
    readonly code: FieldRef<"Option", 'String'>
    readonly name: FieldRef<"Option", 'String'>
    readonly active: FieldRef<"Option", 'Boolean'>
    readonly createdAt: FieldRef<"Option", 'DateTime'>
    readonly updatedAt: FieldRef<"Option", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Option findUnique
   */
  export type OptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findFirst
   */
  export type OptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findMany
   */
  export type OptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Options to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option create
   */
  export type OptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Option.
     */
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }

  /**
   * Option createMany
   */
  export type OptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Option createManyAndReturn
   */
  export type OptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Option update
   */
  export type OptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Option.
     */
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
  }

  /**
   * Option updateManyAndReturn
   */
  export type OptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
  }

  /**
   * Option upsert
   */
  export type OptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Option to update in case it exists.
     */
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     */
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }

  /**
   * Option delete
   */
  export type OptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter which Option to delete.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Options to delete
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to delete.
     */
    limit?: number
  }

  /**
   * Option.screenTypes
   */
  export type Option$screenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    where?: ScreenTypeOptionWhereInput
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    cursor?: ScreenTypeOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeOptionScalarFieldEnum | ScreenTypeOptionScalarFieldEnum[]
  }

  /**
   * Option.modules
   */
  export type Option$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    where?: ModuleOptionWhereInput
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    cursor?: ModuleOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleOptionScalarFieldEnum | ModuleOptionScalarFieldEnum[]
  }

  /**
   * Option without action
   */
  export type OptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
  }


  /**
   * Model Sensor
   */

  export type AggregateSensor = {
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  export type SensorAvgAggregateOutputType = {
    id: number | null
  }

  export type SensorSumAggregateOutputType = {
    id: number | null
  }

  export type SensorMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SensorMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SensorCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SensorAvgAggregateInputType = {
    id?: true
  }

  export type SensorSumAggregateInputType = {
    id?: true
  }

  export type SensorMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SensorMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SensorCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensor to aggregate.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sensors
    **/
    _count?: true | SensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorMaxAggregateInputType
  }

  export type GetSensorAggregateType<T extends SensorAggregateArgs> = {
        [P in keyof T & keyof AggregateSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensor[P]>
      : GetScalarType<T[P], AggregateSensor[P]>
  }




  export type SensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithAggregationInput | SensorOrderByWithAggregationInput[]
    by: SensorScalarFieldEnum[] | SensorScalarFieldEnum
    having?: SensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorCountAggregateInputType | true
    _avg?: SensorAvgAggregateInputType
    _sum?: SensorSumAggregateInputType
    _min?: SensorMinAggregateInputType
    _max?: SensorMaxAggregateInputType
  }

  export type SensorGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  type GetSensorGroupByPayload<T extends SensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorGroupByOutputType[P]>
            : GetScalarType<T[P], SensorGroupByOutputType[P]>
        }
      >
    >


  export type SensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    screenTypes?: boolean | Sensor$screenTypesArgs<ExtArgs>
    _count?: boolean | SensorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SensorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["sensor"]>
  export type SensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | Sensor$screenTypesArgs<ExtArgs>
    _count?: boolean | SensorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SensorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sensor"
    objects: {
      screenTypes: Prisma.$ScreenTypeSensorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sensor"]>
    composites: {}
  }

  type SensorGetPayload<S extends boolean | null | undefined | SensorDefaultArgs> = $Result.GetResult<Prisma.$SensorPayload, S>

  type SensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SensorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SensorCountAggregateInputType | true
    }

  export interface SensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sensor'], meta: { name: 'Sensor' } }
    /**
     * Find zero or one Sensor that matches the filter.
     * @param {SensorFindUniqueArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorFindUniqueArgs>(args: SelectSubset<T, SensorFindUniqueArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sensor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SensorFindUniqueOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorFindFirstArgs>(args?: SelectSubset<T, SensorFindFirstArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sensors
     * const sensors = await prisma.sensor.findMany()
     * 
     * // Get first 10 Sensors
     * const sensors = await prisma.sensor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorWithIdOnly = await prisma.sensor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SensorFindManyArgs>(args?: SelectSubset<T, SensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sensor.
     * @param {SensorCreateArgs} args - Arguments to create a Sensor.
     * @example
     * // Create one Sensor
     * const Sensor = await prisma.sensor.create({
     *   data: {
     *     // ... data to create a Sensor
     *   }
     * })
     * 
     */
    create<T extends SensorCreateArgs>(args: SelectSubset<T, SensorCreateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sensors.
     * @param {SensorCreateManyArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorCreateManyArgs>(args?: SelectSubset<T, SensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sensors and returns the data saved in the database.
     * @param {SensorCreateManyAndReturnArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sensors and only return the `id`
     * const sensorWithIdOnly = await prisma.sensor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensorCreateManyAndReturnArgs>(args?: SelectSubset<T, SensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sensor.
     * @param {SensorDeleteArgs} args - Arguments to delete one Sensor.
     * @example
     * // Delete one Sensor
     * const Sensor = await prisma.sensor.delete({
     *   where: {
     *     // ... filter to delete one Sensor
     *   }
     * })
     * 
     */
    delete<T extends SensorDeleteArgs>(args: SelectSubset<T, SensorDeleteArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sensor.
     * @param {SensorUpdateArgs} args - Arguments to update one Sensor.
     * @example
     * // Update one Sensor
     * const sensor = await prisma.sensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorUpdateArgs>(args: SelectSubset<T, SensorUpdateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sensors.
     * @param {SensorDeleteManyArgs} args - Arguments to filter Sensors to delete.
     * @example
     * // Delete a few Sensors
     * const { count } = await prisma.sensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorDeleteManyArgs>(args?: SelectSubset<T, SensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sensors
     * const sensor = await prisma.sensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorUpdateManyArgs>(args: SelectSubset<T, SensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors and returns the data updated in the database.
     * @param {SensorUpdateManyAndReturnArgs} args - Arguments to update many Sensors.
     * @example
     * // Update many Sensors
     * const sensor = await prisma.sensor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sensors and only return the `id`
     * const sensorWithIdOnly = await prisma.sensor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SensorUpdateManyAndReturnArgs>(args: SelectSubset<T, SensorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sensor.
     * @param {SensorUpsertArgs} args - Arguments to update or create a Sensor.
     * @example
     * // Update or create a Sensor
     * const sensor = await prisma.sensor.upsert({
     *   create: {
     *     // ... data to create a Sensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sensor we want to update
     *   }
     * })
     */
    upsert<T extends SensorUpsertArgs>(args: SelectSubset<T, SensorUpsertArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorCountArgs} args - Arguments to filter Sensors to count.
     * @example
     * // Count the number of Sensors
     * const count = await prisma.sensor.count({
     *   where: {
     *     // ... the filter for the Sensors we want to count
     *   }
     * })
    **/
    count<T extends SensorCountArgs>(
      args?: Subset<T, SensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorAggregateArgs>(args: Subset<T, SensorAggregateArgs>): Prisma.PrismaPromise<GetSensorAggregateType<T>>

    /**
     * Group by Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorGroupByArgs['orderBy'] }
        : { orderBy?: SensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sensor model
   */
  readonly fields: SensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenTypes<T extends Sensor$screenTypesArgs<ExtArgs> = {}>(args?: Subset<T, Sensor$screenTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sensor model
   */
  interface SensorFieldRefs {
    readonly id: FieldRef<"Sensor", 'Int'>
    readonly code: FieldRef<"Sensor", 'String'>
    readonly name: FieldRef<"Sensor", 'String'>
    readonly active: FieldRef<"Sensor", 'Boolean'>
    readonly createdAt: FieldRef<"Sensor", 'DateTime'>
    readonly updatedAt: FieldRef<"Sensor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sensor findUnique
   */
  export type SensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findUniqueOrThrow
   */
  export type SensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findFirst
   */
  export type SensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findFirstOrThrow
   */
  export type SensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findMany
   */
  export type SensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensors to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor create
   */
  export type SensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sensor.
     */
    data: XOR<SensorCreateInput, SensorUncheckedCreateInput>
  }

  /**
   * Sensor createMany
   */
  export type SensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sensor createManyAndReturn
   */
  export type SensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sensor update
   */
  export type SensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sensor.
     */
    data: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
    /**
     * Choose, which Sensor to update.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor updateMany
   */
  export type SensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sensors.
     */
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyInput>
    /**
     * Filter which Sensors to update
     */
    where?: SensorWhereInput
    /**
     * Limit how many Sensors to update.
     */
    limit?: number
  }

  /**
   * Sensor updateManyAndReturn
   */
  export type SensorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * The data used to update Sensors.
     */
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyInput>
    /**
     * Filter which Sensors to update
     */
    where?: SensorWhereInput
    /**
     * Limit how many Sensors to update.
     */
    limit?: number
  }

  /**
   * Sensor upsert
   */
  export type SensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sensor to update in case it exists.
     */
    where: SensorWhereUniqueInput
    /**
     * In case the Sensor found by the `where` argument doesn't exist, create a new Sensor with this data.
     */
    create: XOR<SensorCreateInput, SensorUncheckedCreateInput>
    /**
     * In case the Sensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
  }

  /**
   * Sensor delete
   */
  export type SensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter which Sensor to delete.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor deleteMany
   */
  export type SensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensors to delete
     */
    where?: SensorWhereInput
    /**
     * Limit how many Sensors to delete.
     */
    limit?: number
  }

  /**
   * Sensor.screenTypes
   */
  export type Sensor$screenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    where?: ScreenTypeSensorWhereInput
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    cursor?: ScreenTypeSensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeSensorScalarFieldEnum | ScreenTypeSensorScalarFieldEnum[]
  }

  /**
   * Sensor without action
   */
  export type SensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sensor
     */
    omit?: SensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
  }


  /**
   * Model ControlType
   */

  export type AggregateControlType = {
    _count: ControlTypeCountAggregateOutputType | null
    _avg: ControlTypeAvgAggregateOutputType | null
    _sum: ControlTypeSumAggregateOutputType | null
    _min: ControlTypeMinAggregateOutputType | null
    _max: ControlTypeMaxAggregateOutputType | null
  }

  export type ControlTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ControlTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ControlTypeMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlTypeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ControlTypeAvgAggregateInputType = {
    id?: true
  }

  export type ControlTypeSumAggregateInputType = {
    id?: true
  }

  export type ControlTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ControlTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlType to aggregate.
     */
    where?: ControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlTypes to fetch.
     */
    orderBy?: ControlTypeOrderByWithRelationInput | ControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ControlTypes
    **/
    _count?: true | ControlTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ControlTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ControlTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ControlTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ControlTypeMaxAggregateInputType
  }

  export type GetControlTypeAggregateType<T extends ControlTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateControlType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateControlType[P]>
      : GetScalarType<T[P], AggregateControlType[P]>
  }




  export type ControlTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlTypeWhereInput
    orderBy?: ControlTypeOrderByWithAggregationInput | ControlTypeOrderByWithAggregationInput[]
    by: ControlTypeScalarFieldEnum[] | ControlTypeScalarFieldEnum
    having?: ControlTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ControlTypeCountAggregateInputType | true
    _avg?: ControlTypeAvgAggregateInputType
    _sum?: ControlTypeSumAggregateInputType
    _min?: ControlTypeMinAggregateInputType
    _max?: ControlTypeMaxAggregateInputType
  }

  export type ControlTypeGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ControlTypeCountAggregateOutputType | null
    _avg: ControlTypeAvgAggregateOutputType | null
    _sum: ControlTypeSumAggregateOutputType | null
    _min: ControlTypeMinAggregateOutputType | null
    _max: ControlTypeMaxAggregateOutputType | null
  }

  type GetControlTypeGroupByPayload<T extends ControlTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ControlTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ControlTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ControlTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ControlTypeGroupByOutputType[P]>
        }
      >
    >


  export type ControlTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    screenTypes?: boolean | ControlType$screenTypesArgs<ExtArgs>
    _count?: boolean | ControlTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlType"]>

  export type ControlTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["controlType"]>

  export type ControlTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["controlType"]>

  export type ControlTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ControlTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["controlType"]>
  export type ControlTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenTypes?: boolean | ControlType$screenTypesArgs<ExtArgs>
    _count?: boolean | ControlTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ControlTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ControlTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ControlTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ControlType"
    objects: {
      screenTypes: Prisma.$ScreenTypeControlTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["controlType"]>
    composites: {}
  }

  type ControlTypeGetPayload<S extends boolean | null | undefined | ControlTypeDefaultArgs> = $Result.GetResult<Prisma.$ControlTypePayload, S>

  type ControlTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ControlTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ControlTypeCountAggregateInputType | true
    }

  export interface ControlTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ControlType'], meta: { name: 'ControlType' } }
    /**
     * Find zero or one ControlType that matches the filter.
     * @param {ControlTypeFindUniqueArgs} args - Arguments to find a ControlType
     * @example
     * // Get one ControlType
     * const controlType = await prisma.controlType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ControlTypeFindUniqueArgs>(args: SelectSubset<T, ControlTypeFindUniqueArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ControlType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ControlTypeFindUniqueOrThrowArgs} args - Arguments to find a ControlType
     * @example
     * // Get one ControlType
     * const controlType = await prisma.controlType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ControlTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ControlTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ControlType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeFindFirstArgs} args - Arguments to find a ControlType
     * @example
     * // Get one ControlType
     * const controlType = await prisma.controlType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ControlTypeFindFirstArgs>(args?: SelectSubset<T, ControlTypeFindFirstArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ControlType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeFindFirstOrThrowArgs} args - Arguments to find a ControlType
     * @example
     * // Get one ControlType
     * const controlType = await prisma.controlType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ControlTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ControlTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ControlTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ControlTypes
     * const controlTypes = await prisma.controlType.findMany()
     * 
     * // Get first 10 ControlTypes
     * const controlTypes = await prisma.controlType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const controlTypeWithIdOnly = await prisma.controlType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ControlTypeFindManyArgs>(args?: SelectSubset<T, ControlTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ControlType.
     * @param {ControlTypeCreateArgs} args - Arguments to create a ControlType.
     * @example
     * // Create one ControlType
     * const ControlType = await prisma.controlType.create({
     *   data: {
     *     // ... data to create a ControlType
     *   }
     * })
     * 
     */
    create<T extends ControlTypeCreateArgs>(args: SelectSubset<T, ControlTypeCreateArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ControlTypes.
     * @param {ControlTypeCreateManyArgs} args - Arguments to create many ControlTypes.
     * @example
     * // Create many ControlTypes
     * const controlType = await prisma.controlType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ControlTypeCreateManyArgs>(args?: SelectSubset<T, ControlTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ControlTypes and returns the data saved in the database.
     * @param {ControlTypeCreateManyAndReturnArgs} args - Arguments to create many ControlTypes.
     * @example
     * // Create many ControlTypes
     * const controlType = await prisma.controlType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ControlTypes and only return the `id`
     * const controlTypeWithIdOnly = await prisma.controlType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ControlTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ControlTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ControlType.
     * @param {ControlTypeDeleteArgs} args - Arguments to delete one ControlType.
     * @example
     * // Delete one ControlType
     * const ControlType = await prisma.controlType.delete({
     *   where: {
     *     // ... filter to delete one ControlType
     *   }
     * })
     * 
     */
    delete<T extends ControlTypeDeleteArgs>(args: SelectSubset<T, ControlTypeDeleteArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ControlType.
     * @param {ControlTypeUpdateArgs} args - Arguments to update one ControlType.
     * @example
     * // Update one ControlType
     * const controlType = await prisma.controlType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ControlTypeUpdateArgs>(args: SelectSubset<T, ControlTypeUpdateArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ControlTypes.
     * @param {ControlTypeDeleteManyArgs} args - Arguments to filter ControlTypes to delete.
     * @example
     * // Delete a few ControlTypes
     * const { count } = await prisma.controlType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ControlTypeDeleteManyArgs>(args?: SelectSubset<T, ControlTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ControlTypes
     * const controlType = await prisma.controlType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ControlTypeUpdateManyArgs>(args: SelectSubset<T, ControlTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlTypes and returns the data updated in the database.
     * @param {ControlTypeUpdateManyAndReturnArgs} args - Arguments to update many ControlTypes.
     * @example
     * // Update many ControlTypes
     * const controlType = await prisma.controlType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ControlTypes and only return the `id`
     * const controlTypeWithIdOnly = await prisma.controlType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ControlTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ControlTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ControlType.
     * @param {ControlTypeUpsertArgs} args - Arguments to update or create a ControlType.
     * @example
     * // Update or create a ControlType
     * const controlType = await prisma.controlType.upsert({
     *   create: {
     *     // ... data to create a ControlType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ControlType we want to update
     *   }
     * })
     */
    upsert<T extends ControlTypeUpsertArgs>(args: SelectSubset<T, ControlTypeUpsertArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ControlTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeCountArgs} args - Arguments to filter ControlTypes to count.
     * @example
     * // Count the number of ControlTypes
     * const count = await prisma.controlType.count({
     *   where: {
     *     // ... the filter for the ControlTypes we want to count
     *   }
     * })
    **/
    count<T extends ControlTypeCountArgs>(
      args?: Subset<T, ControlTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ControlTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ControlType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ControlTypeAggregateArgs>(args: Subset<T, ControlTypeAggregateArgs>): Prisma.PrismaPromise<GetControlTypeAggregateType<T>>

    /**
     * Group by ControlType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ControlTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ControlTypeGroupByArgs['orderBy'] }
        : { orderBy?: ControlTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ControlTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetControlTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ControlType model
   */
  readonly fields: ControlTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ControlType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ControlTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenTypes<T extends ControlType$screenTypesArgs<ExtArgs> = {}>(args?: Subset<T, ControlType$screenTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ControlType model
   */
  interface ControlTypeFieldRefs {
    readonly id: FieldRef<"ControlType", 'Int'>
    readonly code: FieldRef<"ControlType", 'String'>
    readonly name: FieldRef<"ControlType", 'String'>
    readonly active: FieldRef<"ControlType", 'Boolean'>
    readonly createdAt: FieldRef<"ControlType", 'DateTime'>
    readonly updatedAt: FieldRef<"ControlType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ControlType findUnique
   */
  export type ControlTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ControlType to fetch.
     */
    where: ControlTypeWhereUniqueInput
  }

  /**
   * ControlType findUniqueOrThrow
   */
  export type ControlTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ControlType to fetch.
     */
    where: ControlTypeWhereUniqueInput
  }

  /**
   * ControlType findFirst
   */
  export type ControlTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ControlType to fetch.
     */
    where?: ControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlTypes to fetch.
     */
    orderBy?: ControlTypeOrderByWithRelationInput | ControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlTypes.
     */
    cursor?: ControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlTypes.
     */
    distinct?: ControlTypeScalarFieldEnum | ControlTypeScalarFieldEnum[]
  }

  /**
   * ControlType findFirstOrThrow
   */
  export type ControlTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ControlType to fetch.
     */
    where?: ControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlTypes to fetch.
     */
    orderBy?: ControlTypeOrderByWithRelationInput | ControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlTypes.
     */
    cursor?: ControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlTypes.
     */
    distinct?: ControlTypeScalarFieldEnum | ControlTypeScalarFieldEnum[]
  }

  /**
   * ControlType findMany
   */
  export type ControlTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ControlTypes to fetch.
     */
    where?: ControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlTypes to fetch.
     */
    orderBy?: ControlTypeOrderByWithRelationInput | ControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ControlTypes.
     */
    cursor?: ControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlTypes.
     */
    skip?: number
    distinct?: ControlTypeScalarFieldEnum | ControlTypeScalarFieldEnum[]
  }

  /**
   * ControlType create
   */
  export type ControlTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ControlType.
     */
    data: XOR<ControlTypeCreateInput, ControlTypeUncheckedCreateInput>
  }

  /**
   * ControlType createMany
   */
  export type ControlTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ControlTypes.
     */
    data: ControlTypeCreateManyInput | ControlTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ControlType createManyAndReturn
   */
  export type ControlTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ControlTypes.
     */
    data: ControlTypeCreateManyInput | ControlTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ControlType update
   */
  export type ControlTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ControlType.
     */
    data: XOR<ControlTypeUpdateInput, ControlTypeUncheckedUpdateInput>
    /**
     * Choose, which ControlType to update.
     */
    where: ControlTypeWhereUniqueInput
  }

  /**
   * ControlType updateMany
   */
  export type ControlTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ControlTypes.
     */
    data: XOR<ControlTypeUpdateManyMutationInput, ControlTypeUncheckedUpdateManyInput>
    /**
     * Filter which ControlTypes to update
     */
    where?: ControlTypeWhereInput
    /**
     * Limit how many ControlTypes to update.
     */
    limit?: number
  }

  /**
   * ControlType updateManyAndReturn
   */
  export type ControlTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * The data used to update ControlTypes.
     */
    data: XOR<ControlTypeUpdateManyMutationInput, ControlTypeUncheckedUpdateManyInput>
    /**
     * Filter which ControlTypes to update
     */
    where?: ControlTypeWhereInput
    /**
     * Limit how many ControlTypes to update.
     */
    limit?: number
  }

  /**
   * ControlType upsert
   */
  export type ControlTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ControlType to update in case it exists.
     */
    where: ControlTypeWhereUniqueInput
    /**
     * In case the ControlType found by the `where` argument doesn't exist, create a new ControlType with this data.
     */
    create: XOR<ControlTypeCreateInput, ControlTypeUncheckedCreateInput>
    /**
     * In case the ControlType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ControlTypeUpdateInput, ControlTypeUncheckedUpdateInput>
  }

  /**
   * ControlType delete
   */
  export type ControlTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
    /**
     * Filter which ControlType to delete.
     */
    where: ControlTypeWhereUniqueInput
  }

  /**
   * ControlType deleteMany
   */
  export type ControlTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlTypes to delete
     */
    where?: ControlTypeWhereInput
    /**
     * Limit how many ControlTypes to delete.
     */
    limit?: number
  }

  /**
   * ControlType.screenTypes
   */
  export type ControlType$screenTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    where?: ScreenTypeControlTypeWhereInput
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenTypeControlTypeScalarFieldEnum | ScreenTypeControlTypeScalarFieldEnum[]
  }

  /**
   * ControlType without action
   */
  export type ControlTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlType
     */
    select?: ControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlType
     */
    omit?: ControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlTypeInclude<ExtArgs> | null
  }


  /**
   * Model Pitch
   */

  export type AggregatePitch = {
    _count: PitchCountAggregateOutputType | null
    _avg: PitchAvgAggregateOutputType | null
    _sum: PitchSumAggregateOutputType | null
    _min: PitchMinAggregateOutputType | null
    _max: PitchMaxAggregateOutputType | null
  }

  export type PitchAvgAggregateOutputType = {
    id: number | null
    pitchValue: Decimal | null
  }

  export type PitchSumAggregateOutputType = {
    id: number | null
    pitchValue: Decimal | null
  }

  export type PitchMinAggregateOutputType = {
    id: number | null
    code: string | null
    pitchValue: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PitchMaxAggregateOutputType = {
    id: number | null
    code: string | null
    pitchValue: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PitchCountAggregateOutputType = {
    id: number
    code: number
    pitchValue: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PitchAvgAggregateInputType = {
    id?: true
    pitchValue?: true
  }

  export type PitchSumAggregateInputType = {
    id?: true
    pitchValue?: true
  }

  export type PitchMinAggregateInputType = {
    id?: true
    code?: true
    pitchValue?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PitchMaxAggregateInputType = {
    id?: true
    code?: true
    pitchValue?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PitchCountAggregateInputType = {
    id?: true
    code?: true
    pitchValue?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PitchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pitch to aggregate.
     */
    where?: PitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pitches to fetch.
     */
    orderBy?: PitchOrderByWithRelationInput | PitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pitches
    **/
    _count?: true | PitchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PitchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PitchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PitchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PitchMaxAggregateInputType
  }

  export type GetPitchAggregateType<T extends PitchAggregateArgs> = {
        [P in keyof T & keyof AggregatePitch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePitch[P]>
      : GetScalarType<T[P], AggregatePitch[P]>
  }




  export type PitchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PitchWhereInput
    orderBy?: PitchOrderByWithAggregationInput | PitchOrderByWithAggregationInput[]
    by: PitchScalarFieldEnum[] | PitchScalarFieldEnum
    having?: PitchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PitchCountAggregateInputType | true
    _avg?: PitchAvgAggregateInputType
    _sum?: PitchSumAggregateInputType
    _min?: PitchMinAggregateInputType
    _max?: PitchMaxAggregateInputType
  }

  export type PitchGroupByOutputType = {
    id: number
    code: string
    pitchValue: Decimal
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PitchCountAggregateOutputType | null
    _avg: PitchAvgAggregateOutputType | null
    _sum: PitchSumAggregateOutputType | null
    _min: PitchMinAggregateOutputType | null
    _max: PitchMaxAggregateOutputType | null
  }

  type GetPitchGroupByPayload<T extends PitchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PitchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PitchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PitchGroupByOutputType[P]>
            : GetScalarType<T[P], PitchGroupByOutputType[P]>
        }
      >
    >


  export type PitchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    pitchValue?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Pitch$cabinetsArgs<ExtArgs>
    modules?: boolean | Pitch$modulesArgs<ExtArgs>
    _count?: boolean | PitchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pitch"]>

  export type PitchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    pitchValue?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pitch"]>

  export type PitchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    pitchValue?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pitch"]>

  export type PitchSelectScalar = {
    id?: boolean
    code?: boolean
    pitchValue?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PitchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "pitchValue" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["pitch"]>
  export type PitchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Pitch$cabinetsArgs<ExtArgs>
    modules?: boolean | Pitch$modulesArgs<ExtArgs>
    _count?: boolean | PitchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PitchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PitchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PitchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pitch"
    objects: {
      cabinets: Prisma.$CabinetPitchPayload<ExtArgs>[]
      modules: Prisma.$ModulePitchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      pitchValue: Prisma.Decimal
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pitch"]>
    composites: {}
  }

  type PitchGetPayload<S extends boolean | null | undefined | PitchDefaultArgs> = $Result.GetResult<Prisma.$PitchPayload, S>

  type PitchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PitchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PitchCountAggregateInputType | true
    }

  export interface PitchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pitch'], meta: { name: 'Pitch' } }
    /**
     * Find zero or one Pitch that matches the filter.
     * @param {PitchFindUniqueArgs} args - Arguments to find a Pitch
     * @example
     * // Get one Pitch
     * const pitch = await prisma.pitch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PitchFindUniqueArgs>(args: SelectSubset<T, PitchFindUniqueArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pitch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PitchFindUniqueOrThrowArgs} args - Arguments to find a Pitch
     * @example
     * // Get one Pitch
     * const pitch = await prisma.pitch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PitchFindUniqueOrThrowArgs>(args: SelectSubset<T, PitchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pitch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchFindFirstArgs} args - Arguments to find a Pitch
     * @example
     * // Get one Pitch
     * const pitch = await prisma.pitch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PitchFindFirstArgs>(args?: SelectSubset<T, PitchFindFirstArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pitch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchFindFirstOrThrowArgs} args - Arguments to find a Pitch
     * @example
     * // Get one Pitch
     * const pitch = await prisma.pitch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PitchFindFirstOrThrowArgs>(args?: SelectSubset<T, PitchFindFirstOrThrowArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pitches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pitches
     * const pitches = await prisma.pitch.findMany()
     * 
     * // Get first 10 Pitches
     * const pitches = await prisma.pitch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pitchWithIdOnly = await prisma.pitch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PitchFindManyArgs>(args?: SelectSubset<T, PitchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pitch.
     * @param {PitchCreateArgs} args - Arguments to create a Pitch.
     * @example
     * // Create one Pitch
     * const Pitch = await prisma.pitch.create({
     *   data: {
     *     // ... data to create a Pitch
     *   }
     * })
     * 
     */
    create<T extends PitchCreateArgs>(args: SelectSubset<T, PitchCreateArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pitches.
     * @param {PitchCreateManyArgs} args - Arguments to create many Pitches.
     * @example
     * // Create many Pitches
     * const pitch = await prisma.pitch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PitchCreateManyArgs>(args?: SelectSubset<T, PitchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pitches and returns the data saved in the database.
     * @param {PitchCreateManyAndReturnArgs} args - Arguments to create many Pitches.
     * @example
     * // Create many Pitches
     * const pitch = await prisma.pitch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pitches and only return the `id`
     * const pitchWithIdOnly = await prisma.pitch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PitchCreateManyAndReturnArgs>(args?: SelectSubset<T, PitchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pitch.
     * @param {PitchDeleteArgs} args - Arguments to delete one Pitch.
     * @example
     * // Delete one Pitch
     * const Pitch = await prisma.pitch.delete({
     *   where: {
     *     // ... filter to delete one Pitch
     *   }
     * })
     * 
     */
    delete<T extends PitchDeleteArgs>(args: SelectSubset<T, PitchDeleteArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pitch.
     * @param {PitchUpdateArgs} args - Arguments to update one Pitch.
     * @example
     * // Update one Pitch
     * const pitch = await prisma.pitch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PitchUpdateArgs>(args: SelectSubset<T, PitchUpdateArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pitches.
     * @param {PitchDeleteManyArgs} args - Arguments to filter Pitches to delete.
     * @example
     * // Delete a few Pitches
     * const { count } = await prisma.pitch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PitchDeleteManyArgs>(args?: SelectSubset<T, PitchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pitches
     * const pitch = await prisma.pitch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PitchUpdateManyArgs>(args: SelectSubset<T, PitchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pitches and returns the data updated in the database.
     * @param {PitchUpdateManyAndReturnArgs} args - Arguments to update many Pitches.
     * @example
     * // Update many Pitches
     * const pitch = await prisma.pitch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pitches and only return the `id`
     * const pitchWithIdOnly = await prisma.pitch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PitchUpdateManyAndReturnArgs>(args: SelectSubset<T, PitchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pitch.
     * @param {PitchUpsertArgs} args - Arguments to update or create a Pitch.
     * @example
     * // Update or create a Pitch
     * const pitch = await prisma.pitch.upsert({
     *   create: {
     *     // ... data to create a Pitch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pitch we want to update
     *   }
     * })
     */
    upsert<T extends PitchUpsertArgs>(args: SelectSubset<T, PitchUpsertArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchCountArgs} args - Arguments to filter Pitches to count.
     * @example
     * // Count the number of Pitches
     * const count = await prisma.pitch.count({
     *   where: {
     *     // ... the filter for the Pitches we want to count
     *   }
     * })
    **/
    count<T extends PitchCountArgs>(
      args?: Subset<T, PitchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PitchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PitchAggregateArgs>(args: Subset<T, PitchAggregateArgs>): Prisma.PrismaPromise<GetPitchAggregateType<T>>

    /**
     * Group by Pitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PitchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PitchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PitchGroupByArgs['orderBy'] }
        : { orderBy?: PitchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PitchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPitchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pitch model
   */
  readonly fields: PitchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pitch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PitchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Pitch$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Pitch$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Pitch$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Pitch$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pitch model
   */
  interface PitchFieldRefs {
    readonly id: FieldRef<"Pitch", 'Int'>
    readonly code: FieldRef<"Pitch", 'String'>
    readonly pitchValue: FieldRef<"Pitch", 'Decimal'>
    readonly active: FieldRef<"Pitch", 'Boolean'>
    readonly createdAt: FieldRef<"Pitch", 'DateTime'>
    readonly updatedAt: FieldRef<"Pitch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pitch findUnique
   */
  export type PitchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter, which Pitch to fetch.
     */
    where: PitchWhereUniqueInput
  }

  /**
   * Pitch findUniqueOrThrow
   */
  export type PitchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter, which Pitch to fetch.
     */
    where: PitchWhereUniqueInput
  }

  /**
   * Pitch findFirst
   */
  export type PitchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter, which Pitch to fetch.
     */
    where?: PitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pitches to fetch.
     */
    orderBy?: PitchOrderByWithRelationInput | PitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pitches.
     */
    cursor?: PitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pitches.
     */
    distinct?: PitchScalarFieldEnum | PitchScalarFieldEnum[]
  }

  /**
   * Pitch findFirstOrThrow
   */
  export type PitchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter, which Pitch to fetch.
     */
    where?: PitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pitches to fetch.
     */
    orderBy?: PitchOrderByWithRelationInput | PitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pitches.
     */
    cursor?: PitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pitches.
     */
    distinct?: PitchScalarFieldEnum | PitchScalarFieldEnum[]
  }

  /**
   * Pitch findMany
   */
  export type PitchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter, which Pitches to fetch.
     */
    where?: PitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pitches to fetch.
     */
    orderBy?: PitchOrderByWithRelationInput | PitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pitches.
     */
    cursor?: PitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pitches.
     */
    skip?: number
    distinct?: PitchScalarFieldEnum | PitchScalarFieldEnum[]
  }

  /**
   * Pitch create
   */
  export type PitchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * The data needed to create a Pitch.
     */
    data: XOR<PitchCreateInput, PitchUncheckedCreateInput>
  }

  /**
   * Pitch createMany
   */
  export type PitchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pitches.
     */
    data: PitchCreateManyInput | PitchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pitch createManyAndReturn
   */
  export type PitchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * The data used to create many Pitches.
     */
    data: PitchCreateManyInput | PitchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pitch update
   */
  export type PitchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * The data needed to update a Pitch.
     */
    data: XOR<PitchUpdateInput, PitchUncheckedUpdateInput>
    /**
     * Choose, which Pitch to update.
     */
    where: PitchWhereUniqueInput
  }

  /**
   * Pitch updateMany
   */
  export type PitchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pitches.
     */
    data: XOR<PitchUpdateManyMutationInput, PitchUncheckedUpdateManyInput>
    /**
     * Filter which Pitches to update
     */
    where?: PitchWhereInput
    /**
     * Limit how many Pitches to update.
     */
    limit?: number
  }

  /**
   * Pitch updateManyAndReturn
   */
  export type PitchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * The data used to update Pitches.
     */
    data: XOR<PitchUpdateManyMutationInput, PitchUncheckedUpdateManyInput>
    /**
     * Filter which Pitches to update
     */
    where?: PitchWhereInput
    /**
     * Limit how many Pitches to update.
     */
    limit?: number
  }

  /**
   * Pitch upsert
   */
  export type PitchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * The filter to search for the Pitch to update in case it exists.
     */
    where: PitchWhereUniqueInput
    /**
     * In case the Pitch found by the `where` argument doesn't exist, create a new Pitch with this data.
     */
    create: XOR<PitchCreateInput, PitchUncheckedCreateInput>
    /**
     * In case the Pitch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PitchUpdateInput, PitchUncheckedUpdateInput>
  }

  /**
   * Pitch delete
   */
  export type PitchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
    /**
     * Filter which Pitch to delete.
     */
    where: PitchWhereUniqueInput
  }

  /**
   * Pitch deleteMany
   */
  export type PitchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pitches to delete
     */
    where?: PitchWhereInput
    /**
     * Limit how many Pitches to delete.
     */
    limit?: number
  }

  /**
   * Pitch.cabinets
   */
  export type Pitch$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    where?: CabinetPitchWhereInput
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    cursor?: CabinetPitchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetPitchScalarFieldEnum | CabinetPitchScalarFieldEnum[]
  }

  /**
   * Pitch.modules
   */
  export type Pitch$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    where?: ModulePitchWhereInput
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    cursor?: ModulePitchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePitchScalarFieldEnum | ModulePitchScalarFieldEnum[]
  }

  /**
   * Pitch without action
   */
  export type PitchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pitch
     */
    select?: PitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pitch
     */
    omit?: PitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PitchInclude<ExtArgs> | null
  }


  /**
   * Model RefreshRate
   */

  export type AggregateRefreshRate = {
    _count: RefreshRateCountAggregateOutputType | null
    _avg: RefreshRateAvgAggregateOutputType | null
    _sum: RefreshRateSumAggregateOutputType | null
    _min: RefreshRateMinAggregateOutputType | null
    _max: RefreshRateMaxAggregateOutputType | null
  }

  export type RefreshRateAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type RefreshRateSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type RefreshRateMinAggregateOutputType = {
    id: number | null
    code: string | null
    value: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshRateMaxAggregateOutputType = {
    id: number | null
    code: string | null
    value: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshRateCountAggregateOutputType = {
    id: number
    code: number
    value: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshRateAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type RefreshRateSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type RefreshRateMinAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshRateMaxAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshRateCountAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshRate to aggregate.
     */
    where?: RefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshRates to fetch.
     */
    orderBy?: RefreshRateOrderByWithRelationInput | RefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshRates
    **/
    _count?: true | RefreshRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshRateMaxAggregateInputType
  }

  export type GetRefreshRateAggregateType<T extends RefreshRateAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshRate[P]>
      : GetScalarType<T[P], AggregateRefreshRate[P]>
  }




  export type RefreshRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshRateWhereInput
    orderBy?: RefreshRateOrderByWithAggregationInput | RefreshRateOrderByWithAggregationInput[]
    by: RefreshRateScalarFieldEnum[] | RefreshRateScalarFieldEnum
    having?: RefreshRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshRateCountAggregateInputType | true
    _avg?: RefreshRateAvgAggregateInputType
    _sum?: RefreshRateSumAggregateInputType
    _min?: RefreshRateMinAggregateInputType
    _max?: RefreshRateMaxAggregateInputType
  }

  export type RefreshRateGroupByOutputType = {
    id: number
    code: string
    value: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: RefreshRateCountAggregateOutputType | null
    _avg: RefreshRateAvgAggregateOutputType | null
    _sum: RefreshRateSumAggregateOutputType | null
    _min: RefreshRateMinAggregateOutputType | null
    _max: RefreshRateMaxAggregateOutputType | null
  }

  type GetRefreshRateGroupByPayload<T extends RefreshRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshRateGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshRateGroupByOutputType[P]>
        }
      >
    >


  export type RefreshRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | RefreshRate$modulesArgs<ExtArgs>
    _count?: boolean | RefreshRateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshRate"]>

  export type RefreshRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["refreshRate"]>

  export type RefreshRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["refreshRate"]>

  export type RefreshRateSelectScalar = {
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "value" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshRate"]>
  export type RefreshRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | RefreshRate$modulesArgs<ExtArgs>
    _count?: boolean | RefreshRateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RefreshRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RefreshRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RefreshRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshRate"
    objects: {
      modules: Prisma.$ModuleRefreshRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      value: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshRate"]>
    composites: {}
  }

  type RefreshRateGetPayload<S extends boolean | null | undefined | RefreshRateDefaultArgs> = $Result.GetResult<Prisma.$RefreshRatePayload, S>

  type RefreshRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshRateCountAggregateInputType | true
    }

  export interface RefreshRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshRate'], meta: { name: 'RefreshRate' } }
    /**
     * Find zero or one RefreshRate that matches the filter.
     * @param {RefreshRateFindUniqueArgs} args - Arguments to find a RefreshRate
     * @example
     * // Get one RefreshRate
     * const refreshRate = await prisma.refreshRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshRateFindUniqueArgs>(args: SelectSubset<T, RefreshRateFindUniqueArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshRateFindUniqueOrThrowArgs} args - Arguments to find a RefreshRate
     * @example
     * // Get one RefreshRate
     * const refreshRate = await prisma.refreshRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshRateFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateFindFirstArgs} args - Arguments to find a RefreshRate
     * @example
     * // Get one RefreshRate
     * const refreshRate = await prisma.refreshRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshRateFindFirstArgs>(args?: SelectSubset<T, RefreshRateFindFirstArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateFindFirstOrThrowArgs} args - Arguments to find a RefreshRate
     * @example
     * // Get one RefreshRate
     * const refreshRate = await prisma.refreshRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshRateFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshRates
     * const refreshRates = await prisma.refreshRate.findMany()
     * 
     * // Get first 10 RefreshRates
     * const refreshRates = await prisma.refreshRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshRateWithIdOnly = await prisma.refreshRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshRateFindManyArgs>(args?: SelectSubset<T, RefreshRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshRate.
     * @param {RefreshRateCreateArgs} args - Arguments to create a RefreshRate.
     * @example
     * // Create one RefreshRate
     * const RefreshRate = await prisma.refreshRate.create({
     *   data: {
     *     // ... data to create a RefreshRate
     *   }
     * })
     * 
     */
    create<T extends RefreshRateCreateArgs>(args: SelectSubset<T, RefreshRateCreateArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshRates.
     * @param {RefreshRateCreateManyArgs} args - Arguments to create many RefreshRates.
     * @example
     * // Create many RefreshRates
     * const refreshRate = await prisma.refreshRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshRateCreateManyArgs>(args?: SelectSubset<T, RefreshRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshRates and returns the data saved in the database.
     * @param {RefreshRateCreateManyAndReturnArgs} args - Arguments to create many RefreshRates.
     * @example
     * // Create many RefreshRates
     * const refreshRate = await prisma.refreshRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshRates and only return the `id`
     * const refreshRateWithIdOnly = await prisma.refreshRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshRateCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshRate.
     * @param {RefreshRateDeleteArgs} args - Arguments to delete one RefreshRate.
     * @example
     * // Delete one RefreshRate
     * const RefreshRate = await prisma.refreshRate.delete({
     *   where: {
     *     // ... filter to delete one RefreshRate
     *   }
     * })
     * 
     */
    delete<T extends RefreshRateDeleteArgs>(args: SelectSubset<T, RefreshRateDeleteArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshRate.
     * @param {RefreshRateUpdateArgs} args - Arguments to update one RefreshRate.
     * @example
     * // Update one RefreshRate
     * const refreshRate = await prisma.refreshRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshRateUpdateArgs>(args: SelectSubset<T, RefreshRateUpdateArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshRates.
     * @param {RefreshRateDeleteManyArgs} args - Arguments to filter RefreshRates to delete.
     * @example
     * // Delete a few RefreshRates
     * const { count } = await prisma.refreshRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshRateDeleteManyArgs>(args?: SelectSubset<T, RefreshRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshRates
     * const refreshRate = await prisma.refreshRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshRateUpdateManyArgs>(args: SelectSubset<T, RefreshRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshRates and returns the data updated in the database.
     * @param {RefreshRateUpdateManyAndReturnArgs} args - Arguments to update many RefreshRates.
     * @example
     * // Update many RefreshRates
     * const refreshRate = await prisma.refreshRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshRates and only return the `id`
     * const refreshRateWithIdOnly = await prisma.refreshRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshRateUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshRate.
     * @param {RefreshRateUpsertArgs} args - Arguments to update or create a RefreshRate.
     * @example
     * // Update or create a RefreshRate
     * const refreshRate = await prisma.refreshRate.upsert({
     *   create: {
     *     // ... data to create a RefreshRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshRate we want to update
     *   }
     * })
     */
    upsert<T extends RefreshRateUpsertArgs>(args: SelectSubset<T, RefreshRateUpsertArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateCountArgs} args - Arguments to filter RefreshRates to count.
     * @example
     * // Count the number of RefreshRates
     * const count = await prisma.refreshRate.count({
     *   where: {
     *     // ... the filter for the RefreshRates we want to count
     *   }
     * })
    **/
    count<T extends RefreshRateCountArgs>(
      args?: Subset<T, RefreshRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshRateAggregateArgs>(args: Subset<T, RefreshRateAggregateArgs>): Prisma.PrismaPromise<GetRefreshRateAggregateType<T>>

    /**
     * Group by RefreshRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshRateGroupByArgs['orderBy'] }
        : { orderBy?: RefreshRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshRate model
   */
  readonly fields: RefreshRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends RefreshRate$modulesArgs<ExtArgs> = {}>(args?: Subset<T, RefreshRate$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshRate model
   */
  interface RefreshRateFieldRefs {
    readonly id: FieldRef<"RefreshRate", 'Int'>
    readonly code: FieldRef<"RefreshRate", 'String'>
    readonly value: FieldRef<"RefreshRate", 'Int'>
    readonly active: FieldRef<"RefreshRate", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshRate", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshRate findUnique
   */
  export type RefreshRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which RefreshRate to fetch.
     */
    where: RefreshRateWhereUniqueInput
  }

  /**
   * RefreshRate findUniqueOrThrow
   */
  export type RefreshRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which RefreshRate to fetch.
     */
    where: RefreshRateWhereUniqueInput
  }

  /**
   * RefreshRate findFirst
   */
  export type RefreshRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which RefreshRate to fetch.
     */
    where?: RefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshRates to fetch.
     */
    orderBy?: RefreshRateOrderByWithRelationInput | RefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshRates.
     */
    cursor?: RefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshRates.
     */
    distinct?: RefreshRateScalarFieldEnum | RefreshRateScalarFieldEnum[]
  }

  /**
   * RefreshRate findFirstOrThrow
   */
  export type RefreshRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which RefreshRate to fetch.
     */
    where?: RefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshRates to fetch.
     */
    orderBy?: RefreshRateOrderByWithRelationInput | RefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshRates.
     */
    cursor?: RefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshRates.
     */
    distinct?: RefreshRateScalarFieldEnum | RefreshRateScalarFieldEnum[]
  }

  /**
   * RefreshRate findMany
   */
  export type RefreshRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which RefreshRates to fetch.
     */
    where?: RefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshRates to fetch.
     */
    orderBy?: RefreshRateOrderByWithRelationInput | RefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshRates.
     */
    cursor?: RefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshRates.
     */
    skip?: number
    distinct?: RefreshRateScalarFieldEnum | RefreshRateScalarFieldEnum[]
  }

  /**
   * RefreshRate create
   */
  export type RefreshRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshRate.
     */
    data: XOR<RefreshRateCreateInput, RefreshRateUncheckedCreateInput>
  }

  /**
   * RefreshRate createMany
   */
  export type RefreshRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshRates.
     */
    data: RefreshRateCreateManyInput | RefreshRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshRate createManyAndReturn
   */
  export type RefreshRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshRates.
     */
    data: RefreshRateCreateManyInput | RefreshRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshRate update
   */
  export type RefreshRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshRate.
     */
    data: XOR<RefreshRateUpdateInput, RefreshRateUncheckedUpdateInput>
    /**
     * Choose, which RefreshRate to update.
     */
    where: RefreshRateWhereUniqueInput
  }

  /**
   * RefreshRate updateMany
   */
  export type RefreshRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshRates.
     */
    data: XOR<RefreshRateUpdateManyMutationInput, RefreshRateUncheckedUpdateManyInput>
    /**
     * Filter which RefreshRates to update
     */
    where?: RefreshRateWhereInput
    /**
     * Limit how many RefreshRates to update.
     */
    limit?: number
  }

  /**
   * RefreshRate updateManyAndReturn
   */
  export type RefreshRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * The data used to update RefreshRates.
     */
    data: XOR<RefreshRateUpdateManyMutationInput, RefreshRateUncheckedUpdateManyInput>
    /**
     * Filter which RefreshRates to update
     */
    where?: RefreshRateWhereInput
    /**
     * Limit how many RefreshRates to update.
     */
    limit?: number
  }

  /**
   * RefreshRate upsert
   */
  export type RefreshRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshRate to update in case it exists.
     */
    where: RefreshRateWhereUniqueInput
    /**
     * In case the RefreshRate found by the `where` argument doesn't exist, create a new RefreshRate with this data.
     */
    create: XOR<RefreshRateCreateInput, RefreshRateUncheckedCreateInput>
    /**
     * In case the RefreshRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshRateUpdateInput, RefreshRateUncheckedUpdateInput>
  }

  /**
   * RefreshRate delete
   */
  export type RefreshRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
    /**
     * Filter which RefreshRate to delete.
     */
    where: RefreshRateWhereUniqueInput
  }

  /**
   * RefreshRate deleteMany
   */
  export type RefreshRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshRates to delete
     */
    where?: RefreshRateWhereInput
    /**
     * Limit how many RefreshRates to delete.
     */
    limit?: number
  }

  /**
   * RefreshRate.modules
   */
  export type RefreshRate$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    where?: ModuleRefreshRateWhereInput
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    cursor?: ModuleRefreshRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleRefreshRateScalarFieldEnum | ModuleRefreshRateScalarFieldEnum[]
  }

  /**
   * RefreshRate without action
   */
  export type RefreshRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshRate
     */
    select?: RefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshRate
     */
    omit?: RefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshRateInclude<ExtArgs> | null
  }


  /**
   * Model Brightness
   */

  export type AggregateBrightness = {
    _count: BrightnessCountAggregateOutputType | null
    _avg: BrightnessAvgAggregateOutputType | null
    _sum: BrightnessSumAggregateOutputType | null
    _min: BrightnessMinAggregateOutputType | null
    _max: BrightnessMaxAggregateOutputType | null
  }

  export type BrightnessAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type BrightnessSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type BrightnessMinAggregateOutputType = {
    id: number | null
    code: string | null
    value: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrightnessMaxAggregateOutputType = {
    id: number | null
    code: string | null
    value: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrightnessCountAggregateOutputType = {
    id: number
    code: number
    value: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrightnessAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type BrightnessSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type BrightnessMinAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrightnessMaxAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrightnessCountAggregateInputType = {
    id?: true
    code?: true
    value?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrightnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brightness to aggregate.
     */
    where?: BrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brightnesses to fetch.
     */
    orderBy?: BrightnessOrderByWithRelationInput | BrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brightnesses
    **/
    _count?: true | BrightnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrightnessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrightnessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrightnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrightnessMaxAggregateInputType
  }

  export type GetBrightnessAggregateType<T extends BrightnessAggregateArgs> = {
        [P in keyof T & keyof AggregateBrightness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrightness[P]>
      : GetScalarType<T[P], AggregateBrightness[P]>
  }




  export type BrightnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrightnessWhereInput
    orderBy?: BrightnessOrderByWithAggregationInput | BrightnessOrderByWithAggregationInput[]
    by: BrightnessScalarFieldEnum[] | BrightnessScalarFieldEnum
    having?: BrightnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrightnessCountAggregateInputType | true
    _avg?: BrightnessAvgAggregateInputType
    _sum?: BrightnessSumAggregateInputType
    _min?: BrightnessMinAggregateInputType
    _max?: BrightnessMaxAggregateInputType
  }

  export type BrightnessGroupByOutputType = {
    id: number
    code: string
    value: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BrightnessCountAggregateOutputType | null
    _avg: BrightnessAvgAggregateOutputType | null
    _sum: BrightnessSumAggregateOutputType | null
    _min: BrightnessMinAggregateOutputType | null
    _max: BrightnessMaxAggregateOutputType | null
  }

  type GetBrightnessGroupByPayload<T extends BrightnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrightnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrightnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrightnessGroupByOutputType[P]>
            : GetScalarType<T[P], BrightnessGroupByOutputType[P]>
        }
      >
    >


  export type BrightnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | Brightness$modulesArgs<ExtArgs>
    _count?: boolean | BrightnessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brightness"]>

  export type BrightnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brightness"]>

  export type BrightnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brightness"]>

  export type BrightnessSelectScalar = {
    id?: boolean
    code?: boolean
    value?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrightnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "value" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["brightness"]>
  export type BrightnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | Brightness$modulesArgs<ExtArgs>
    _count?: boolean | BrightnessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrightnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrightnessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrightnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brightness"
    objects: {
      modules: Prisma.$ModuleBrightnessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      value: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brightness"]>
    composites: {}
  }

  type BrightnessGetPayload<S extends boolean | null | undefined | BrightnessDefaultArgs> = $Result.GetResult<Prisma.$BrightnessPayload, S>

  type BrightnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrightnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrightnessCountAggregateInputType | true
    }

  export interface BrightnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brightness'], meta: { name: 'Brightness' } }
    /**
     * Find zero or one Brightness that matches the filter.
     * @param {BrightnessFindUniqueArgs} args - Arguments to find a Brightness
     * @example
     * // Get one Brightness
     * const brightness = await prisma.brightness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrightnessFindUniqueArgs>(args: SelectSubset<T, BrightnessFindUniqueArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brightness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrightnessFindUniqueOrThrowArgs} args - Arguments to find a Brightness
     * @example
     * // Get one Brightness
     * const brightness = await prisma.brightness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrightnessFindUniqueOrThrowArgs>(args: SelectSubset<T, BrightnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brightness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessFindFirstArgs} args - Arguments to find a Brightness
     * @example
     * // Get one Brightness
     * const brightness = await prisma.brightness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrightnessFindFirstArgs>(args?: SelectSubset<T, BrightnessFindFirstArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brightness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessFindFirstOrThrowArgs} args - Arguments to find a Brightness
     * @example
     * // Get one Brightness
     * const brightness = await prisma.brightness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrightnessFindFirstOrThrowArgs>(args?: SelectSubset<T, BrightnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brightnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brightnesses
     * const brightnesses = await prisma.brightness.findMany()
     * 
     * // Get first 10 Brightnesses
     * const brightnesses = await prisma.brightness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brightnessWithIdOnly = await prisma.brightness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrightnessFindManyArgs>(args?: SelectSubset<T, BrightnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brightness.
     * @param {BrightnessCreateArgs} args - Arguments to create a Brightness.
     * @example
     * // Create one Brightness
     * const Brightness = await prisma.brightness.create({
     *   data: {
     *     // ... data to create a Brightness
     *   }
     * })
     * 
     */
    create<T extends BrightnessCreateArgs>(args: SelectSubset<T, BrightnessCreateArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brightnesses.
     * @param {BrightnessCreateManyArgs} args - Arguments to create many Brightnesses.
     * @example
     * // Create many Brightnesses
     * const brightness = await prisma.brightness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrightnessCreateManyArgs>(args?: SelectSubset<T, BrightnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brightnesses and returns the data saved in the database.
     * @param {BrightnessCreateManyAndReturnArgs} args - Arguments to create many Brightnesses.
     * @example
     * // Create many Brightnesses
     * const brightness = await prisma.brightness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brightnesses and only return the `id`
     * const brightnessWithIdOnly = await prisma.brightness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrightnessCreateManyAndReturnArgs>(args?: SelectSubset<T, BrightnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brightness.
     * @param {BrightnessDeleteArgs} args - Arguments to delete one Brightness.
     * @example
     * // Delete one Brightness
     * const Brightness = await prisma.brightness.delete({
     *   where: {
     *     // ... filter to delete one Brightness
     *   }
     * })
     * 
     */
    delete<T extends BrightnessDeleteArgs>(args: SelectSubset<T, BrightnessDeleteArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brightness.
     * @param {BrightnessUpdateArgs} args - Arguments to update one Brightness.
     * @example
     * // Update one Brightness
     * const brightness = await prisma.brightness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrightnessUpdateArgs>(args: SelectSubset<T, BrightnessUpdateArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brightnesses.
     * @param {BrightnessDeleteManyArgs} args - Arguments to filter Brightnesses to delete.
     * @example
     * // Delete a few Brightnesses
     * const { count } = await prisma.brightness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrightnessDeleteManyArgs>(args?: SelectSubset<T, BrightnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brightnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brightnesses
     * const brightness = await prisma.brightness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrightnessUpdateManyArgs>(args: SelectSubset<T, BrightnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brightnesses and returns the data updated in the database.
     * @param {BrightnessUpdateManyAndReturnArgs} args - Arguments to update many Brightnesses.
     * @example
     * // Update many Brightnesses
     * const brightness = await prisma.brightness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brightnesses and only return the `id`
     * const brightnessWithIdOnly = await prisma.brightness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrightnessUpdateManyAndReturnArgs>(args: SelectSubset<T, BrightnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brightness.
     * @param {BrightnessUpsertArgs} args - Arguments to update or create a Brightness.
     * @example
     * // Update or create a Brightness
     * const brightness = await prisma.brightness.upsert({
     *   create: {
     *     // ... data to create a Brightness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brightness we want to update
     *   }
     * })
     */
    upsert<T extends BrightnessUpsertArgs>(args: SelectSubset<T, BrightnessUpsertArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brightnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessCountArgs} args - Arguments to filter Brightnesses to count.
     * @example
     * // Count the number of Brightnesses
     * const count = await prisma.brightness.count({
     *   where: {
     *     // ... the filter for the Brightnesses we want to count
     *   }
     * })
    **/
    count<T extends BrightnessCountArgs>(
      args?: Subset<T, BrightnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrightnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brightness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrightnessAggregateArgs>(args: Subset<T, BrightnessAggregateArgs>): Prisma.PrismaPromise<GetBrightnessAggregateType<T>>

    /**
     * Group by Brightness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrightnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrightnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrightnessGroupByArgs['orderBy'] }
        : { orderBy?: BrightnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrightnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrightnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brightness model
   */
  readonly fields: BrightnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brightness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrightnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends Brightness$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Brightness$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brightness model
   */
  interface BrightnessFieldRefs {
    readonly id: FieldRef<"Brightness", 'Int'>
    readonly code: FieldRef<"Brightness", 'String'>
    readonly value: FieldRef<"Brightness", 'Int'>
    readonly active: FieldRef<"Brightness", 'Boolean'>
    readonly createdAt: FieldRef<"Brightness", 'DateTime'>
    readonly updatedAt: FieldRef<"Brightness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brightness findUnique
   */
  export type BrightnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter, which Brightness to fetch.
     */
    where: BrightnessWhereUniqueInput
  }

  /**
   * Brightness findUniqueOrThrow
   */
  export type BrightnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter, which Brightness to fetch.
     */
    where: BrightnessWhereUniqueInput
  }

  /**
   * Brightness findFirst
   */
  export type BrightnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter, which Brightness to fetch.
     */
    where?: BrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brightnesses to fetch.
     */
    orderBy?: BrightnessOrderByWithRelationInput | BrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brightnesses.
     */
    cursor?: BrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brightnesses.
     */
    distinct?: BrightnessScalarFieldEnum | BrightnessScalarFieldEnum[]
  }

  /**
   * Brightness findFirstOrThrow
   */
  export type BrightnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter, which Brightness to fetch.
     */
    where?: BrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brightnesses to fetch.
     */
    orderBy?: BrightnessOrderByWithRelationInput | BrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brightnesses.
     */
    cursor?: BrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brightnesses.
     */
    distinct?: BrightnessScalarFieldEnum | BrightnessScalarFieldEnum[]
  }

  /**
   * Brightness findMany
   */
  export type BrightnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter, which Brightnesses to fetch.
     */
    where?: BrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brightnesses to fetch.
     */
    orderBy?: BrightnessOrderByWithRelationInput | BrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brightnesses.
     */
    cursor?: BrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brightnesses.
     */
    skip?: number
    distinct?: BrightnessScalarFieldEnum | BrightnessScalarFieldEnum[]
  }

  /**
   * Brightness create
   */
  export type BrightnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * The data needed to create a Brightness.
     */
    data: XOR<BrightnessCreateInput, BrightnessUncheckedCreateInput>
  }

  /**
   * Brightness createMany
   */
  export type BrightnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brightnesses.
     */
    data: BrightnessCreateManyInput | BrightnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brightness createManyAndReturn
   */
  export type BrightnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * The data used to create many Brightnesses.
     */
    data: BrightnessCreateManyInput | BrightnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brightness update
   */
  export type BrightnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * The data needed to update a Brightness.
     */
    data: XOR<BrightnessUpdateInput, BrightnessUncheckedUpdateInput>
    /**
     * Choose, which Brightness to update.
     */
    where: BrightnessWhereUniqueInput
  }

  /**
   * Brightness updateMany
   */
  export type BrightnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brightnesses.
     */
    data: XOR<BrightnessUpdateManyMutationInput, BrightnessUncheckedUpdateManyInput>
    /**
     * Filter which Brightnesses to update
     */
    where?: BrightnessWhereInput
    /**
     * Limit how many Brightnesses to update.
     */
    limit?: number
  }

  /**
   * Brightness updateManyAndReturn
   */
  export type BrightnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * The data used to update Brightnesses.
     */
    data: XOR<BrightnessUpdateManyMutationInput, BrightnessUncheckedUpdateManyInput>
    /**
     * Filter which Brightnesses to update
     */
    where?: BrightnessWhereInput
    /**
     * Limit how many Brightnesses to update.
     */
    limit?: number
  }

  /**
   * Brightness upsert
   */
  export type BrightnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * The filter to search for the Brightness to update in case it exists.
     */
    where: BrightnessWhereUniqueInput
    /**
     * In case the Brightness found by the `where` argument doesn't exist, create a new Brightness with this data.
     */
    create: XOR<BrightnessCreateInput, BrightnessUncheckedCreateInput>
    /**
     * In case the Brightness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrightnessUpdateInput, BrightnessUncheckedUpdateInput>
  }

  /**
   * Brightness delete
   */
  export type BrightnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
    /**
     * Filter which Brightness to delete.
     */
    where: BrightnessWhereUniqueInput
  }

  /**
   * Brightness deleteMany
   */
  export type BrightnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brightnesses to delete
     */
    where?: BrightnessWhereInput
    /**
     * Limit how many Brightnesses to delete.
     */
    limit?: number
  }

  /**
   * Brightness.modules
   */
  export type Brightness$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    where?: ModuleBrightnessWhereInput
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    cursor?: ModuleBrightnessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleBrightnessScalarFieldEnum | ModuleBrightnessScalarFieldEnum[]
  }

  /**
   * Brightness without action
   */
  export type BrightnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brightness
     */
    select?: BrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brightness
     */
    omit?: BrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrightnessInclude<ExtArgs> | null
  }


  /**
   * Model Manufacturer
   */

  export type AggregateManufacturer = {
    _count: ManufacturerCountAggregateOutputType | null
    _avg: ManufacturerAvgAggregateOutputType | null
    _sum: ManufacturerSumAggregateOutputType | null
    _min: ManufacturerMinAggregateOutputType | null
    _max: ManufacturerMaxAggregateOutputType | null
  }

  export type ManufacturerAvgAggregateOutputType = {
    id: number | null
  }

  export type ManufacturerSumAggregateOutputType = {
    id: number | null
  }

  export type ManufacturerMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManufacturerMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManufacturerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManufacturerAvgAggregateInputType = {
    id?: true
  }

  export type ManufacturerSumAggregateInputType = {
    id?: true
  }

  export type ManufacturerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManufacturerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManufacturerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManufacturerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manufacturer to aggregate.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: ManufacturerOrderByWithRelationInput | ManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Manufacturers
    **/
    _count?: true | ManufacturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManufacturerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManufacturerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManufacturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManufacturerMaxAggregateInputType
  }

  export type GetManufacturerAggregateType<T extends ManufacturerAggregateArgs> = {
        [P in keyof T & keyof AggregateManufacturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManufacturer[P]>
      : GetScalarType<T[P], AggregateManufacturer[P]>
  }




  export type ManufacturerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManufacturerWhereInput
    orderBy?: ManufacturerOrderByWithAggregationInput | ManufacturerOrderByWithAggregationInput[]
    by: ManufacturerScalarFieldEnum[] | ManufacturerScalarFieldEnum
    having?: ManufacturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManufacturerCountAggregateInputType | true
    _avg?: ManufacturerAvgAggregateInputType
    _sum?: ManufacturerSumAggregateInputType
    _min?: ManufacturerMinAggregateInputType
    _max?: ManufacturerMaxAggregateInputType
  }

  export type ManufacturerGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ManufacturerCountAggregateOutputType | null
    _avg: ManufacturerAvgAggregateOutputType | null
    _sum: ManufacturerSumAggregateOutputType | null
    _min: ManufacturerMinAggregateOutputType | null
    _max: ManufacturerMaxAggregateOutputType | null
  }

  type GetManufacturerGroupByPayload<T extends ManufacturerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManufacturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManufacturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManufacturerGroupByOutputType[P]>
            : GetScalarType<T[P], ManufacturerGroupByOutputType[P]>
        }
      >
    >


  export type ManufacturerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Manufacturer$cabinetsArgs<ExtArgs>
    modules?: boolean | Manufacturer$modulesArgs<ExtArgs>
    _count?: boolean | ManufacturerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manufacturer"]>

  export type ManufacturerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["manufacturer"]>

  export type ManufacturerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["manufacturer"]>

  export type ManufacturerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManufacturerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["manufacturer"]>
  export type ManufacturerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Manufacturer$cabinetsArgs<ExtArgs>
    modules?: boolean | Manufacturer$modulesArgs<ExtArgs>
    _count?: boolean | ManufacturerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManufacturerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ManufacturerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ManufacturerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manufacturer"
    objects: {
      cabinets: Prisma.$CabinetManufacturerPayload<ExtArgs>[]
      modules: Prisma.$ModuleManufacturerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manufacturer"]>
    composites: {}
  }

  type ManufacturerGetPayload<S extends boolean | null | undefined | ManufacturerDefaultArgs> = $Result.GetResult<Prisma.$ManufacturerPayload, S>

  type ManufacturerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManufacturerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManufacturerCountAggregateInputType | true
    }

  export interface ManufacturerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manufacturer'], meta: { name: 'Manufacturer' } }
    /**
     * Find zero or one Manufacturer that matches the filter.
     * @param {ManufacturerFindUniqueArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManufacturerFindUniqueArgs>(args: SelectSubset<T, ManufacturerFindUniqueArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manufacturer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManufacturerFindUniqueOrThrowArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManufacturerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManufacturerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manufacturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindFirstArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManufacturerFindFirstArgs>(args?: SelectSubset<T, ManufacturerFindFirstArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manufacturer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindFirstOrThrowArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManufacturerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManufacturerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manufacturers
     * const manufacturers = await prisma.manufacturer.findMany()
     * 
     * // Get first 10 Manufacturers
     * const manufacturers = await prisma.manufacturer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manufacturerWithIdOnly = await prisma.manufacturer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManufacturerFindManyArgs>(args?: SelectSubset<T, ManufacturerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manufacturer.
     * @param {ManufacturerCreateArgs} args - Arguments to create a Manufacturer.
     * @example
     * // Create one Manufacturer
     * const Manufacturer = await prisma.manufacturer.create({
     *   data: {
     *     // ... data to create a Manufacturer
     *   }
     * })
     * 
     */
    create<T extends ManufacturerCreateArgs>(args: SelectSubset<T, ManufacturerCreateArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manufacturers.
     * @param {ManufacturerCreateManyArgs} args - Arguments to create many Manufacturers.
     * @example
     * // Create many Manufacturers
     * const manufacturer = await prisma.manufacturer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManufacturerCreateManyArgs>(args?: SelectSubset<T, ManufacturerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Manufacturers and returns the data saved in the database.
     * @param {ManufacturerCreateManyAndReturnArgs} args - Arguments to create many Manufacturers.
     * @example
     * // Create many Manufacturers
     * const manufacturer = await prisma.manufacturer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Manufacturers and only return the `id`
     * const manufacturerWithIdOnly = await prisma.manufacturer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManufacturerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManufacturerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manufacturer.
     * @param {ManufacturerDeleteArgs} args - Arguments to delete one Manufacturer.
     * @example
     * // Delete one Manufacturer
     * const Manufacturer = await prisma.manufacturer.delete({
     *   where: {
     *     // ... filter to delete one Manufacturer
     *   }
     * })
     * 
     */
    delete<T extends ManufacturerDeleteArgs>(args: SelectSubset<T, ManufacturerDeleteArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manufacturer.
     * @param {ManufacturerUpdateArgs} args - Arguments to update one Manufacturer.
     * @example
     * // Update one Manufacturer
     * const manufacturer = await prisma.manufacturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManufacturerUpdateArgs>(args: SelectSubset<T, ManufacturerUpdateArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manufacturers.
     * @param {ManufacturerDeleteManyArgs} args - Arguments to filter Manufacturers to delete.
     * @example
     * // Delete a few Manufacturers
     * const { count } = await prisma.manufacturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManufacturerDeleteManyArgs>(args?: SelectSubset<T, ManufacturerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manufacturers
     * const manufacturer = await prisma.manufacturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManufacturerUpdateManyArgs>(args: SelectSubset<T, ManufacturerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manufacturers and returns the data updated in the database.
     * @param {ManufacturerUpdateManyAndReturnArgs} args - Arguments to update many Manufacturers.
     * @example
     * // Update many Manufacturers
     * const manufacturer = await prisma.manufacturer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Manufacturers and only return the `id`
     * const manufacturerWithIdOnly = await prisma.manufacturer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManufacturerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManufacturerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manufacturer.
     * @param {ManufacturerUpsertArgs} args - Arguments to update or create a Manufacturer.
     * @example
     * // Update or create a Manufacturer
     * const manufacturer = await prisma.manufacturer.upsert({
     *   create: {
     *     // ... data to create a Manufacturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manufacturer we want to update
     *   }
     * })
     */
    upsert<T extends ManufacturerUpsertArgs>(args: SelectSubset<T, ManufacturerUpsertArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerCountArgs} args - Arguments to filter Manufacturers to count.
     * @example
     * // Count the number of Manufacturers
     * const count = await prisma.manufacturer.count({
     *   where: {
     *     // ... the filter for the Manufacturers we want to count
     *   }
     * })
    **/
    count<T extends ManufacturerCountArgs>(
      args?: Subset<T, ManufacturerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManufacturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManufacturerAggregateArgs>(args: Subset<T, ManufacturerAggregateArgs>): Prisma.PrismaPromise<GetManufacturerAggregateType<T>>

    /**
     * Group by Manufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManufacturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManufacturerGroupByArgs['orderBy'] }
        : { orderBy?: ManufacturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManufacturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManufacturerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manufacturer model
   */
  readonly fields: ManufacturerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manufacturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManufacturerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Manufacturer$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Manufacturer$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Manufacturer$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Manufacturer$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manufacturer model
   */
  interface ManufacturerFieldRefs {
    readonly id: FieldRef<"Manufacturer", 'Int'>
    readonly code: FieldRef<"Manufacturer", 'String'>
    readonly name: FieldRef<"Manufacturer", 'String'>
    readonly active: FieldRef<"Manufacturer", 'Boolean'>
    readonly createdAt: FieldRef<"Manufacturer", 'DateTime'>
    readonly updatedAt: FieldRef<"Manufacturer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Manufacturer findUnique
   */
  export type ManufacturerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where: ManufacturerWhereUniqueInput
  }

  /**
   * Manufacturer findUniqueOrThrow
   */
  export type ManufacturerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where: ManufacturerWhereUniqueInput
  }

  /**
   * Manufacturer findFirst
   */
  export type ManufacturerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: ManufacturerOrderByWithRelationInput | ManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manufacturers.
     */
    distinct?: ManufacturerScalarFieldEnum | ManufacturerScalarFieldEnum[]
  }

  /**
   * Manufacturer findFirstOrThrow
   */
  export type ManufacturerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: ManufacturerOrderByWithRelationInput | ManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manufacturers.
     */
    distinct?: ManufacturerScalarFieldEnum | ManufacturerScalarFieldEnum[]
  }

  /**
   * Manufacturer findMany
   */
  export type ManufacturerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturers to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: ManufacturerOrderByWithRelationInput | ManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    distinct?: ManufacturerScalarFieldEnum | ManufacturerScalarFieldEnum[]
  }

  /**
   * Manufacturer create
   */
  export type ManufacturerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manufacturer.
     */
    data: XOR<ManufacturerCreateInput, ManufacturerUncheckedCreateInput>
  }

  /**
   * Manufacturer createMany
   */
  export type ManufacturerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Manufacturers.
     */
    data: ManufacturerCreateManyInput | ManufacturerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manufacturer createManyAndReturn
   */
  export type ManufacturerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * The data used to create many Manufacturers.
     */
    data: ManufacturerCreateManyInput | ManufacturerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manufacturer update
   */
  export type ManufacturerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manufacturer.
     */
    data: XOR<ManufacturerUpdateInput, ManufacturerUncheckedUpdateInput>
    /**
     * Choose, which Manufacturer to update.
     */
    where: ManufacturerWhereUniqueInput
  }

  /**
   * Manufacturer updateMany
   */
  export type ManufacturerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Manufacturers.
     */
    data: XOR<ManufacturerUpdateManyMutationInput, ManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which Manufacturers to update
     */
    where?: ManufacturerWhereInput
    /**
     * Limit how many Manufacturers to update.
     */
    limit?: number
  }

  /**
   * Manufacturer updateManyAndReturn
   */
  export type ManufacturerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * The data used to update Manufacturers.
     */
    data: XOR<ManufacturerUpdateManyMutationInput, ManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which Manufacturers to update
     */
    where?: ManufacturerWhereInput
    /**
     * Limit how many Manufacturers to update.
     */
    limit?: number
  }

  /**
   * Manufacturer upsert
   */
  export type ManufacturerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manufacturer to update in case it exists.
     */
    where: ManufacturerWhereUniqueInput
    /**
     * In case the Manufacturer found by the `where` argument doesn't exist, create a new Manufacturer with this data.
     */
    create: XOR<ManufacturerCreateInput, ManufacturerUncheckedCreateInput>
    /**
     * In case the Manufacturer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManufacturerUpdateInput, ManufacturerUncheckedUpdateInput>
  }

  /**
   * Manufacturer delete
   */
  export type ManufacturerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter which Manufacturer to delete.
     */
    where: ManufacturerWhereUniqueInput
  }

  /**
   * Manufacturer deleteMany
   */
  export type ManufacturerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manufacturers to delete
     */
    where?: ManufacturerWhereInput
    /**
     * Limit how many Manufacturers to delete.
     */
    limit?: number
  }

  /**
   * Manufacturer.cabinets
   */
  export type Manufacturer$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    where?: CabinetManufacturerWhereInput
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    cursor?: CabinetManufacturerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetManufacturerScalarFieldEnum | CabinetManufacturerScalarFieldEnum[]
  }

  /**
   * Manufacturer.modules
   */
  export type Manufacturer$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    where?: ModuleManufacturerWhereInput
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    cursor?: ModuleManufacturerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleManufacturerScalarFieldEnum | ModuleManufacturerScalarFieldEnum[]
  }

  /**
   * Manufacturer without action
   */
  export type ManufacturerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manufacturer
     */
    omit?: ManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturerInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | Supplier$cabinetsArgs<ExtArgs>
    items?: boolean | Supplier$itemsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | Supplier$cabinetsArgs<ExtArgs>
    items?: boolean | Supplier$itemsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      cabinets: Prisma.$CabinetSupplierPayload<ExtArgs>[]
      items: Prisma.$ItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends Supplier$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Supplier$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly active: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.cabinets
   */
  export type Supplier$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    where?: CabinetSupplierWhereInput
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    cursor?: CabinetSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSupplierScalarFieldEnum | CabinetSupplierScalarFieldEnum[]
  }

  /**
   * Supplier.items
   */
  export type Supplier$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    cursor?: ItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model IpProtection
   */

  export type AggregateIpProtection = {
    _count: IpProtectionCountAggregateOutputType | null
    _avg: IpProtectionAvgAggregateOutputType | null
    _sum: IpProtectionSumAggregateOutputType | null
    _min: IpProtectionMinAggregateOutputType | null
    _max: IpProtectionMaxAggregateOutputType | null
  }

  export type IpProtectionAvgAggregateOutputType = {
    id: number | null
  }

  export type IpProtectionSumAggregateOutputType = {
    id: number | null
  }

  export type IpProtectionMinAggregateOutputType = {
    id: number | null
    code: string | null
    protectionSolid: string | null
    protectionWater: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IpProtectionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    protectionSolid: string | null
    protectionWater: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IpProtectionCountAggregateOutputType = {
    id: number
    code: number
    protectionSolid: number
    protectionWater: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IpProtectionAvgAggregateInputType = {
    id?: true
  }

  export type IpProtectionSumAggregateInputType = {
    id?: true
  }

  export type IpProtectionMinAggregateInputType = {
    id?: true
    code?: true
    protectionSolid?: true
    protectionWater?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IpProtectionMaxAggregateInputType = {
    id?: true
    code?: true
    protectionSolid?: true
    protectionWater?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IpProtectionCountAggregateInputType = {
    id?: true
    code?: true
    protectionSolid?: true
    protectionWater?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IpProtectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpProtection to aggregate.
     */
    where?: IpProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpProtections to fetch.
     */
    orderBy?: IpProtectionOrderByWithRelationInput | IpProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IpProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IpProtections
    **/
    _count?: true | IpProtectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IpProtectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IpProtectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpProtectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpProtectionMaxAggregateInputType
  }

  export type GetIpProtectionAggregateType<T extends IpProtectionAggregateArgs> = {
        [P in keyof T & keyof AggregateIpProtection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIpProtection[P]>
      : GetScalarType<T[P], AggregateIpProtection[P]>
  }




  export type IpProtectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpProtectionWhereInput
    orderBy?: IpProtectionOrderByWithAggregationInput | IpProtectionOrderByWithAggregationInput[]
    by: IpProtectionScalarFieldEnum[] | IpProtectionScalarFieldEnum
    having?: IpProtectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpProtectionCountAggregateInputType | true
    _avg?: IpProtectionAvgAggregateInputType
    _sum?: IpProtectionSumAggregateInputType
    _min?: IpProtectionMinAggregateInputType
    _max?: IpProtectionMaxAggregateInputType
  }

  export type IpProtectionGroupByOutputType = {
    id: number
    code: string
    protectionSolid: string
    protectionWater: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: IpProtectionCountAggregateOutputType | null
    _avg: IpProtectionAvgAggregateOutputType | null
    _sum: IpProtectionSumAggregateOutputType | null
    _min: IpProtectionMinAggregateOutputType | null
    _max: IpProtectionMaxAggregateOutputType | null
  }

  type GetIpProtectionGroupByPayload<T extends IpProtectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpProtectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpProtectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpProtectionGroupByOutputType[P]>
            : GetScalarType<T[P], IpProtectionGroupByOutputType[P]>
        }
      >
    >


  export type IpProtectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    protectionSolid?: boolean
    protectionWater?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ipProtection"]>

  export type IpProtectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    protectionSolid?: boolean
    protectionWater?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ipProtection"]>

  export type IpProtectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    protectionSolid?: boolean
    protectionWater?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ipProtection"]>

  export type IpProtectionSelectScalar = {
    id?: boolean
    code?: boolean
    protectionSolid?: boolean
    protectionWater?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IpProtectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "protectionSolid" | "protectionWater" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["ipProtection"]>

  export type $IpProtectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IpProtection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      protectionSolid: string
      protectionWater: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ipProtection"]>
    composites: {}
  }

  type IpProtectionGetPayload<S extends boolean | null | undefined | IpProtectionDefaultArgs> = $Result.GetResult<Prisma.$IpProtectionPayload, S>

  type IpProtectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IpProtectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IpProtectionCountAggregateInputType | true
    }

  export interface IpProtectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IpProtection'], meta: { name: 'IpProtection' } }
    /**
     * Find zero or one IpProtection that matches the filter.
     * @param {IpProtectionFindUniqueArgs} args - Arguments to find a IpProtection
     * @example
     * // Get one IpProtection
     * const ipProtection = await prisma.ipProtection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IpProtectionFindUniqueArgs>(args: SelectSubset<T, IpProtectionFindUniqueArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IpProtection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IpProtectionFindUniqueOrThrowArgs} args - Arguments to find a IpProtection
     * @example
     * // Get one IpProtection
     * const ipProtection = await prisma.ipProtection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IpProtectionFindUniqueOrThrowArgs>(args: SelectSubset<T, IpProtectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpProtection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionFindFirstArgs} args - Arguments to find a IpProtection
     * @example
     * // Get one IpProtection
     * const ipProtection = await prisma.ipProtection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IpProtectionFindFirstArgs>(args?: SelectSubset<T, IpProtectionFindFirstArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpProtection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionFindFirstOrThrowArgs} args - Arguments to find a IpProtection
     * @example
     * // Get one IpProtection
     * const ipProtection = await prisma.ipProtection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IpProtectionFindFirstOrThrowArgs>(args?: SelectSubset<T, IpProtectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IpProtections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IpProtections
     * const ipProtections = await prisma.ipProtection.findMany()
     * 
     * // Get first 10 IpProtections
     * const ipProtections = await prisma.ipProtection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipProtectionWithIdOnly = await prisma.ipProtection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IpProtectionFindManyArgs>(args?: SelectSubset<T, IpProtectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IpProtection.
     * @param {IpProtectionCreateArgs} args - Arguments to create a IpProtection.
     * @example
     * // Create one IpProtection
     * const IpProtection = await prisma.ipProtection.create({
     *   data: {
     *     // ... data to create a IpProtection
     *   }
     * })
     * 
     */
    create<T extends IpProtectionCreateArgs>(args: SelectSubset<T, IpProtectionCreateArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IpProtections.
     * @param {IpProtectionCreateManyArgs} args - Arguments to create many IpProtections.
     * @example
     * // Create many IpProtections
     * const ipProtection = await prisma.ipProtection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IpProtectionCreateManyArgs>(args?: SelectSubset<T, IpProtectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IpProtections and returns the data saved in the database.
     * @param {IpProtectionCreateManyAndReturnArgs} args - Arguments to create many IpProtections.
     * @example
     * // Create many IpProtections
     * const ipProtection = await prisma.ipProtection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IpProtections and only return the `id`
     * const ipProtectionWithIdOnly = await prisma.ipProtection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IpProtectionCreateManyAndReturnArgs>(args?: SelectSubset<T, IpProtectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IpProtection.
     * @param {IpProtectionDeleteArgs} args - Arguments to delete one IpProtection.
     * @example
     * // Delete one IpProtection
     * const IpProtection = await prisma.ipProtection.delete({
     *   where: {
     *     // ... filter to delete one IpProtection
     *   }
     * })
     * 
     */
    delete<T extends IpProtectionDeleteArgs>(args: SelectSubset<T, IpProtectionDeleteArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IpProtection.
     * @param {IpProtectionUpdateArgs} args - Arguments to update one IpProtection.
     * @example
     * // Update one IpProtection
     * const ipProtection = await prisma.ipProtection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IpProtectionUpdateArgs>(args: SelectSubset<T, IpProtectionUpdateArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IpProtections.
     * @param {IpProtectionDeleteManyArgs} args - Arguments to filter IpProtections to delete.
     * @example
     * // Delete a few IpProtections
     * const { count } = await prisma.ipProtection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IpProtectionDeleteManyArgs>(args?: SelectSubset<T, IpProtectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpProtections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IpProtections
     * const ipProtection = await prisma.ipProtection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IpProtectionUpdateManyArgs>(args: SelectSubset<T, IpProtectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpProtections and returns the data updated in the database.
     * @param {IpProtectionUpdateManyAndReturnArgs} args - Arguments to update many IpProtections.
     * @example
     * // Update many IpProtections
     * const ipProtection = await prisma.ipProtection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IpProtections and only return the `id`
     * const ipProtectionWithIdOnly = await prisma.ipProtection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IpProtectionUpdateManyAndReturnArgs>(args: SelectSubset<T, IpProtectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IpProtection.
     * @param {IpProtectionUpsertArgs} args - Arguments to update or create a IpProtection.
     * @example
     * // Update or create a IpProtection
     * const ipProtection = await prisma.ipProtection.upsert({
     *   create: {
     *     // ... data to create a IpProtection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IpProtection we want to update
     *   }
     * })
     */
    upsert<T extends IpProtectionUpsertArgs>(args: SelectSubset<T, IpProtectionUpsertArgs<ExtArgs>>): Prisma__IpProtectionClient<$Result.GetResult<Prisma.$IpProtectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IpProtections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionCountArgs} args - Arguments to filter IpProtections to count.
     * @example
     * // Count the number of IpProtections
     * const count = await prisma.ipProtection.count({
     *   where: {
     *     // ... the filter for the IpProtections we want to count
     *   }
     * })
    **/
    count<T extends IpProtectionCountArgs>(
      args?: Subset<T, IpProtectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpProtectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IpProtection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpProtectionAggregateArgs>(args: Subset<T, IpProtectionAggregateArgs>): Prisma.PrismaPromise<GetIpProtectionAggregateType<T>>

    /**
     * Group by IpProtection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpProtectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IpProtectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IpProtectionGroupByArgs['orderBy'] }
        : { orderBy?: IpProtectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IpProtectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpProtectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IpProtection model
   */
  readonly fields: IpProtectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IpProtection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IpProtectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IpProtection model
   */
  interface IpProtectionFieldRefs {
    readonly id: FieldRef<"IpProtection", 'Int'>
    readonly code: FieldRef<"IpProtection", 'String'>
    readonly protectionSolid: FieldRef<"IpProtection", 'String'>
    readonly protectionWater: FieldRef<"IpProtection", 'String'>
    readonly active: FieldRef<"IpProtection", 'Boolean'>
    readonly createdAt: FieldRef<"IpProtection", 'DateTime'>
    readonly updatedAt: FieldRef<"IpProtection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IpProtection findUnique
   */
  export type IpProtectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter, which IpProtection to fetch.
     */
    where: IpProtectionWhereUniqueInput
  }

  /**
   * IpProtection findUniqueOrThrow
   */
  export type IpProtectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter, which IpProtection to fetch.
     */
    where: IpProtectionWhereUniqueInput
  }

  /**
   * IpProtection findFirst
   */
  export type IpProtectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter, which IpProtection to fetch.
     */
    where?: IpProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpProtections to fetch.
     */
    orderBy?: IpProtectionOrderByWithRelationInput | IpProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpProtections.
     */
    cursor?: IpProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpProtections.
     */
    distinct?: IpProtectionScalarFieldEnum | IpProtectionScalarFieldEnum[]
  }

  /**
   * IpProtection findFirstOrThrow
   */
  export type IpProtectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter, which IpProtection to fetch.
     */
    where?: IpProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpProtections to fetch.
     */
    orderBy?: IpProtectionOrderByWithRelationInput | IpProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpProtections.
     */
    cursor?: IpProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpProtections.
     */
    distinct?: IpProtectionScalarFieldEnum | IpProtectionScalarFieldEnum[]
  }

  /**
   * IpProtection findMany
   */
  export type IpProtectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter, which IpProtections to fetch.
     */
    where?: IpProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpProtections to fetch.
     */
    orderBy?: IpProtectionOrderByWithRelationInput | IpProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IpProtections.
     */
    cursor?: IpProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpProtections.
     */
    skip?: number
    distinct?: IpProtectionScalarFieldEnum | IpProtectionScalarFieldEnum[]
  }

  /**
   * IpProtection create
   */
  export type IpProtectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * The data needed to create a IpProtection.
     */
    data: XOR<IpProtectionCreateInput, IpProtectionUncheckedCreateInput>
  }

  /**
   * IpProtection createMany
   */
  export type IpProtectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IpProtections.
     */
    data: IpProtectionCreateManyInput | IpProtectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpProtection createManyAndReturn
   */
  export type IpProtectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * The data used to create many IpProtections.
     */
    data: IpProtectionCreateManyInput | IpProtectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpProtection update
   */
  export type IpProtectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * The data needed to update a IpProtection.
     */
    data: XOR<IpProtectionUpdateInput, IpProtectionUncheckedUpdateInput>
    /**
     * Choose, which IpProtection to update.
     */
    where: IpProtectionWhereUniqueInput
  }

  /**
   * IpProtection updateMany
   */
  export type IpProtectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IpProtections.
     */
    data: XOR<IpProtectionUpdateManyMutationInput, IpProtectionUncheckedUpdateManyInput>
    /**
     * Filter which IpProtections to update
     */
    where?: IpProtectionWhereInput
    /**
     * Limit how many IpProtections to update.
     */
    limit?: number
  }

  /**
   * IpProtection updateManyAndReturn
   */
  export type IpProtectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * The data used to update IpProtections.
     */
    data: XOR<IpProtectionUpdateManyMutationInput, IpProtectionUncheckedUpdateManyInput>
    /**
     * Filter which IpProtections to update
     */
    where?: IpProtectionWhereInput
    /**
     * Limit how many IpProtections to update.
     */
    limit?: number
  }

  /**
   * IpProtection upsert
   */
  export type IpProtectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * The filter to search for the IpProtection to update in case it exists.
     */
    where: IpProtectionWhereUniqueInput
    /**
     * In case the IpProtection found by the `where` argument doesn't exist, create a new IpProtection with this data.
     */
    create: XOR<IpProtectionCreateInput, IpProtectionUncheckedCreateInput>
    /**
     * In case the IpProtection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IpProtectionUpdateInput, IpProtectionUncheckedUpdateInput>
  }

  /**
   * IpProtection delete
   */
  export type IpProtectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
    /**
     * Filter which IpProtection to delete.
     */
    where: IpProtectionWhereUniqueInput
  }

  /**
   * IpProtection deleteMany
   */
  export type IpProtectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpProtections to delete
     */
    where?: IpProtectionWhereInput
    /**
     * Limit how many IpProtections to delete.
     */
    limit?: number
  }

  /**
   * IpProtection without action
   */
  export type IpProtectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpProtection
     */
    select?: IpProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpProtection
     */
    omit?: IpProtectionOmit<ExtArgs> | null
  }


  /**
   * Model ModuleSize
   */

  export type AggregateModuleSize = {
    _count: ModuleSizeCountAggregateOutputType | null
    _avg: ModuleSizeAvgAggregateOutputType | null
    _sum: ModuleSizeSumAggregateOutputType | null
    _min: ModuleSizeMinAggregateOutputType | null
    _max: ModuleSizeMaxAggregateOutputType | null
  }

  export type ModuleSizeAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
  }

  export type ModuleSizeSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
  }

  export type ModuleSizeMinAggregateOutputType = {
    id: number | null
    code: string | null
    size: string | null
    width: number | null
    height: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleSizeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    size: string | null
    width: number | null
    height: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleSizeCountAggregateOutputType = {
    id: number
    code: number
    size: number
    width: number
    height: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleSizeAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
  }

  export type ModuleSizeSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
  }

  export type ModuleSizeMinAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleSizeMaxAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleSizeCountAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleSize to aggregate.
     */
    where?: ModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSizes to fetch.
     */
    orderBy?: ModuleSizeOrderByWithRelationInput | ModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleSizes
    **/
    _count?: true | ModuleSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleSizeMaxAggregateInputType
  }

  export type GetModuleSizeAggregateType<T extends ModuleSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleSize[P]>
      : GetScalarType<T[P], AggregateModuleSize[P]>
  }




  export type ModuleSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleSizeWhereInput
    orderBy?: ModuleSizeOrderByWithAggregationInput | ModuleSizeOrderByWithAggregationInput[]
    by: ModuleSizeScalarFieldEnum[] | ModuleSizeScalarFieldEnum
    having?: ModuleSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleSizeCountAggregateInputType | true
    _avg?: ModuleSizeAvgAggregateInputType
    _sum?: ModuleSizeSumAggregateInputType
    _min?: ModuleSizeMinAggregateInputType
    _max?: ModuleSizeMaxAggregateInputType
  }

  export type ModuleSizeGroupByOutputType = {
    id: number
    code: string
    size: string
    width: number
    height: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ModuleSizeCountAggregateOutputType | null
    _avg: ModuleSizeAvgAggregateOutputType | null
    _sum: ModuleSizeSumAggregateOutputType | null
    _min: ModuleSizeMinAggregateOutputType | null
    _max: ModuleSizeMaxAggregateOutputType | null
  }

  type GetModuleSizeGroupByPayload<T extends ModuleSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleSizeGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | ModuleSize$modulesArgs<ExtArgs>
    cabinetSizes?: boolean | ModuleSize$cabinetSizesArgs<ExtArgs>
    _count?: boolean | ModuleSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleSize"]>

  export type ModuleSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["moduleSize"]>

  export type ModuleSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["moduleSize"]>

  export type ModuleSizeSelectScalar = {
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "size" | "width" | "height" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["moduleSize"]>
  export type ModuleSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | ModuleSize$modulesArgs<ExtArgs>
    cabinetSizes?: boolean | ModuleSize$cabinetSizesArgs<ExtArgs>
    _count?: boolean | ModuleSizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModuleSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModuleSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleSize"
    objects: {
      modules: Prisma.$ModuleModuleSizePayload<ExtArgs>[]
      cabinetSizes: Prisma.$CabinetSizeModuleSizePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      size: string
      width: number
      height: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moduleSize"]>
    composites: {}
  }

  type ModuleSizeGetPayload<S extends boolean | null | undefined | ModuleSizeDefaultArgs> = $Result.GetResult<Prisma.$ModuleSizePayload, S>

  type ModuleSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleSizeCountAggregateInputType | true
    }

  export interface ModuleSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleSize'], meta: { name: 'ModuleSize' } }
    /**
     * Find zero or one ModuleSize that matches the filter.
     * @param {ModuleSizeFindUniqueArgs} args - Arguments to find a ModuleSize
     * @example
     * // Get one ModuleSize
     * const moduleSize = await prisma.moduleSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleSizeFindUniqueArgs>(args: SelectSubset<T, ModuleSizeFindUniqueArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleSizeFindUniqueOrThrowArgs} args - Arguments to find a ModuleSize
     * @example
     * // Get one ModuleSize
     * const moduleSize = await prisma.moduleSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeFindFirstArgs} args - Arguments to find a ModuleSize
     * @example
     * // Get one ModuleSize
     * const moduleSize = await prisma.moduleSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleSizeFindFirstArgs>(args?: SelectSubset<T, ModuleSizeFindFirstArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeFindFirstOrThrowArgs} args - Arguments to find a ModuleSize
     * @example
     * // Get one ModuleSize
     * const moduleSize = await prisma.moduleSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleSizes
     * const moduleSizes = await prisma.moduleSize.findMany()
     * 
     * // Get first 10 ModuleSizes
     * const moduleSizes = await prisma.moduleSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleSizeWithIdOnly = await prisma.moduleSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleSizeFindManyArgs>(args?: SelectSubset<T, ModuleSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleSize.
     * @param {ModuleSizeCreateArgs} args - Arguments to create a ModuleSize.
     * @example
     * // Create one ModuleSize
     * const ModuleSize = await prisma.moduleSize.create({
     *   data: {
     *     // ... data to create a ModuleSize
     *   }
     * })
     * 
     */
    create<T extends ModuleSizeCreateArgs>(args: SelectSubset<T, ModuleSizeCreateArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleSizes.
     * @param {ModuleSizeCreateManyArgs} args - Arguments to create many ModuleSizes.
     * @example
     * // Create many ModuleSizes
     * const moduleSize = await prisma.moduleSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleSizeCreateManyArgs>(args?: SelectSubset<T, ModuleSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleSizes and returns the data saved in the database.
     * @param {ModuleSizeCreateManyAndReturnArgs} args - Arguments to create many ModuleSizes.
     * @example
     * // Create many ModuleSizes
     * const moduleSize = await prisma.moduleSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleSizes and only return the `id`
     * const moduleSizeWithIdOnly = await prisma.moduleSize.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleSize.
     * @param {ModuleSizeDeleteArgs} args - Arguments to delete one ModuleSize.
     * @example
     * // Delete one ModuleSize
     * const ModuleSize = await prisma.moduleSize.delete({
     *   where: {
     *     // ... filter to delete one ModuleSize
     *   }
     * })
     * 
     */
    delete<T extends ModuleSizeDeleteArgs>(args: SelectSubset<T, ModuleSizeDeleteArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleSize.
     * @param {ModuleSizeUpdateArgs} args - Arguments to update one ModuleSize.
     * @example
     * // Update one ModuleSize
     * const moduleSize = await prisma.moduleSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleSizeUpdateArgs>(args: SelectSubset<T, ModuleSizeUpdateArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleSizes.
     * @param {ModuleSizeDeleteManyArgs} args - Arguments to filter ModuleSizes to delete.
     * @example
     * // Delete a few ModuleSizes
     * const { count } = await prisma.moduleSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleSizeDeleteManyArgs>(args?: SelectSubset<T, ModuleSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleSizes
     * const moduleSize = await prisma.moduleSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleSizeUpdateManyArgs>(args: SelectSubset<T, ModuleSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleSizes and returns the data updated in the database.
     * @param {ModuleSizeUpdateManyAndReturnArgs} args - Arguments to update many ModuleSizes.
     * @example
     * // Update many ModuleSizes
     * const moduleSize = await prisma.moduleSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleSizes and only return the `id`
     * const moduleSizeWithIdOnly = await prisma.moduleSize.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleSize.
     * @param {ModuleSizeUpsertArgs} args - Arguments to update or create a ModuleSize.
     * @example
     * // Update or create a ModuleSize
     * const moduleSize = await prisma.moduleSize.upsert({
     *   create: {
     *     // ... data to create a ModuleSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleSize we want to update
     *   }
     * })
     */
    upsert<T extends ModuleSizeUpsertArgs>(args: SelectSubset<T, ModuleSizeUpsertArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeCountArgs} args - Arguments to filter ModuleSizes to count.
     * @example
     * // Count the number of ModuleSizes
     * const count = await prisma.moduleSize.count({
     *   where: {
     *     // ... the filter for the ModuleSizes we want to count
     *   }
     * })
    **/
    count<T extends ModuleSizeCountArgs>(
      args?: Subset<T, ModuleSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleSizeAggregateArgs>(args: Subset<T, ModuleSizeAggregateArgs>): Prisma.PrismaPromise<GetModuleSizeAggregateType<T>>

    /**
     * Group by ModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleSizeGroupByArgs['orderBy'] }
        : { orderBy?: ModuleSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleSize model
   */
  readonly fields: ModuleSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends ModuleSize$modulesArgs<ExtArgs> = {}>(args?: Subset<T, ModuleSize$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinetSizes<T extends ModuleSize$cabinetSizesArgs<ExtArgs> = {}>(args?: Subset<T, ModuleSize$cabinetSizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleSize model
   */
  interface ModuleSizeFieldRefs {
    readonly id: FieldRef<"ModuleSize", 'Int'>
    readonly code: FieldRef<"ModuleSize", 'String'>
    readonly size: FieldRef<"ModuleSize", 'String'>
    readonly width: FieldRef<"ModuleSize", 'Int'>
    readonly height: FieldRef<"ModuleSize", 'Int'>
    readonly active: FieldRef<"ModuleSize", 'Boolean'>
    readonly createdAt: FieldRef<"ModuleSize", 'DateTime'>
    readonly updatedAt: FieldRef<"ModuleSize", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuleSize findUnique
   */
  export type ModuleSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSize to fetch.
     */
    where: ModuleSizeWhereUniqueInput
  }

  /**
   * ModuleSize findUniqueOrThrow
   */
  export type ModuleSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSize to fetch.
     */
    where: ModuleSizeWhereUniqueInput
  }

  /**
   * ModuleSize findFirst
   */
  export type ModuleSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSize to fetch.
     */
    where?: ModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSizes to fetch.
     */
    orderBy?: ModuleSizeOrderByWithRelationInput | ModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleSizes.
     */
    cursor?: ModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleSizes.
     */
    distinct?: ModuleSizeScalarFieldEnum | ModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleSize findFirstOrThrow
   */
  export type ModuleSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSize to fetch.
     */
    where?: ModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSizes to fetch.
     */
    orderBy?: ModuleSizeOrderByWithRelationInput | ModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleSizes.
     */
    cursor?: ModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleSizes.
     */
    distinct?: ModuleSizeScalarFieldEnum | ModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleSize findMany
   */
  export type ModuleSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSizes to fetch.
     */
    where?: ModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSizes to fetch.
     */
    orderBy?: ModuleSizeOrderByWithRelationInput | ModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleSizes.
     */
    cursor?: ModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSizes.
     */
    skip?: number
    distinct?: ModuleSizeScalarFieldEnum | ModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleSize create
   */
  export type ModuleSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleSize.
     */
    data: XOR<ModuleSizeCreateInput, ModuleSizeUncheckedCreateInput>
  }

  /**
   * ModuleSize createMany
   */
  export type ModuleSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleSizes.
     */
    data: ModuleSizeCreateManyInput | ModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleSize createManyAndReturn
   */
  export type ModuleSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleSizes.
     */
    data: ModuleSizeCreateManyInput | ModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleSize update
   */
  export type ModuleSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleSize.
     */
    data: XOR<ModuleSizeUpdateInput, ModuleSizeUncheckedUpdateInput>
    /**
     * Choose, which ModuleSize to update.
     */
    where: ModuleSizeWhereUniqueInput
  }

  /**
   * ModuleSize updateMany
   */
  export type ModuleSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleSizes.
     */
    data: XOR<ModuleSizeUpdateManyMutationInput, ModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which ModuleSizes to update
     */
    where?: ModuleSizeWhereInput
    /**
     * Limit how many ModuleSizes to update.
     */
    limit?: number
  }

  /**
   * ModuleSize updateManyAndReturn
   */
  export type ModuleSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to update ModuleSizes.
     */
    data: XOR<ModuleSizeUpdateManyMutationInput, ModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which ModuleSizes to update
     */
    where?: ModuleSizeWhereInput
    /**
     * Limit how many ModuleSizes to update.
     */
    limit?: number
  }

  /**
   * ModuleSize upsert
   */
  export type ModuleSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleSize to update in case it exists.
     */
    where: ModuleSizeWhereUniqueInput
    /**
     * In case the ModuleSize found by the `where` argument doesn't exist, create a new ModuleSize with this data.
     */
    create: XOR<ModuleSizeCreateInput, ModuleSizeUncheckedCreateInput>
    /**
     * In case the ModuleSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleSizeUpdateInput, ModuleSizeUncheckedUpdateInput>
  }

  /**
   * ModuleSize delete
   */
  export type ModuleSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
    /**
     * Filter which ModuleSize to delete.
     */
    where: ModuleSizeWhereUniqueInput
  }

  /**
   * ModuleSize deleteMany
   */
  export type ModuleSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleSizes to delete
     */
    where?: ModuleSizeWhereInput
    /**
     * Limit how many ModuleSizes to delete.
     */
    limit?: number
  }

  /**
   * ModuleSize.modules
   */
  export type ModuleSize$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    where?: ModuleModuleSizeWhereInput
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    cursor?: ModuleModuleSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleModuleSizeScalarFieldEnum | ModuleModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleSize.cabinetSizes
   */
  export type ModuleSize$cabinetSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    where?: CabinetSizeModuleSizeWhereInput
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSizeModuleSizeScalarFieldEnum | CabinetSizeModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleSize without action
   */
  export type ModuleSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSize
     */
    select?: ModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSize
     */
    omit?: ModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSizeInclude<ExtArgs> | null
  }


  /**
   * Model CabinetSize
   */

  export type AggregateCabinetSize = {
    _count: CabinetSizeCountAggregateOutputType | null
    _avg: CabinetSizeAvgAggregateOutputType | null
    _sum: CabinetSizeSumAggregateOutputType | null
    _min: CabinetSizeMinAggregateOutputType | null
    _max: CabinetSizeMaxAggregateOutputType | null
  }

  export type CabinetSizeAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
  }

  export type CabinetSizeSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
  }

  export type CabinetSizeMinAggregateOutputType = {
    id: number | null
    code: string | null
    size: string | null
    width: number | null
    height: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetSizeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    size: string | null
    width: number | null
    height: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetSizeCountAggregateOutputType = {
    id: number
    code: number
    size: number
    width: number
    height: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CabinetSizeAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
  }

  export type CabinetSizeSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
  }

  export type CabinetSizeMinAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetSizeMaxAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetSizeCountAggregateInputType = {
    id?: true
    code?: true
    size?: true
    width?: true
    height?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CabinetSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSize to aggregate.
     */
    where?: CabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizes to fetch.
     */
    orderBy?: CabinetSizeOrderByWithRelationInput | CabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetSizes
    **/
    _count?: true | CabinetSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CabinetSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CabinetSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetSizeMaxAggregateInputType
  }

  export type GetCabinetSizeAggregateType<T extends CabinetSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetSize[P]>
      : GetScalarType<T[P], AggregateCabinetSize[P]>
  }




  export type CabinetSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSizeWhereInput
    orderBy?: CabinetSizeOrderByWithAggregationInput | CabinetSizeOrderByWithAggregationInput[]
    by: CabinetSizeScalarFieldEnum[] | CabinetSizeScalarFieldEnum
    having?: CabinetSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetSizeCountAggregateInputType | true
    _avg?: CabinetSizeAvgAggregateInputType
    _sum?: CabinetSizeSumAggregateInputType
    _min?: CabinetSizeMinAggregateInputType
    _max?: CabinetSizeMaxAggregateInputType
  }

  export type CabinetSizeGroupByOutputType = {
    id: number
    code: string
    size: string
    width: number
    height: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CabinetSizeCountAggregateOutputType | null
    _avg: CabinetSizeAvgAggregateOutputType | null
    _sum: CabinetSizeSumAggregateOutputType | null
    _min: CabinetSizeMinAggregateOutputType | null
    _max: CabinetSizeMaxAggregateOutputType | null
  }

  type GetCabinetSizeGroupByPayload<T extends CabinetSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetSizeGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetSizeGroupByOutputType[P]>
        }
      >
    >


  export type CabinetSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cabinets?: boolean | CabinetSize$cabinetsArgs<ExtArgs>
    moduleSizes?: boolean | CabinetSize$moduleSizesArgs<ExtArgs>
    _count?: boolean | CabinetSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSize"]>

  export type CabinetSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cabinetSize"]>

  export type CabinetSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cabinetSize"]>

  export type CabinetSizeSelectScalar = {
    id?: boolean
    code?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CabinetSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "size" | "width" | "height" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["cabinetSize"]>
  export type CabinetSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinets?: boolean | CabinetSize$cabinetsArgs<ExtArgs>
    moduleSizes?: boolean | CabinetSize$moduleSizesArgs<ExtArgs>
    _count?: boolean | CabinetSizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CabinetSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CabinetSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CabinetSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetSize"
    objects: {
      cabinets: Prisma.$CabinetCabinetSizePayload<ExtArgs>[]
      moduleSizes: Prisma.$CabinetSizeModuleSizePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      size: string
      width: number
      height: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cabinetSize"]>
    composites: {}
  }

  type CabinetSizeGetPayload<S extends boolean | null | undefined | CabinetSizeDefaultArgs> = $Result.GetResult<Prisma.$CabinetSizePayload, S>

  type CabinetSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetSizeCountAggregateInputType | true
    }

  export interface CabinetSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetSize'], meta: { name: 'CabinetSize' } }
    /**
     * Find zero or one CabinetSize that matches the filter.
     * @param {CabinetSizeFindUniqueArgs} args - Arguments to find a CabinetSize
     * @example
     * // Get one CabinetSize
     * const cabinetSize = await prisma.cabinetSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetSizeFindUniqueArgs>(args: SelectSubset<T, CabinetSizeFindUniqueArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetSizeFindUniqueOrThrowArgs} args - Arguments to find a CabinetSize
     * @example
     * // Get one CabinetSize
     * const cabinetSize = await prisma.cabinetSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeFindFirstArgs} args - Arguments to find a CabinetSize
     * @example
     * // Get one CabinetSize
     * const cabinetSize = await prisma.cabinetSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetSizeFindFirstArgs>(args?: SelectSubset<T, CabinetSizeFindFirstArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeFindFirstOrThrowArgs} args - Arguments to find a CabinetSize
     * @example
     * // Get one CabinetSize
     * const cabinetSize = await prisma.cabinetSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetSizes
     * const cabinetSizes = await prisma.cabinetSize.findMany()
     * 
     * // Get first 10 CabinetSizes
     * const cabinetSizes = await prisma.cabinetSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cabinetSizeWithIdOnly = await prisma.cabinetSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CabinetSizeFindManyArgs>(args?: SelectSubset<T, CabinetSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetSize.
     * @param {CabinetSizeCreateArgs} args - Arguments to create a CabinetSize.
     * @example
     * // Create one CabinetSize
     * const CabinetSize = await prisma.cabinetSize.create({
     *   data: {
     *     // ... data to create a CabinetSize
     *   }
     * })
     * 
     */
    create<T extends CabinetSizeCreateArgs>(args: SelectSubset<T, CabinetSizeCreateArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetSizes.
     * @param {CabinetSizeCreateManyArgs} args - Arguments to create many CabinetSizes.
     * @example
     * // Create many CabinetSizes
     * const cabinetSize = await prisma.cabinetSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetSizeCreateManyArgs>(args?: SelectSubset<T, CabinetSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetSizes and returns the data saved in the database.
     * @param {CabinetSizeCreateManyAndReturnArgs} args - Arguments to create many CabinetSizes.
     * @example
     * // Create many CabinetSizes
     * const cabinetSize = await prisma.cabinetSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetSizes and only return the `id`
     * const cabinetSizeWithIdOnly = await prisma.cabinetSize.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetSize.
     * @param {CabinetSizeDeleteArgs} args - Arguments to delete one CabinetSize.
     * @example
     * // Delete one CabinetSize
     * const CabinetSize = await prisma.cabinetSize.delete({
     *   where: {
     *     // ... filter to delete one CabinetSize
     *   }
     * })
     * 
     */
    delete<T extends CabinetSizeDeleteArgs>(args: SelectSubset<T, CabinetSizeDeleteArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetSize.
     * @param {CabinetSizeUpdateArgs} args - Arguments to update one CabinetSize.
     * @example
     * // Update one CabinetSize
     * const cabinetSize = await prisma.cabinetSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetSizeUpdateArgs>(args: SelectSubset<T, CabinetSizeUpdateArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetSizes.
     * @param {CabinetSizeDeleteManyArgs} args - Arguments to filter CabinetSizes to delete.
     * @example
     * // Delete a few CabinetSizes
     * const { count } = await prisma.cabinetSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetSizeDeleteManyArgs>(args?: SelectSubset<T, CabinetSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetSizes
     * const cabinetSize = await prisma.cabinetSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetSizeUpdateManyArgs>(args: SelectSubset<T, CabinetSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSizes and returns the data updated in the database.
     * @param {CabinetSizeUpdateManyAndReturnArgs} args - Arguments to update many CabinetSizes.
     * @example
     * // Update many CabinetSizes
     * const cabinetSize = await prisma.cabinetSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetSizes and only return the `id`
     * const cabinetSizeWithIdOnly = await prisma.cabinetSize.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetSize.
     * @param {CabinetSizeUpsertArgs} args - Arguments to update or create a CabinetSize.
     * @example
     * // Update or create a CabinetSize
     * const cabinetSize = await prisma.cabinetSize.upsert({
     *   create: {
     *     // ... data to create a CabinetSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetSize we want to update
     *   }
     * })
     */
    upsert<T extends CabinetSizeUpsertArgs>(args: SelectSubset<T, CabinetSizeUpsertArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeCountArgs} args - Arguments to filter CabinetSizes to count.
     * @example
     * // Count the number of CabinetSizes
     * const count = await prisma.cabinetSize.count({
     *   where: {
     *     // ... the filter for the CabinetSizes we want to count
     *   }
     * })
    **/
    count<T extends CabinetSizeCountArgs>(
      args?: Subset<T, CabinetSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetSizeAggregateArgs>(args: Subset<T, CabinetSizeAggregateArgs>): Prisma.PrismaPromise<GetCabinetSizeAggregateType<T>>

    /**
     * Group by CabinetSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetSizeGroupByArgs['orderBy'] }
        : { orderBy?: CabinetSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetSize model
   */
  readonly fields: CabinetSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinets<T extends CabinetSize$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, CabinetSize$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moduleSizes<T extends CabinetSize$moduleSizesArgs<ExtArgs> = {}>(args?: Subset<T, CabinetSize$moduleSizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetSize model
   */
  interface CabinetSizeFieldRefs {
    readonly id: FieldRef<"CabinetSize", 'Int'>
    readonly code: FieldRef<"CabinetSize", 'String'>
    readonly size: FieldRef<"CabinetSize", 'String'>
    readonly width: FieldRef<"CabinetSize", 'Int'>
    readonly height: FieldRef<"CabinetSize", 'Int'>
    readonly active: FieldRef<"CabinetSize", 'Boolean'>
    readonly createdAt: FieldRef<"CabinetSize", 'DateTime'>
    readonly updatedAt: FieldRef<"CabinetSize", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CabinetSize findUnique
   */
  export type CabinetSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSize to fetch.
     */
    where: CabinetSizeWhereUniqueInput
  }

  /**
   * CabinetSize findUniqueOrThrow
   */
  export type CabinetSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSize to fetch.
     */
    where: CabinetSizeWhereUniqueInput
  }

  /**
   * CabinetSize findFirst
   */
  export type CabinetSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSize to fetch.
     */
    where?: CabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizes to fetch.
     */
    orderBy?: CabinetSizeOrderByWithRelationInput | CabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSizes.
     */
    cursor?: CabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSizes.
     */
    distinct?: CabinetSizeScalarFieldEnum | CabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetSize findFirstOrThrow
   */
  export type CabinetSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSize to fetch.
     */
    where?: CabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizes to fetch.
     */
    orderBy?: CabinetSizeOrderByWithRelationInput | CabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSizes.
     */
    cursor?: CabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSizes.
     */
    distinct?: CabinetSizeScalarFieldEnum | CabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetSize findMany
   */
  export type CabinetSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizes to fetch.
     */
    where?: CabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizes to fetch.
     */
    orderBy?: CabinetSizeOrderByWithRelationInput | CabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetSizes.
     */
    cursor?: CabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizes.
     */
    skip?: number
    distinct?: CabinetSizeScalarFieldEnum | CabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetSize create
   */
  export type CabinetSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetSize.
     */
    data: XOR<CabinetSizeCreateInput, CabinetSizeUncheckedCreateInput>
  }

  /**
   * CabinetSize createMany
   */
  export type CabinetSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetSizes.
     */
    data: CabinetSizeCreateManyInput | CabinetSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetSize createManyAndReturn
   */
  export type CabinetSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetSizes.
     */
    data: CabinetSizeCreateManyInput | CabinetSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetSize update
   */
  export type CabinetSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetSize.
     */
    data: XOR<CabinetSizeUpdateInput, CabinetSizeUncheckedUpdateInput>
    /**
     * Choose, which CabinetSize to update.
     */
    where: CabinetSizeWhereUniqueInput
  }

  /**
   * CabinetSize updateMany
   */
  export type CabinetSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetSizes.
     */
    data: XOR<CabinetSizeUpdateManyMutationInput, CabinetSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSizes to update
     */
    where?: CabinetSizeWhereInput
    /**
     * Limit how many CabinetSizes to update.
     */
    limit?: number
  }

  /**
   * CabinetSize updateManyAndReturn
   */
  export type CabinetSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * The data used to update CabinetSizes.
     */
    data: XOR<CabinetSizeUpdateManyMutationInput, CabinetSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSizes to update
     */
    where?: CabinetSizeWhereInput
    /**
     * Limit how many CabinetSizes to update.
     */
    limit?: number
  }

  /**
   * CabinetSize upsert
   */
  export type CabinetSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetSize to update in case it exists.
     */
    where: CabinetSizeWhereUniqueInput
    /**
     * In case the CabinetSize found by the `where` argument doesn't exist, create a new CabinetSize with this data.
     */
    create: XOR<CabinetSizeCreateInput, CabinetSizeUncheckedCreateInput>
    /**
     * In case the CabinetSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetSizeUpdateInput, CabinetSizeUncheckedUpdateInput>
  }

  /**
   * CabinetSize delete
   */
  export type CabinetSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
    /**
     * Filter which CabinetSize to delete.
     */
    where: CabinetSizeWhereUniqueInput
  }

  /**
   * CabinetSize deleteMany
   */
  export type CabinetSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSizes to delete
     */
    where?: CabinetSizeWhereInput
    /**
     * Limit how many CabinetSizes to delete.
     */
    limit?: number
  }

  /**
   * CabinetSize.cabinets
   */
  export type CabinetSize$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    where?: CabinetCabinetSizeWhereInput
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    cursor?: CabinetCabinetSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetCabinetSizeScalarFieldEnum | CabinetCabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetSize.moduleSizes
   */
  export type CabinetSize$moduleSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    where?: CabinetSizeModuleSizeWhereInput
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSizeModuleSizeScalarFieldEnum | CabinetSizeModuleSizeScalarFieldEnum[]
  }

  /**
   * CabinetSize without action
   */
  export type CabinetSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSize
     */
    select?: CabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSize
     */
    omit?: CabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ItemCategorySumAggregateInputType = {
    id?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subcategories?: boolean | ItemCategory$subcategoriesArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    cabinets?: boolean | ItemCategory$cabinetsArgs<ExtArgs>
    modules?: boolean | ItemCategory$modulesArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["itemCategory"]>
  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategories?: boolean | ItemCategory$subcategoriesArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    cabinets?: boolean | ItemCategory$cabinetsArgs<ExtArgs>
    modules?: boolean | ItemCategory$modulesArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      subcategories: Prisma.$ItemCategorySubcategoryPayload<ExtArgs>[]
      items: Prisma.$ItemCategoryRelationPayload<ExtArgs>[]
      cabinets: Prisma.$CabinetCategoryPayload<ExtArgs>[]
      modules: Prisma.$ModuleCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategories and returns the data saved in the database.
     * @param {ItemCategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories and returns the data updated in the database.
     * @param {ItemCategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemCategories.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subcategories<T extends ItemCategory$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends ItemCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinets<T extends ItemCategory$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends ItemCategory$modulesArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */
  interface ItemCategoryFieldRefs {
    readonly id: FieldRef<"ItemCategory", 'Int'>
    readonly code: FieldRef<"ItemCategory", 'String'>
    readonly name: FieldRef<"ItemCategory", 'String'>
    readonly active: FieldRef<"ItemCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ItemCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory createManyAndReturn
   */
  export type ItemCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
  }

  /**
   * ItemCategory updateManyAndReturn
   */
  export type ItemCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to delete.
     */
    limit?: number
  }

  /**
   * ItemCategory.subcategories
   */
  export type ItemCategory$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    where?: ItemCategorySubcategoryWhereInput
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategorySubcategoryScalarFieldEnum | ItemCategorySubcategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory.items
   */
  export type ItemCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    where?: ItemCategoryRelationWhereInput
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    cursor?: ItemCategoryRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategoryRelationScalarFieldEnum | ItemCategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemCategory.cabinets
   */
  export type ItemCategory$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    where?: CabinetCategoryWhereInput
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    cursor?: CabinetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetCategoryScalarFieldEnum | CabinetCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory.modules
   */
  export type ItemCategory$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    where?: ModuleCategoryWhereInput
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    cursor?: ModuleCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleCategoryScalarFieldEnum | ModuleCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ItemSubcategory
   */

  export type AggregateItemSubcategory = {
    _count: ItemSubcategoryCountAggregateOutputType | null
    _avg: ItemSubcategoryAvgAggregateOutputType | null
    _sum: ItemSubcategorySumAggregateOutputType | null
    _min: ItemSubcategoryMinAggregateOutputType | null
    _max: ItemSubcategoryMaxAggregateOutputType | null
  }

  export type ItemSubcategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemSubcategorySumAggregateOutputType = {
    id: number | null
  }

  export type ItemSubcategoryMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemSubcategoryMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemSubcategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemSubcategoryAvgAggregateInputType = {
    id?: true
  }

  export type ItemSubcategorySumAggregateInputType = {
    id?: true
  }

  export type ItemSubcategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemSubcategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemSubcategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemSubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSubcategory to aggregate.
     */
    where?: ItemSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategories to fetch.
     */
    orderBy?: ItemSubcategoryOrderByWithRelationInput | ItemSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemSubcategories
    **/
    _count?: true | ItemSubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemSubcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSubcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemSubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemSubcategoryMaxAggregateInputType
  }

  export type GetItemSubcategoryAggregateType<T extends ItemSubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemSubcategory[P]>
      : GetScalarType<T[P], AggregateItemSubcategory[P]>
  }




  export type ItemSubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSubcategoryWhereInput
    orderBy?: ItemSubcategoryOrderByWithAggregationInput | ItemSubcategoryOrderByWithAggregationInput[]
    by: ItemSubcategoryScalarFieldEnum[] | ItemSubcategoryScalarFieldEnum
    having?: ItemSubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemSubcategoryCountAggregateInputType | true
    _avg?: ItemSubcategoryAvgAggregateInputType
    _sum?: ItemSubcategorySumAggregateInputType
    _min?: ItemSubcategoryMinAggregateInputType
    _max?: ItemSubcategoryMaxAggregateInputType
  }

  export type ItemSubcategoryGroupByOutputType = {
    id: number
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemSubcategoryCountAggregateOutputType | null
    _avg: ItemSubcategoryAvgAggregateOutputType | null
    _sum: ItemSubcategorySumAggregateOutputType | null
    _min: ItemSubcategoryMinAggregateOutputType | null
    _max: ItemSubcategoryMaxAggregateOutputType | null
  }

  type GetItemSubcategoryGroupByPayload<T extends ItemSubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemSubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemSubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemSubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemSubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemSubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | ItemSubcategory$categoriesArgs<ExtArgs>
    items?: boolean | ItemSubcategory$itemsArgs<ExtArgs>
    cabinets?: boolean | ItemSubcategory$cabinetsArgs<ExtArgs>
    modules?: boolean | ItemSubcategory$modulesArgs<ExtArgs>
    _count?: boolean | ItemSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSubcategory"]>

  export type ItemSubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemSubcategory"]>

  export type ItemSubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemSubcategory"]>

  export type ItemSubcategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemSubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["itemSubcategory"]>
  export type ItemSubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ItemSubcategory$categoriesArgs<ExtArgs>
    items?: boolean | ItemSubcategory$itemsArgs<ExtArgs>
    cabinets?: boolean | ItemSubcategory$cabinetsArgs<ExtArgs>
    modules?: boolean | ItemSubcategory$modulesArgs<ExtArgs>
    _count?: boolean | ItemSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemSubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemSubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemSubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemSubcategory"
    objects: {
      categories: Prisma.$ItemCategorySubcategoryPayload<ExtArgs>[]
      items: Prisma.$ItemSubcategoryRelationPayload<ExtArgs>[]
      cabinets: Prisma.$CabinetSubcategoryPayload<ExtArgs>[]
      modules: Prisma.$ModuleSubcategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemSubcategory"]>
    composites: {}
  }

  type ItemSubcategoryGetPayload<S extends boolean | null | undefined | ItemSubcategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemSubcategoryPayload, S>

  type ItemSubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemSubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemSubcategoryCountAggregateInputType | true
    }

  export interface ItemSubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemSubcategory'], meta: { name: 'ItemSubcategory' } }
    /**
     * Find zero or one ItemSubcategory that matches the filter.
     * @param {ItemSubcategoryFindUniqueArgs} args - Arguments to find a ItemSubcategory
     * @example
     * // Get one ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemSubcategoryFindUniqueArgs>(args: SelectSubset<T, ItemSubcategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemSubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemSubcategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemSubcategory
     * @example
     * // Get one ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemSubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemSubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryFindFirstArgs} args - Arguments to find a ItemSubcategory
     * @example
     * // Get one ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemSubcategoryFindFirstArgs>(args?: SelectSubset<T, ItemSubcategoryFindFirstArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryFindFirstOrThrowArgs} args - Arguments to find a ItemSubcategory
     * @example
     * // Get one ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemSubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemSubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemSubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemSubcategories
     * const itemSubcategories = await prisma.itemSubcategory.findMany()
     * 
     * // Get first 10 ItemSubcategories
     * const itemSubcategories = await prisma.itemSubcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemSubcategoryWithIdOnly = await prisma.itemSubcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemSubcategoryFindManyArgs>(args?: SelectSubset<T, ItemSubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemSubcategory.
     * @param {ItemSubcategoryCreateArgs} args - Arguments to create a ItemSubcategory.
     * @example
     * // Create one ItemSubcategory
     * const ItemSubcategory = await prisma.itemSubcategory.create({
     *   data: {
     *     // ... data to create a ItemSubcategory
     *   }
     * })
     * 
     */
    create<T extends ItemSubcategoryCreateArgs>(args: SelectSubset<T, ItemSubcategoryCreateArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemSubcategories.
     * @param {ItemSubcategoryCreateManyArgs} args - Arguments to create many ItemSubcategories.
     * @example
     * // Create many ItemSubcategories
     * const itemSubcategory = await prisma.itemSubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemSubcategoryCreateManyArgs>(args?: SelectSubset<T, ItemSubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemSubcategories and returns the data saved in the database.
     * @param {ItemSubcategoryCreateManyAndReturnArgs} args - Arguments to create many ItemSubcategories.
     * @example
     * // Create many ItemSubcategories
     * const itemSubcategory = await prisma.itemSubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemSubcategories and only return the `id`
     * const itemSubcategoryWithIdOnly = await prisma.itemSubcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemSubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemSubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemSubcategory.
     * @param {ItemSubcategoryDeleteArgs} args - Arguments to delete one ItemSubcategory.
     * @example
     * // Delete one ItemSubcategory
     * const ItemSubcategory = await prisma.itemSubcategory.delete({
     *   where: {
     *     // ... filter to delete one ItemSubcategory
     *   }
     * })
     * 
     */
    delete<T extends ItemSubcategoryDeleteArgs>(args: SelectSubset<T, ItemSubcategoryDeleteArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemSubcategory.
     * @param {ItemSubcategoryUpdateArgs} args - Arguments to update one ItemSubcategory.
     * @example
     * // Update one ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemSubcategoryUpdateArgs>(args: SelectSubset<T, ItemSubcategoryUpdateArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemSubcategories.
     * @param {ItemSubcategoryDeleteManyArgs} args - Arguments to filter ItemSubcategories to delete.
     * @example
     * // Delete a few ItemSubcategories
     * const { count } = await prisma.itemSubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemSubcategoryDeleteManyArgs>(args?: SelectSubset<T, ItemSubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemSubcategories
     * const itemSubcategory = await prisma.itemSubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemSubcategoryUpdateManyArgs>(args: SelectSubset<T, ItemSubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSubcategories and returns the data updated in the database.
     * @param {ItemSubcategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemSubcategories.
     * @example
     * // Update many ItemSubcategories
     * const itemSubcategory = await prisma.itemSubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemSubcategories and only return the `id`
     * const itemSubcategoryWithIdOnly = await prisma.itemSubcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemSubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemSubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemSubcategory.
     * @param {ItemSubcategoryUpsertArgs} args - Arguments to update or create a ItemSubcategory.
     * @example
     * // Update or create a ItemSubcategory
     * const itemSubcategory = await prisma.itemSubcategory.upsert({
     *   create: {
     *     // ... data to create a ItemSubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemSubcategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemSubcategoryUpsertArgs>(args: SelectSubset<T, ItemSubcategoryUpsertArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryCountArgs} args - Arguments to filter ItemSubcategories to count.
     * @example
     * // Count the number of ItemSubcategories
     * const count = await prisma.itemSubcategory.count({
     *   where: {
     *     // ... the filter for the ItemSubcategories we want to count
     *   }
     * })
    **/
    count<T extends ItemSubcategoryCountArgs>(
      args?: Subset<T, ItemSubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemSubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemSubcategoryAggregateArgs>(args: Subset<T, ItemSubcategoryAggregateArgs>): Prisma.PrismaPromise<GetItemSubcategoryAggregateType<T>>

    /**
     * Group by ItemSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemSubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemSubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemSubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemSubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemSubcategory model
   */
  readonly fields: ItemSubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemSubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemSubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends ItemSubcategory$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategory$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends ItemSubcategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinets<T extends ItemSubcategory$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategory$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends ItemSubcategory$modulesArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategory$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemSubcategory model
   */
  interface ItemSubcategoryFieldRefs {
    readonly id: FieldRef<"ItemSubcategory", 'Int'>
    readonly code: FieldRef<"ItemSubcategory", 'String'>
    readonly name: FieldRef<"ItemSubcategory", 'String'>
    readonly active: FieldRef<"ItemSubcategory", 'Boolean'>
    readonly createdAt: FieldRef<"ItemSubcategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemSubcategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemSubcategory findUnique
   */
  export type ItemSubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategory to fetch.
     */
    where: ItemSubcategoryWhereUniqueInput
  }

  /**
   * ItemSubcategory findUniqueOrThrow
   */
  export type ItemSubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategory to fetch.
     */
    where: ItemSubcategoryWhereUniqueInput
  }

  /**
   * ItemSubcategory findFirst
   */
  export type ItemSubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategory to fetch.
     */
    where?: ItemSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategories to fetch.
     */
    orderBy?: ItemSubcategoryOrderByWithRelationInput | ItemSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSubcategories.
     */
    cursor?: ItemSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSubcategories.
     */
    distinct?: ItemSubcategoryScalarFieldEnum | ItemSubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory findFirstOrThrow
   */
  export type ItemSubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategory to fetch.
     */
    where?: ItemSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategories to fetch.
     */
    orderBy?: ItemSubcategoryOrderByWithRelationInput | ItemSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSubcategories.
     */
    cursor?: ItemSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSubcategories.
     */
    distinct?: ItemSubcategoryScalarFieldEnum | ItemSubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory findMany
   */
  export type ItemSubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategories to fetch.
     */
    where?: ItemSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategories to fetch.
     */
    orderBy?: ItemSubcategoryOrderByWithRelationInput | ItemSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemSubcategories.
     */
    cursor?: ItemSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategories.
     */
    skip?: number
    distinct?: ItemSubcategoryScalarFieldEnum | ItemSubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory create
   */
  export type ItemSubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemSubcategory.
     */
    data: XOR<ItemSubcategoryCreateInput, ItemSubcategoryUncheckedCreateInput>
  }

  /**
   * ItemSubcategory createMany
   */
  export type ItemSubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemSubcategories.
     */
    data: ItemSubcategoryCreateManyInput | ItemSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemSubcategory createManyAndReturn
   */
  export type ItemSubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemSubcategories.
     */
    data: ItemSubcategoryCreateManyInput | ItemSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemSubcategory update
   */
  export type ItemSubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemSubcategory.
     */
    data: XOR<ItemSubcategoryUpdateInput, ItemSubcategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemSubcategory to update.
     */
    where: ItemSubcategoryWhereUniqueInput
  }

  /**
   * ItemSubcategory updateMany
   */
  export type ItemSubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemSubcategories.
     */
    data: XOR<ItemSubcategoryUpdateManyMutationInput, ItemSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemSubcategories to update
     */
    where?: ItemSubcategoryWhereInput
    /**
     * Limit how many ItemSubcategories to update.
     */
    limit?: number
  }

  /**
   * ItemSubcategory updateManyAndReturn
   */
  export type ItemSubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemSubcategories.
     */
    data: XOR<ItemSubcategoryUpdateManyMutationInput, ItemSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemSubcategories to update
     */
    where?: ItemSubcategoryWhereInput
    /**
     * Limit how many ItemSubcategories to update.
     */
    limit?: number
  }

  /**
   * ItemSubcategory upsert
   */
  export type ItemSubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemSubcategory to update in case it exists.
     */
    where: ItemSubcategoryWhereUniqueInput
    /**
     * In case the ItemSubcategory found by the `where` argument doesn't exist, create a new ItemSubcategory with this data.
     */
    create: XOR<ItemSubcategoryCreateInput, ItemSubcategoryUncheckedCreateInput>
    /**
     * In case the ItemSubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemSubcategoryUpdateInput, ItemSubcategoryUncheckedUpdateInput>
  }

  /**
   * ItemSubcategory delete
   */
  export type ItemSubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemSubcategory to delete.
     */
    where: ItemSubcategoryWhereUniqueInput
  }

  /**
   * ItemSubcategory deleteMany
   */
  export type ItemSubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSubcategories to delete
     */
    where?: ItemSubcategoryWhereInput
    /**
     * Limit how many ItemSubcategories to delete.
     */
    limit?: number
  }

  /**
   * ItemSubcategory.categories
   */
  export type ItemSubcategory$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    where?: ItemCategorySubcategoryWhereInput
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategorySubcategoryScalarFieldEnum | ItemCategorySubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory.items
   */
  export type ItemSubcategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    where?: ItemSubcategoryRelationWhereInput
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSubcategoryRelationScalarFieldEnum | ItemSubcategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemSubcategory.cabinets
   */
  export type ItemSubcategory$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    where?: CabinetSubcategoryWhereInput
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    cursor?: CabinetSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSubcategoryScalarFieldEnum | CabinetSubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory.modules
   */
  export type ItemSubcategory$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    where?: ModuleSubcategoryWhereInput
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    cursor?: ModuleSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleSubcategoryScalarFieldEnum | ModuleSubcategoryScalarFieldEnum[]
  }

  /**
   * ItemSubcategory without action
   */
  export type ItemSubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategory
     */
    select?: ItemSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategory
     */
    omit?: ItemSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model Cabinet
   */

  export type AggregateCabinet = {
    _count: CabinetCountAggregateOutputType | null
    _avg: CabinetAvgAggregateOutputType | null
    _sum: CabinetSumAggregateOutputType | null
    _min: CabinetMinAggregateOutputType | null
    _max: CabinetMaxAggregateOutputType | null
  }

  export type CabinetAvgAggregateOutputType = {
    id: number | null
  }

  export type CabinetSumAggregateOutputType = {
    id: number | null
  }

  export type CabinetMinAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetMaxAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetCountAggregateOutputType = {
    id: number
    code: number
    sku: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CabinetAvgAggregateInputType = {
    id?: true
  }

  export type CabinetSumAggregateInputType = {
    id?: true
  }

  export type CabinetMinAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetMaxAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetCountAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CabinetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cabinet to aggregate.
     */
    where?: CabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cabinets to fetch.
     */
    orderBy?: CabinetOrderByWithRelationInput | CabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cabinets
    **/
    _count?: true | CabinetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CabinetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CabinetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetMaxAggregateInputType
  }

  export type GetCabinetAggregateType<T extends CabinetAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinet[P]>
      : GetScalarType<T[P], AggregateCabinet[P]>
  }




  export type CabinetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetWhereInput
    orderBy?: CabinetOrderByWithAggregationInput | CabinetOrderByWithAggregationInput[]
    by: CabinetScalarFieldEnum[] | CabinetScalarFieldEnum
    having?: CabinetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetCountAggregateInputType | true
    _avg?: CabinetAvgAggregateInputType
    _sum?: CabinetSumAggregateInputType
    _min?: CabinetMinAggregateInputType
    _max?: CabinetMaxAggregateInputType
  }

  export type CabinetGroupByOutputType = {
    id: number
    code: string
    sku: string | null
    name: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CabinetCountAggregateOutputType | null
    _avg: CabinetAvgAggregateOutputType | null
    _sum: CabinetSumAggregateOutputType | null
    _min: CabinetMinAggregateOutputType | null
    _max: CabinetMaxAggregateOutputType | null
  }

  type GetCabinetGroupByPayload<T extends CabinetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetGroupByOutputType[P]>
        }
      >
    >


  export type CabinetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Cabinet$categoriesArgs<ExtArgs>
    subcategories?: boolean | Cabinet$subcategoriesArgs<ExtArgs>
    locations?: boolean | Cabinet$locationsArgs<ExtArgs>
    placements?: boolean | Cabinet$placementsArgs<ExtArgs>
    materials?: boolean | Cabinet$materialsArgs<ExtArgs>
    sizes?: boolean | Cabinet$sizesArgs<ExtArgs>
    pitches?: boolean | Cabinet$pitchesArgs<ExtArgs>
    manufacturers?: boolean | Cabinet$manufacturersArgs<ExtArgs>
    suppliers?: boolean | Cabinet$suppliersArgs<ExtArgs>
    items?: boolean | Cabinet$itemsArgs<ExtArgs>
    prices?: boolean | Cabinet$pricesArgs<ExtArgs>
    _count?: boolean | CabinetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinet"]>

  export type CabinetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cabinet"]>

  export type CabinetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cabinet"]>

  export type CabinetSelectScalar = {
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CabinetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "sku" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["cabinet"]>
  export type CabinetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Cabinet$categoriesArgs<ExtArgs>
    subcategories?: boolean | Cabinet$subcategoriesArgs<ExtArgs>
    locations?: boolean | Cabinet$locationsArgs<ExtArgs>
    placements?: boolean | Cabinet$placementsArgs<ExtArgs>
    materials?: boolean | Cabinet$materialsArgs<ExtArgs>
    sizes?: boolean | Cabinet$sizesArgs<ExtArgs>
    pitches?: boolean | Cabinet$pitchesArgs<ExtArgs>
    manufacturers?: boolean | Cabinet$manufacturersArgs<ExtArgs>
    suppliers?: boolean | Cabinet$suppliersArgs<ExtArgs>
    items?: boolean | Cabinet$itemsArgs<ExtArgs>
    prices?: boolean | Cabinet$pricesArgs<ExtArgs>
    _count?: boolean | CabinetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CabinetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CabinetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CabinetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cabinet"
    objects: {
      categories: Prisma.$CabinetCategoryPayload<ExtArgs>[]
      subcategories: Prisma.$CabinetSubcategoryPayload<ExtArgs>[]
      locations: Prisma.$CabinetLocationPayload<ExtArgs>[]
      placements: Prisma.$CabinetPlacementPayload<ExtArgs>[]
      materials: Prisma.$CabinetMaterialPayload<ExtArgs>[]
      sizes: Prisma.$CabinetCabinetSizePayload<ExtArgs>[]
      pitches: Prisma.$CabinetPitchPayload<ExtArgs>[]
      manufacturers: Prisma.$CabinetManufacturerPayload<ExtArgs>[]
      suppliers: Prisma.$CabinetSupplierPayload<ExtArgs>[]
      items: Prisma.$CabinetItemComponentPayload<ExtArgs>[]
      prices: Prisma.$CabinetPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      sku: string | null
      name: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cabinet"]>
    composites: {}
  }

  type CabinetGetPayload<S extends boolean | null | undefined | CabinetDefaultArgs> = $Result.GetResult<Prisma.$CabinetPayload, S>

  type CabinetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetCountAggregateInputType | true
    }

  export interface CabinetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cabinet'], meta: { name: 'Cabinet' } }
    /**
     * Find zero or one Cabinet that matches the filter.
     * @param {CabinetFindUniqueArgs} args - Arguments to find a Cabinet
     * @example
     * // Get one Cabinet
     * const cabinet = await prisma.cabinet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetFindUniqueArgs>(args: SelectSubset<T, CabinetFindUniqueArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cabinet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetFindUniqueOrThrowArgs} args - Arguments to find a Cabinet
     * @example
     * // Get one Cabinet
     * const cabinet = await prisma.cabinet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cabinet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetFindFirstArgs} args - Arguments to find a Cabinet
     * @example
     * // Get one Cabinet
     * const cabinet = await prisma.cabinet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetFindFirstArgs>(args?: SelectSubset<T, CabinetFindFirstArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cabinet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetFindFirstOrThrowArgs} args - Arguments to find a Cabinet
     * @example
     * // Get one Cabinet
     * const cabinet = await prisma.cabinet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cabinets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cabinets
     * const cabinets = await prisma.cabinet.findMany()
     * 
     * // Get first 10 Cabinets
     * const cabinets = await prisma.cabinet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cabinetWithIdOnly = await prisma.cabinet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CabinetFindManyArgs>(args?: SelectSubset<T, CabinetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cabinet.
     * @param {CabinetCreateArgs} args - Arguments to create a Cabinet.
     * @example
     * // Create one Cabinet
     * const Cabinet = await prisma.cabinet.create({
     *   data: {
     *     // ... data to create a Cabinet
     *   }
     * })
     * 
     */
    create<T extends CabinetCreateArgs>(args: SelectSubset<T, CabinetCreateArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cabinets.
     * @param {CabinetCreateManyArgs} args - Arguments to create many Cabinets.
     * @example
     * // Create many Cabinets
     * const cabinet = await prisma.cabinet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetCreateManyArgs>(args?: SelectSubset<T, CabinetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cabinets and returns the data saved in the database.
     * @param {CabinetCreateManyAndReturnArgs} args - Arguments to create many Cabinets.
     * @example
     * // Create many Cabinets
     * const cabinet = await prisma.cabinet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cabinets and only return the `id`
     * const cabinetWithIdOnly = await prisma.cabinet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cabinet.
     * @param {CabinetDeleteArgs} args - Arguments to delete one Cabinet.
     * @example
     * // Delete one Cabinet
     * const Cabinet = await prisma.cabinet.delete({
     *   where: {
     *     // ... filter to delete one Cabinet
     *   }
     * })
     * 
     */
    delete<T extends CabinetDeleteArgs>(args: SelectSubset<T, CabinetDeleteArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cabinet.
     * @param {CabinetUpdateArgs} args - Arguments to update one Cabinet.
     * @example
     * // Update one Cabinet
     * const cabinet = await prisma.cabinet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetUpdateArgs>(args: SelectSubset<T, CabinetUpdateArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cabinets.
     * @param {CabinetDeleteManyArgs} args - Arguments to filter Cabinets to delete.
     * @example
     * // Delete a few Cabinets
     * const { count } = await prisma.cabinet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetDeleteManyArgs>(args?: SelectSubset<T, CabinetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cabinets
     * const cabinet = await prisma.cabinet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetUpdateManyArgs>(args: SelectSubset<T, CabinetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cabinets and returns the data updated in the database.
     * @param {CabinetUpdateManyAndReturnArgs} args - Arguments to update many Cabinets.
     * @example
     * // Update many Cabinets
     * const cabinet = await prisma.cabinet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cabinets and only return the `id`
     * const cabinetWithIdOnly = await prisma.cabinet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cabinet.
     * @param {CabinetUpsertArgs} args - Arguments to update or create a Cabinet.
     * @example
     * // Update or create a Cabinet
     * const cabinet = await prisma.cabinet.upsert({
     *   create: {
     *     // ... data to create a Cabinet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cabinet we want to update
     *   }
     * })
     */
    upsert<T extends CabinetUpsertArgs>(args: SelectSubset<T, CabinetUpsertArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cabinets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCountArgs} args - Arguments to filter Cabinets to count.
     * @example
     * // Count the number of Cabinets
     * const count = await prisma.cabinet.count({
     *   where: {
     *     // ... the filter for the Cabinets we want to count
     *   }
     * })
    **/
    count<T extends CabinetCountArgs>(
      args?: Subset<T, CabinetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetAggregateArgs>(args: Subset<T, CabinetAggregateArgs>): Prisma.PrismaPromise<GetCabinetAggregateType<T>>

    /**
     * Group by Cabinet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetGroupByArgs['orderBy'] }
        : { orderBy?: CabinetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cabinet model
   */
  readonly fields: CabinetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cabinet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Cabinet$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Cabinet$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Cabinet$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placements<T extends Cabinet$placementsArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$placementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends Cabinet$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sizes<T extends Cabinet$sizesArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$sizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pitches<T extends Cabinet$pitchesArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$pitchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manufacturers<T extends Cabinet$manufacturersArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$manufacturersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Cabinet$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Cabinet$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends Cabinet$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Cabinet$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cabinet model
   */
  interface CabinetFieldRefs {
    readonly id: FieldRef<"Cabinet", 'Int'>
    readonly code: FieldRef<"Cabinet", 'String'>
    readonly sku: FieldRef<"Cabinet", 'String'>
    readonly name: FieldRef<"Cabinet", 'String'>
    readonly active: FieldRef<"Cabinet", 'Boolean'>
    readonly createdAt: FieldRef<"Cabinet", 'DateTime'>
    readonly updatedAt: FieldRef<"Cabinet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cabinet findUnique
   */
  export type CabinetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter, which Cabinet to fetch.
     */
    where: CabinetWhereUniqueInput
  }

  /**
   * Cabinet findUniqueOrThrow
   */
  export type CabinetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter, which Cabinet to fetch.
     */
    where: CabinetWhereUniqueInput
  }

  /**
   * Cabinet findFirst
   */
  export type CabinetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter, which Cabinet to fetch.
     */
    where?: CabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cabinets to fetch.
     */
    orderBy?: CabinetOrderByWithRelationInput | CabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cabinets.
     */
    cursor?: CabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cabinets.
     */
    distinct?: CabinetScalarFieldEnum | CabinetScalarFieldEnum[]
  }

  /**
   * Cabinet findFirstOrThrow
   */
  export type CabinetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter, which Cabinet to fetch.
     */
    where?: CabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cabinets to fetch.
     */
    orderBy?: CabinetOrderByWithRelationInput | CabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cabinets.
     */
    cursor?: CabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cabinets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cabinets.
     */
    distinct?: CabinetScalarFieldEnum | CabinetScalarFieldEnum[]
  }

  /**
   * Cabinet findMany
   */
  export type CabinetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter, which Cabinets to fetch.
     */
    where?: CabinetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cabinets to fetch.
     */
    orderBy?: CabinetOrderByWithRelationInput | CabinetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cabinets.
     */
    cursor?: CabinetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cabinets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cabinets.
     */
    skip?: number
    distinct?: CabinetScalarFieldEnum | CabinetScalarFieldEnum[]
  }

  /**
   * Cabinet create
   */
  export type CabinetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * The data needed to create a Cabinet.
     */
    data: XOR<CabinetCreateInput, CabinetUncheckedCreateInput>
  }

  /**
   * Cabinet createMany
   */
  export type CabinetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cabinets.
     */
    data: CabinetCreateManyInput | CabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cabinet createManyAndReturn
   */
  export type CabinetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * The data used to create many Cabinets.
     */
    data: CabinetCreateManyInput | CabinetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cabinet update
   */
  export type CabinetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * The data needed to update a Cabinet.
     */
    data: XOR<CabinetUpdateInput, CabinetUncheckedUpdateInput>
    /**
     * Choose, which Cabinet to update.
     */
    where: CabinetWhereUniqueInput
  }

  /**
   * Cabinet updateMany
   */
  export type CabinetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cabinets.
     */
    data: XOR<CabinetUpdateManyMutationInput, CabinetUncheckedUpdateManyInput>
    /**
     * Filter which Cabinets to update
     */
    where?: CabinetWhereInput
    /**
     * Limit how many Cabinets to update.
     */
    limit?: number
  }

  /**
   * Cabinet updateManyAndReturn
   */
  export type CabinetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * The data used to update Cabinets.
     */
    data: XOR<CabinetUpdateManyMutationInput, CabinetUncheckedUpdateManyInput>
    /**
     * Filter which Cabinets to update
     */
    where?: CabinetWhereInput
    /**
     * Limit how many Cabinets to update.
     */
    limit?: number
  }

  /**
   * Cabinet upsert
   */
  export type CabinetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * The filter to search for the Cabinet to update in case it exists.
     */
    where: CabinetWhereUniqueInput
    /**
     * In case the Cabinet found by the `where` argument doesn't exist, create a new Cabinet with this data.
     */
    create: XOR<CabinetCreateInput, CabinetUncheckedCreateInput>
    /**
     * In case the Cabinet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetUpdateInput, CabinetUncheckedUpdateInput>
  }

  /**
   * Cabinet delete
   */
  export type CabinetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
    /**
     * Filter which Cabinet to delete.
     */
    where: CabinetWhereUniqueInput
  }

  /**
   * Cabinet deleteMany
   */
  export type CabinetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cabinets to delete
     */
    where?: CabinetWhereInput
    /**
     * Limit how many Cabinets to delete.
     */
    limit?: number
  }

  /**
   * Cabinet.categories
   */
  export type Cabinet$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    where?: CabinetCategoryWhereInput
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    cursor?: CabinetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetCategoryScalarFieldEnum | CabinetCategoryScalarFieldEnum[]
  }

  /**
   * Cabinet.subcategories
   */
  export type Cabinet$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    where?: CabinetSubcategoryWhereInput
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    cursor?: CabinetSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSubcategoryScalarFieldEnum | CabinetSubcategoryScalarFieldEnum[]
  }

  /**
   * Cabinet.locations
   */
  export type Cabinet$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    where?: CabinetLocationWhereInput
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    cursor?: CabinetLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetLocationScalarFieldEnum | CabinetLocationScalarFieldEnum[]
  }

  /**
   * Cabinet.placements
   */
  export type Cabinet$placementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    where?: CabinetPlacementWhereInput
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    cursor?: CabinetPlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetPlacementScalarFieldEnum | CabinetPlacementScalarFieldEnum[]
  }

  /**
   * Cabinet.materials
   */
  export type Cabinet$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    where?: CabinetMaterialWhereInput
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    cursor?: CabinetMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetMaterialScalarFieldEnum | CabinetMaterialScalarFieldEnum[]
  }

  /**
   * Cabinet.sizes
   */
  export type Cabinet$sizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    where?: CabinetCabinetSizeWhereInput
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    cursor?: CabinetCabinetSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetCabinetSizeScalarFieldEnum | CabinetCabinetSizeScalarFieldEnum[]
  }

  /**
   * Cabinet.pitches
   */
  export type Cabinet$pitchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    where?: CabinetPitchWhereInput
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    cursor?: CabinetPitchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetPitchScalarFieldEnum | CabinetPitchScalarFieldEnum[]
  }

  /**
   * Cabinet.manufacturers
   */
  export type Cabinet$manufacturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    where?: CabinetManufacturerWhereInput
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    cursor?: CabinetManufacturerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetManufacturerScalarFieldEnum | CabinetManufacturerScalarFieldEnum[]
  }

  /**
   * Cabinet.suppliers
   */
  export type Cabinet$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    where?: CabinetSupplierWhereInput
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    cursor?: CabinetSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetSupplierScalarFieldEnum | CabinetSupplierScalarFieldEnum[]
  }

  /**
   * Cabinet.items
   */
  export type Cabinet$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    where?: CabinetItemComponentWhereInput
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    cursor?: CabinetItemComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetItemComponentScalarFieldEnum | CabinetItemComponentScalarFieldEnum[]
  }

  /**
   * Cabinet.prices
   */
  export type Cabinet$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    where?: CabinetPriceWhereInput
    orderBy?: CabinetPriceOrderByWithRelationInput | CabinetPriceOrderByWithRelationInput[]
    cursor?: CabinetPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetPriceScalarFieldEnum | CabinetPriceScalarFieldEnum[]
  }

  /**
   * Cabinet without action
   */
  export type CabinetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cabinet
     */
    select?: CabinetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cabinet
     */
    omit?: CabinetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    id: number | null
  }

  export type ModuleSumAggregateOutputType = {
    id: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    moduleOption: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    moduleOption: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    code: number
    sku: number
    name: number
    moduleOption: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    id?: true
  }

  export type ModuleSumAggregateInputType = {
    id?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    moduleOption?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    moduleOption?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    moduleOption?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: number
    code: string
    sku: string | null
    name: string | null
    moduleOption: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    moduleOption?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Module$categoriesArgs<ExtArgs>
    subcategories?: boolean | Module$subcategoriesArgs<ExtArgs>
    locations?: boolean | Module$locationsArgs<ExtArgs>
    refreshRates?: boolean | Module$refreshRatesArgs<ExtArgs>
    brightnesses?: boolean | Module$brightnessesArgs<ExtArgs>
    sizes?: boolean | Module$sizesArgs<ExtArgs>
    pitches?: boolean | Module$pitchesArgs<ExtArgs>
    manufacturers?: boolean | Module$manufacturersArgs<ExtArgs>
    items?: boolean | Module$itemsArgs<ExtArgs>
    options?: boolean | Module$optionsArgs<ExtArgs>
    prices?: boolean | Module$pricesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    moduleOption?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    moduleOption?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    moduleOption?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "sku" | "name" | "moduleOption" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Module$categoriesArgs<ExtArgs>
    subcategories?: boolean | Module$subcategoriesArgs<ExtArgs>
    locations?: boolean | Module$locationsArgs<ExtArgs>
    refreshRates?: boolean | Module$refreshRatesArgs<ExtArgs>
    brightnesses?: boolean | Module$brightnessesArgs<ExtArgs>
    sizes?: boolean | Module$sizesArgs<ExtArgs>
    pitches?: boolean | Module$pitchesArgs<ExtArgs>
    manufacturers?: boolean | Module$manufacturersArgs<ExtArgs>
    items?: boolean | Module$itemsArgs<ExtArgs>
    options?: boolean | Module$optionsArgs<ExtArgs>
    prices?: boolean | Module$pricesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      categories: Prisma.$ModuleCategoryPayload<ExtArgs>[]
      subcategories: Prisma.$ModuleSubcategoryPayload<ExtArgs>[]
      locations: Prisma.$ModuleLocationPayload<ExtArgs>[]
      refreshRates: Prisma.$ModuleRefreshRatePayload<ExtArgs>[]
      brightnesses: Prisma.$ModuleBrightnessPayload<ExtArgs>[]
      sizes: Prisma.$ModuleModuleSizePayload<ExtArgs>[]
      pitches: Prisma.$ModulePitchPayload<ExtArgs>[]
      manufacturers: Prisma.$ModuleManufacturerPayload<ExtArgs>[]
      items: Prisma.$ModuleItemComponentPayload<ExtArgs>[]
      options: Prisma.$ModuleOptionPayload<ExtArgs>[]
      prices: Prisma.$ModulePricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      sku: string | null
      name: string | null
      moduleOption: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Module$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Module$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Module$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Module$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Module$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Module$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshRates<T extends Module$refreshRatesArgs<ExtArgs> = {}>(args?: Subset<T, Module$refreshRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brightnesses<T extends Module$brightnessesArgs<ExtArgs> = {}>(args?: Subset<T, Module$brightnessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sizes<T extends Module$sizesArgs<ExtArgs> = {}>(args?: Subset<T, Module$sizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pitches<T extends Module$pitchesArgs<ExtArgs> = {}>(args?: Subset<T, Module$pitchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manufacturers<T extends Module$manufacturersArgs<ExtArgs> = {}>(args?: Subset<T, Module$manufacturersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Module$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Module$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends Module$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Module$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends Module$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Module$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'Int'>
    readonly code: FieldRef<"Module", 'String'>
    readonly sku: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly moduleOption: FieldRef<"Module", 'String'>
    readonly active: FieldRef<"Module", 'Boolean'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.categories
   */
  export type Module$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    where?: ModuleCategoryWhereInput
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    cursor?: ModuleCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleCategoryScalarFieldEnum | ModuleCategoryScalarFieldEnum[]
  }

  /**
   * Module.subcategories
   */
  export type Module$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    where?: ModuleSubcategoryWhereInput
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    cursor?: ModuleSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleSubcategoryScalarFieldEnum | ModuleSubcategoryScalarFieldEnum[]
  }

  /**
   * Module.locations
   */
  export type Module$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    where?: ModuleLocationWhereInput
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    cursor?: ModuleLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleLocationScalarFieldEnum | ModuleLocationScalarFieldEnum[]
  }

  /**
   * Module.refreshRates
   */
  export type Module$refreshRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    where?: ModuleRefreshRateWhereInput
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    cursor?: ModuleRefreshRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleRefreshRateScalarFieldEnum | ModuleRefreshRateScalarFieldEnum[]
  }

  /**
   * Module.brightnesses
   */
  export type Module$brightnessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    where?: ModuleBrightnessWhereInput
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    cursor?: ModuleBrightnessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleBrightnessScalarFieldEnum | ModuleBrightnessScalarFieldEnum[]
  }

  /**
   * Module.sizes
   */
  export type Module$sizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    where?: ModuleModuleSizeWhereInput
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    cursor?: ModuleModuleSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleModuleSizeScalarFieldEnum | ModuleModuleSizeScalarFieldEnum[]
  }

  /**
   * Module.pitches
   */
  export type Module$pitchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    where?: ModulePitchWhereInput
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    cursor?: ModulePitchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePitchScalarFieldEnum | ModulePitchScalarFieldEnum[]
  }

  /**
   * Module.manufacturers
   */
  export type Module$manufacturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    where?: ModuleManufacturerWhereInput
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    cursor?: ModuleManufacturerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleManufacturerScalarFieldEnum | ModuleManufacturerScalarFieldEnum[]
  }

  /**
   * Module.items
   */
  export type Module$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    where?: ModuleItemComponentWhereInput
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    cursor?: ModuleItemComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleItemComponentScalarFieldEnum | ModuleItemComponentScalarFieldEnum[]
  }

  /**
   * Module.options
   */
  export type Module$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    where?: ModuleOptionWhereInput
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    cursor?: ModuleOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleOptionScalarFieldEnum | ModuleOptionScalarFieldEnum[]
  }

  /**
   * Module.prices
   */
  export type Module$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    where?: ModulePriceWhereInput
    orderBy?: ModulePriceOrderByWithRelationInput | ModulePriceOrderByWithRelationInput[]
    cursor?: ModulePriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePriceScalarFieldEnum | ModulePriceScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    active: boolean | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    code: string | null
    sku: string | null
    name: string | null
    active: boolean | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    code: number
    sku: number
    name: number
    active: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    code?: true
    sku?: true
    name?: true
    active?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    code: string
    sku: string | null
    name: string
    active: boolean
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Item$categoriesArgs<ExtArgs>
    subcategories?: boolean | Item$subcategoriesArgs<ExtArgs>
    prices?: boolean | Item$pricesArgs<ExtArgs>
    suppliers?: boolean | Item$suppliersArgs<ExtArgs>
    cabinets?: boolean | Item$cabinetsArgs<ExtArgs>
    modules?: boolean | Item$modulesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    code?: boolean
    sku?: boolean
    name?: boolean
    active?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "sku" | "name" | "active" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Item$categoriesArgs<ExtArgs>
    subcategories?: boolean | Item$subcategoriesArgs<ExtArgs>
    prices?: boolean | Item$pricesArgs<ExtArgs>
    suppliers?: boolean | Item$suppliersArgs<ExtArgs>
    cabinets?: boolean | Item$cabinetsArgs<ExtArgs>
    modules?: boolean | Item$modulesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      categories: Prisma.$ItemCategoryRelationPayload<ExtArgs>[]
      subcategories: Prisma.$ItemSubcategoryRelationPayload<ExtArgs>[]
      prices: Prisma.$ItemPricePayload<ExtArgs>[]
      suppliers: Prisma.$ItemSupplierPayload<ExtArgs>[]
      cabinets: Prisma.$CabinetItemComponentPayload<ExtArgs>[]
      modules: Prisma.$ModuleItemComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      sku: string | null
      name: string
      active: boolean
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Item$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Item$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Item$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Item$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends Item$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Item$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Item$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Item$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinets<T extends Item$cabinetsArgs<ExtArgs> = {}>(args?: Subset<T, Item$cabinetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Item$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Item$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly code: FieldRef<"Item", 'String'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly active: FieldRef<"Item", 'Boolean'>
    readonly comment: FieldRef<"Item", 'String'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.categories
   */
  export type Item$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    where?: ItemCategoryRelationWhereInput
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    cursor?: ItemCategoryRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategoryRelationScalarFieldEnum | ItemCategoryRelationScalarFieldEnum[]
  }

  /**
   * Item.subcategories
   */
  export type Item$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    where?: ItemSubcategoryRelationWhereInput
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSubcategoryRelationScalarFieldEnum | ItemSubcategoryRelationScalarFieldEnum[]
  }

  /**
   * Item.prices
   */
  export type Item$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    where?: ItemPriceWhereInput
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    cursor?: ItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * Item.suppliers
   */
  export type Item$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    cursor?: ItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * Item.cabinets
   */
  export type Item$cabinetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    where?: CabinetItemComponentWhereInput
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    cursor?: CabinetItemComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetItemComponentScalarFieldEnum | CabinetItemComponentScalarFieldEnum[]
  }

  /**
   * Item.modules
   */
  export type Item$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    where?: ModuleItemComponentWhereInput
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    cursor?: ModuleItemComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleItemComponentScalarFieldEnum | ModuleItemComponentScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model ScreenTypeOption
   */

  export type AggregateScreenTypeOption = {
    _count: ScreenTypeOptionCountAggregateOutputType | null
    _min: ScreenTypeOptionMinAggregateOutputType | null
    _max: ScreenTypeOptionMaxAggregateOutputType | null
  }

  export type ScreenTypeOptionMinAggregateOutputType = {
    screenTypeCode: string | null
    optionCode: string | null
  }

  export type ScreenTypeOptionMaxAggregateOutputType = {
    screenTypeCode: string | null
    optionCode: string | null
  }

  export type ScreenTypeOptionCountAggregateOutputType = {
    screenTypeCode: number
    optionCode: number
    _all: number
  }


  export type ScreenTypeOptionMinAggregateInputType = {
    screenTypeCode?: true
    optionCode?: true
  }

  export type ScreenTypeOptionMaxAggregateInputType = {
    screenTypeCode?: true
    optionCode?: true
  }

  export type ScreenTypeOptionCountAggregateInputType = {
    screenTypeCode?: true
    optionCode?: true
    _all?: true
  }

  export type ScreenTypeOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeOption to aggregate.
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeOptions to fetch.
     */
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenTypeOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenTypeOptions
    **/
    _count?: true | ScreenTypeOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenTypeOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenTypeOptionMaxAggregateInputType
  }

  export type GetScreenTypeOptionAggregateType<T extends ScreenTypeOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenTypeOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenTypeOption[P]>
      : GetScalarType<T[P], AggregateScreenTypeOption[P]>
  }




  export type ScreenTypeOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeOptionWhereInput
    orderBy?: ScreenTypeOptionOrderByWithAggregationInput | ScreenTypeOptionOrderByWithAggregationInput[]
    by: ScreenTypeOptionScalarFieldEnum[] | ScreenTypeOptionScalarFieldEnum
    having?: ScreenTypeOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenTypeOptionCountAggregateInputType | true
    _min?: ScreenTypeOptionMinAggregateInputType
    _max?: ScreenTypeOptionMaxAggregateInputType
  }

  export type ScreenTypeOptionGroupByOutputType = {
    screenTypeCode: string
    optionCode: string
    _count: ScreenTypeOptionCountAggregateOutputType | null
    _min: ScreenTypeOptionMinAggregateOutputType | null
    _max: ScreenTypeOptionMaxAggregateOutputType | null
  }

  type GetScreenTypeOptionGroupByPayload<T extends ScreenTypeOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenTypeOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenTypeOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenTypeOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenTypeOptionGroupByOutputType[P]>
        }
      >
    >


  export type ScreenTypeOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    optionCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeOption"]>

  export type ScreenTypeOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    optionCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeOption"]>

  export type ScreenTypeOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    optionCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeOption"]>

  export type ScreenTypeOptionSelectScalar = {
    screenTypeCode?: boolean
    optionCode?: boolean
  }

  export type ScreenTypeOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"screenTypeCode" | "optionCode", ExtArgs["result"]["screenTypeOption"]>
  export type ScreenTypeOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type ScreenTypeOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type ScreenTypeOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }

  export type $ScreenTypeOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenTypeOption"
    objects: {
      screenType: Prisma.$ScreenTypePayload<ExtArgs>
      option: Prisma.$OptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      screenTypeCode: string
      optionCode: string
    }, ExtArgs["result"]["screenTypeOption"]>
    composites: {}
  }

  type ScreenTypeOptionGetPayload<S extends boolean | null | undefined | ScreenTypeOptionDefaultArgs> = $Result.GetResult<Prisma.$ScreenTypeOptionPayload, S>

  type ScreenTypeOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenTypeOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenTypeOptionCountAggregateInputType | true
    }

  export interface ScreenTypeOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenTypeOption'], meta: { name: 'ScreenTypeOption' } }
    /**
     * Find zero or one ScreenTypeOption that matches the filter.
     * @param {ScreenTypeOptionFindUniqueArgs} args - Arguments to find a ScreenTypeOption
     * @example
     * // Get one ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenTypeOptionFindUniqueArgs>(args: SelectSubset<T, ScreenTypeOptionFindUniqueArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenTypeOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenTypeOptionFindUniqueOrThrowArgs} args - Arguments to find a ScreenTypeOption
     * @example
     * // Get one ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenTypeOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenTypeOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionFindFirstArgs} args - Arguments to find a ScreenTypeOption
     * @example
     * // Get one ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenTypeOptionFindFirstArgs>(args?: SelectSubset<T, ScreenTypeOptionFindFirstArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionFindFirstOrThrowArgs} args - Arguments to find a ScreenTypeOption
     * @example
     * // Get one ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenTypeOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenTypeOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenTypeOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenTypeOptions
     * const screenTypeOptions = await prisma.screenTypeOption.findMany()
     * 
     * // Get first 10 ScreenTypeOptions
     * const screenTypeOptions = await prisma.screenTypeOption.findMany({ take: 10 })
     * 
     * // Only select the `screenTypeCode`
     * const screenTypeOptionWithScreenTypeCodeOnly = await prisma.screenTypeOption.findMany({ select: { screenTypeCode: true } })
     * 
     */
    findMany<T extends ScreenTypeOptionFindManyArgs>(args?: SelectSubset<T, ScreenTypeOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenTypeOption.
     * @param {ScreenTypeOptionCreateArgs} args - Arguments to create a ScreenTypeOption.
     * @example
     * // Create one ScreenTypeOption
     * const ScreenTypeOption = await prisma.screenTypeOption.create({
     *   data: {
     *     // ... data to create a ScreenTypeOption
     *   }
     * })
     * 
     */
    create<T extends ScreenTypeOptionCreateArgs>(args: SelectSubset<T, ScreenTypeOptionCreateArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenTypeOptions.
     * @param {ScreenTypeOptionCreateManyArgs} args - Arguments to create many ScreenTypeOptions.
     * @example
     * // Create many ScreenTypeOptions
     * const screenTypeOption = await prisma.screenTypeOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenTypeOptionCreateManyArgs>(args?: SelectSubset<T, ScreenTypeOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenTypeOptions and returns the data saved in the database.
     * @param {ScreenTypeOptionCreateManyAndReturnArgs} args - Arguments to create many ScreenTypeOptions.
     * @example
     * // Create many ScreenTypeOptions
     * const screenTypeOption = await prisma.screenTypeOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenTypeOptions and only return the `screenTypeCode`
     * const screenTypeOptionWithScreenTypeCodeOnly = await prisma.screenTypeOption.createManyAndReturn({
     *   select: { screenTypeCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenTypeOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenTypeOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenTypeOption.
     * @param {ScreenTypeOptionDeleteArgs} args - Arguments to delete one ScreenTypeOption.
     * @example
     * // Delete one ScreenTypeOption
     * const ScreenTypeOption = await prisma.screenTypeOption.delete({
     *   where: {
     *     // ... filter to delete one ScreenTypeOption
     *   }
     * })
     * 
     */
    delete<T extends ScreenTypeOptionDeleteArgs>(args: SelectSubset<T, ScreenTypeOptionDeleteArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenTypeOption.
     * @param {ScreenTypeOptionUpdateArgs} args - Arguments to update one ScreenTypeOption.
     * @example
     * // Update one ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenTypeOptionUpdateArgs>(args: SelectSubset<T, ScreenTypeOptionUpdateArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenTypeOptions.
     * @param {ScreenTypeOptionDeleteManyArgs} args - Arguments to filter ScreenTypeOptions to delete.
     * @example
     * // Delete a few ScreenTypeOptions
     * const { count } = await prisma.screenTypeOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenTypeOptionDeleteManyArgs>(args?: SelectSubset<T, ScreenTypeOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenTypeOptions
     * const screenTypeOption = await prisma.screenTypeOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenTypeOptionUpdateManyArgs>(args: SelectSubset<T, ScreenTypeOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeOptions and returns the data updated in the database.
     * @param {ScreenTypeOptionUpdateManyAndReturnArgs} args - Arguments to update many ScreenTypeOptions.
     * @example
     * // Update many ScreenTypeOptions
     * const screenTypeOption = await prisma.screenTypeOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenTypeOptions and only return the `screenTypeCode`
     * const screenTypeOptionWithScreenTypeCodeOnly = await prisma.screenTypeOption.updateManyAndReturn({
     *   select: { screenTypeCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenTypeOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenTypeOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenTypeOption.
     * @param {ScreenTypeOptionUpsertArgs} args - Arguments to update or create a ScreenTypeOption.
     * @example
     * // Update or create a ScreenTypeOption
     * const screenTypeOption = await prisma.screenTypeOption.upsert({
     *   create: {
     *     // ... data to create a ScreenTypeOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenTypeOption we want to update
     *   }
     * })
     */
    upsert<T extends ScreenTypeOptionUpsertArgs>(args: SelectSubset<T, ScreenTypeOptionUpsertArgs<ExtArgs>>): Prisma__ScreenTypeOptionClient<$Result.GetResult<Prisma.$ScreenTypeOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenTypeOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionCountArgs} args - Arguments to filter ScreenTypeOptions to count.
     * @example
     * // Count the number of ScreenTypeOptions
     * const count = await prisma.screenTypeOption.count({
     *   where: {
     *     // ... the filter for the ScreenTypeOptions we want to count
     *   }
     * })
    **/
    count<T extends ScreenTypeOptionCountArgs>(
      args?: Subset<T, ScreenTypeOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenTypeOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenTypeOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenTypeOptionAggregateArgs>(args: Subset<T, ScreenTypeOptionAggregateArgs>): Prisma.PrismaPromise<GetScreenTypeOptionAggregateType<T>>

    /**
     * Group by ScreenTypeOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenTypeOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenTypeOptionGroupByArgs['orderBy'] }
        : { orderBy?: ScreenTypeOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenTypeOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenTypeOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenTypeOption model
   */
  readonly fields: ScreenTypeOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenTypeOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenTypeOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenType<T extends ScreenTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScreenTypeDefaultArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends OptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OptionDefaultArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenTypeOption model
   */
  interface ScreenTypeOptionFieldRefs {
    readonly screenTypeCode: FieldRef<"ScreenTypeOption", 'String'>
    readonly optionCode: FieldRef<"ScreenTypeOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScreenTypeOption findUnique
   */
  export type ScreenTypeOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeOption to fetch.
     */
    where: ScreenTypeOptionWhereUniqueInput
  }

  /**
   * ScreenTypeOption findUniqueOrThrow
   */
  export type ScreenTypeOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeOption to fetch.
     */
    where: ScreenTypeOptionWhereUniqueInput
  }

  /**
   * ScreenTypeOption findFirst
   */
  export type ScreenTypeOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeOption to fetch.
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeOptions to fetch.
     */
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeOptions.
     */
    cursor?: ScreenTypeOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeOptions.
     */
    distinct?: ScreenTypeOptionScalarFieldEnum | ScreenTypeOptionScalarFieldEnum[]
  }

  /**
   * ScreenTypeOption findFirstOrThrow
   */
  export type ScreenTypeOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeOption to fetch.
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeOptions to fetch.
     */
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeOptions.
     */
    cursor?: ScreenTypeOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeOptions.
     */
    distinct?: ScreenTypeOptionScalarFieldEnum | ScreenTypeOptionScalarFieldEnum[]
  }

  /**
   * ScreenTypeOption findMany
   */
  export type ScreenTypeOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeOptions to fetch.
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeOptions to fetch.
     */
    orderBy?: ScreenTypeOptionOrderByWithRelationInput | ScreenTypeOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenTypeOptions.
     */
    cursor?: ScreenTypeOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeOptions.
     */
    skip?: number
    distinct?: ScreenTypeOptionScalarFieldEnum | ScreenTypeOptionScalarFieldEnum[]
  }

  /**
   * ScreenTypeOption create
   */
  export type ScreenTypeOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenTypeOption.
     */
    data: XOR<ScreenTypeOptionCreateInput, ScreenTypeOptionUncheckedCreateInput>
  }

  /**
   * ScreenTypeOption createMany
   */
  export type ScreenTypeOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenTypeOptions.
     */
    data: ScreenTypeOptionCreateManyInput | ScreenTypeOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenTypeOption createManyAndReturn
   */
  export type ScreenTypeOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenTypeOptions.
     */
    data: ScreenTypeOptionCreateManyInput | ScreenTypeOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeOption update
   */
  export type ScreenTypeOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenTypeOption.
     */
    data: XOR<ScreenTypeOptionUpdateInput, ScreenTypeOptionUncheckedUpdateInput>
    /**
     * Choose, which ScreenTypeOption to update.
     */
    where: ScreenTypeOptionWhereUniqueInput
  }

  /**
   * ScreenTypeOption updateMany
   */
  export type ScreenTypeOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenTypeOptions.
     */
    data: XOR<ScreenTypeOptionUpdateManyMutationInput, ScreenTypeOptionUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeOptions to update
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * Limit how many ScreenTypeOptions to update.
     */
    limit?: number
  }

  /**
   * ScreenTypeOption updateManyAndReturn
   */
  export type ScreenTypeOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * The data used to update ScreenTypeOptions.
     */
    data: XOR<ScreenTypeOptionUpdateManyMutationInput, ScreenTypeOptionUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeOptions to update
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * Limit how many ScreenTypeOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeOption upsert
   */
  export type ScreenTypeOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenTypeOption to update in case it exists.
     */
    where: ScreenTypeOptionWhereUniqueInput
    /**
     * In case the ScreenTypeOption found by the `where` argument doesn't exist, create a new ScreenTypeOption with this data.
     */
    create: XOR<ScreenTypeOptionCreateInput, ScreenTypeOptionUncheckedCreateInput>
    /**
     * In case the ScreenTypeOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenTypeOptionUpdateInput, ScreenTypeOptionUncheckedUpdateInput>
  }

  /**
   * ScreenTypeOption delete
   */
  export type ScreenTypeOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
    /**
     * Filter which ScreenTypeOption to delete.
     */
    where: ScreenTypeOptionWhereUniqueInput
  }

  /**
   * ScreenTypeOption deleteMany
   */
  export type ScreenTypeOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeOptions to delete
     */
    where?: ScreenTypeOptionWhereInput
    /**
     * Limit how many ScreenTypeOptions to delete.
     */
    limit?: number
  }

  /**
   * ScreenTypeOption without action
   */
  export type ScreenTypeOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeOption
     */
    select?: ScreenTypeOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeOption
     */
    omit?: ScreenTypeOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeOptionInclude<ExtArgs> | null
  }


  /**
   * Model ScreenTypeControlType
   */

  export type AggregateScreenTypeControlType = {
    _count: ScreenTypeControlTypeCountAggregateOutputType | null
    _min: ScreenTypeControlTypeMinAggregateOutputType | null
    _max: ScreenTypeControlTypeMaxAggregateOutputType | null
  }

  export type ScreenTypeControlTypeMinAggregateOutputType = {
    screenTypeCode: string | null
    controlTypeCode: string | null
  }

  export type ScreenTypeControlTypeMaxAggregateOutputType = {
    screenTypeCode: string | null
    controlTypeCode: string | null
  }

  export type ScreenTypeControlTypeCountAggregateOutputType = {
    screenTypeCode: number
    controlTypeCode: number
    _all: number
  }


  export type ScreenTypeControlTypeMinAggregateInputType = {
    screenTypeCode?: true
    controlTypeCode?: true
  }

  export type ScreenTypeControlTypeMaxAggregateInputType = {
    screenTypeCode?: true
    controlTypeCode?: true
  }

  export type ScreenTypeControlTypeCountAggregateInputType = {
    screenTypeCode?: true
    controlTypeCode?: true
    _all?: true
  }

  export type ScreenTypeControlTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeControlType to aggregate.
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeControlTypes to fetch.
     */
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenTypeControlTypes
    **/
    _count?: true | ScreenTypeControlTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenTypeControlTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenTypeControlTypeMaxAggregateInputType
  }

  export type GetScreenTypeControlTypeAggregateType<T extends ScreenTypeControlTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenTypeControlType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenTypeControlType[P]>
      : GetScalarType<T[P], AggregateScreenTypeControlType[P]>
  }




  export type ScreenTypeControlTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeControlTypeWhereInput
    orderBy?: ScreenTypeControlTypeOrderByWithAggregationInput | ScreenTypeControlTypeOrderByWithAggregationInput[]
    by: ScreenTypeControlTypeScalarFieldEnum[] | ScreenTypeControlTypeScalarFieldEnum
    having?: ScreenTypeControlTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenTypeControlTypeCountAggregateInputType | true
    _min?: ScreenTypeControlTypeMinAggregateInputType
    _max?: ScreenTypeControlTypeMaxAggregateInputType
  }

  export type ScreenTypeControlTypeGroupByOutputType = {
    screenTypeCode: string
    controlTypeCode: string
    _count: ScreenTypeControlTypeCountAggregateOutputType | null
    _min: ScreenTypeControlTypeMinAggregateOutputType | null
    _max: ScreenTypeControlTypeMaxAggregateOutputType | null
  }

  type GetScreenTypeControlTypeGroupByPayload<T extends ScreenTypeControlTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenTypeControlTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenTypeControlTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenTypeControlTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenTypeControlTypeGroupByOutputType[P]>
        }
      >
    >


  export type ScreenTypeControlTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    controlTypeCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeControlType"]>

  export type ScreenTypeControlTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    controlTypeCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeControlType"]>

  export type ScreenTypeControlTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    controlTypeCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeControlType"]>

  export type ScreenTypeControlTypeSelectScalar = {
    screenTypeCode?: boolean
    controlTypeCode?: boolean
  }

  export type ScreenTypeControlTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"screenTypeCode" | "controlTypeCode", ExtArgs["result"]["screenTypeControlType"]>
  export type ScreenTypeControlTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }
  export type ScreenTypeControlTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }
  export type ScreenTypeControlTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    controlType?: boolean | ControlTypeDefaultArgs<ExtArgs>
  }

  export type $ScreenTypeControlTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenTypeControlType"
    objects: {
      screenType: Prisma.$ScreenTypePayload<ExtArgs>
      controlType: Prisma.$ControlTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      screenTypeCode: string
      controlTypeCode: string
    }, ExtArgs["result"]["screenTypeControlType"]>
    composites: {}
  }

  type ScreenTypeControlTypeGetPayload<S extends boolean | null | undefined | ScreenTypeControlTypeDefaultArgs> = $Result.GetResult<Prisma.$ScreenTypeControlTypePayload, S>

  type ScreenTypeControlTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenTypeControlTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenTypeControlTypeCountAggregateInputType | true
    }

  export interface ScreenTypeControlTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenTypeControlType'], meta: { name: 'ScreenTypeControlType' } }
    /**
     * Find zero or one ScreenTypeControlType that matches the filter.
     * @param {ScreenTypeControlTypeFindUniqueArgs} args - Arguments to find a ScreenTypeControlType
     * @example
     * // Get one ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenTypeControlTypeFindUniqueArgs>(args: SelectSubset<T, ScreenTypeControlTypeFindUniqueArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenTypeControlType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenTypeControlTypeFindUniqueOrThrowArgs} args - Arguments to find a ScreenTypeControlType
     * @example
     * // Get one ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenTypeControlTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenTypeControlTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeControlType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeFindFirstArgs} args - Arguments to find a ScreenTypeControlType
     * @example
     * // Get one ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenTypeControlTypeFindFirstArgs>(args?: SelectSubset<T, ScreenTypeControlTypeFindFirstArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeControlType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeFindFirstOrThrowArgs} args - Arguments to find a ScreenTypeControlType
     * @example
     * // Get one ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenTypeControlTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenTypeControlTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenTypeControlTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenTypeControlTypes
     * const screenTypeControlTypes = await prisma.screenTypeControlType.findMany()
     * 
     * // Get first 10 ScreenTypeControlTypes
     * const screenTypeControlTypes = await prisma.screenTypeControlType.findMany({ take: 10 })
     * 
     * // Only select the `screenTypeCode`
     * const screenTypeControlTypeWithScreenTypeCodeOnly = await prisma.screenTypeControlType.findMany({ select: { screenTypeCode: true } })
     * 
     */
    findMany<T extends ScreenTypeControlTypeFindManyArgs>(args?: SelectSubset<T, ScreenTypeControlTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenTypeControlType.
     * @param {ScreenTypeControlTypeCreateArgs} args - Arguments to create a ScreenTypeControlType.
     * @example
     * // Create one ScreenTypeControlType
     * const ScreenTypeControlType = await prisma.screenTypeControlType.create({
     *   data: {
     *     // ... data to create a ScreenTypeControlType
     *   }
     * })
     * 
     */
    create<T extends ScreenTypeControlTypeCreateArgs>(args: SelectSubset<T, ScreenTypeControlTypeCreateArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenTypeControlTypes.
     * @param {ScreenTypeControlTypeCreateManyArgs} args - Arguments to create many ScreenTypeControlTypes.
     * @example
     * // Create many ScreenTypeControlTypes
     * const screenTypeControlType = await prisma.screenTypeControlType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenTypeControlTypeCreateManyArgs>(args?: SelectSubset<T, ScreenTypeControlTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenTypeControlTypes and returns the data saved in the database.
     * @param {ScreenTypeControlTypeCreateManyAndReturnArgs} args - Arguments to create many ScreenTypeControlTypes.
     * @example
     * // Create many ScreenTypeControlTypes
     * const screenTypeControlType = await prisma.screenTypeControlType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenTypeControlTypes and only return the `screenTypeCode`
     * const screenTypeControlTypeWithScreenTypeCodeOnly = await prisma.screenTypeControlType.createManyAndReturn({
     *   select: { screenTypeCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenTypeControlTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenTypeControlTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenTypeControlType.
     * @param {ScreenTypeControlTypeDeleteArgs} args - Arguments to delete one ScreenTypeControlType.
     * @example
     * // Delete one ScreenTypeControlType
     * const ScreenTypeControlType = await prisma.screenTypeControlType.delete({
     *   where: {
     *     // ... filter to delete one ScreenTypeControlType
     *   }
     * })
     * 
     */
    delete<T extends ScreenTypeControlTypeDeleteArgs>(args: SelectSubset<T, ScreenTypeControlTypeDeleteArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenTypeControlType.
     * @param {ScreenTypeControlTypeUpdateArgs} args - Arguments to update one ScreenTypeControlType.
     * @example
     * // Update one ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenTypeControlTypeUpdateArgs>(args: SelectSubset<T, ScreenTypeControlTypeUpdateArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenTypeControlTypes.
     * @param {ScreenTypeControlTypeDeleteManyArgs} args - Arguments to filter ScreenTypeControlTypes to delete.
     * @example
     * // Delete a few ScreenTypeControlTypes
     * const { count } = await prisma.screenTypeControlType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenTypeControlTypeDeleteManyArgs>(args?: SelectSubset<T, ScreenTypeControlTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeControlTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenTypeControlTypes
     * const screenTypeControlType = await prisma.screenTypeControlType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenTypeControlTypeUpdateManyArgs>(args: SelectSubset<T, ScreenTypeControlTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeControlTypes and returns the data updated in the database.
     * @param {ScreenTypeControlTypeUpdateManyAndReturnArgs} args - Arguments to update many ScreenTypeControlTypes.
     * @example
     * // Update many ScreenTypeControlTypes
     * const screenTypeControlType = await prisma.screenTypeControlType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenTypeControlTypes and only return the `screenTypeCode`
     * const screenTypeControlTypeWithScreenTypeCodeOnly = await prisma.screenTypeControlType.updateManyAndReturn({
     *   select: { screenTypeCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenTypeControlTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenTypeControlTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenTypeControlType.
     * @param {ScreenTypeControlTypeUpsertArgs} args - Arguments to update or create a ScreenTypeControlType.
     * @example
     * // Update or create a ScreenTypeControlType
     * const screenTypeControlType = await prisma.screenTypeControlType.upsert({
     *   create: {
     *     // ... data to create a ScreenTypeControlType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenTypeControlType we want to update
     *   }
     * })
     */
    upsert<T extends ScreenTypeControlTypeUpsertArgs>(args: SelectSubset<T, ScreenTypeControlTypeUpsertArgs<ExtArgs>>): Prisma__ScreenTypeControlTypeClient<$Result.GetResult<Prisma.$ScreenTypeControlTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenTypeControlTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeCountArgs} args - Arguments to filter ScreenTypeControlTypes to count.
     * @example
     * // Count the number of ScreenTypeControlTypes
     * const count = await prisma.screenTypeControlType.count({
     *   where: {
     *     // ... the filter for the ScreenTypeControlTypes we want to count
     *   }
     * })
    **/
    count<T extends ScreenTypeControlTypeCountArgs>(
      args?: Subset<T, ScreenTypeControlTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenTypeControlTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenTypeControlType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenTypeControlTypeAggregateArgs>(args: Subset<T, ScreenTypeControlTypeAggregateArgs>): Prisma.PrismaPromise<GetScreenTypeControlTypeAggregateType<T>>

    /**
     * Group by ScreenTypeControlType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeControlTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenTypeControlTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenTypeControlTypeGroupByArgs['orderBy'] }
        : { orderBy?: ScreenTypeControlTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenTypeControlTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenTypeControlTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenTypeControlType model
   */
  readonly fields: ScreenTypeControlTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenTypeControlType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenTypeControlTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenType<T extends ScreenTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScreenTypeDefaultArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    controlType<T extends ControlTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ControlTypeDefaultArgs<ExtArgs>>): Prisma__ControlTypeClient<$Result.GetResult<Prisma.$ControlTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenTypeControlType model
   */
  interface ScreenTypeControlTypeFieldRefs {
    readonly screenTypeCode: FieldRef<"ScreenTypeControlType", 'String'>
    readonly controlTypeCode: FieldRef<"ScreenTypeControlType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScreenTypeControlType findUnique
   */
  export type ScreenTypeControlTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeControlType to fetch.
     */
    where: ScreenTypeControlTypeWhereUniqueInput
  }

  /**
   * ScreenTypeControlType findUniqueOrThrow
   */
  export type ScreenTypeControlTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeControlType to fetch.
     */
    where: ScreenTypeControlTypeWhereUniqueInput
  }

  /**
   * ScreenTypeControlType findFirst
   */
  export type ScreenTypeControlTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeControlType to fetch.
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeControlTypes to fetch.
     */
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeControlTypes.
     */
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeControlTypes.
     */
    distinct?: ScreenTypeControlTypeScalarFieldEnum | ScreenTypeControlTypeScalarFieldEnum[]
  }

  /**
   * ScreenTypeControlType findFirstOrThrow
   */
  export type ScreenTypeControlTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeControlType to fetch.
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeControlTypes to fetch.
     */
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeControlTypes.
     */
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeControlTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeControlTypes.
     */
    distinct?: ScreenTypeControlTypeScalarFieldEnum | ScreenTypeControlTypeScalarFieldEnum[]
  }

  /**
   * ScreenTypeControlType findMany
   */
  export type ScreenTypeControlTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeControlTypes to fetch.
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeControlTypes to fetch.
     */
    orderBy?: ScreenTypeControlTypeOrderByWithRelationInput | ScreenTypeControlTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenTypeControlTypes.
     */
    cursor?: ScreenTypeControlTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeControlTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeControlTypes.
     */
    skip?: number
    distinct?: ScreenTypeControlTypeScalarFieldEnum | ScreenTypeControlTypeScalarFieldEnum[]
  }

  /**
   * ScreenTypeControlType create
   */
  export type ScreenTypeControlTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenTypeControlType.
     */
    data: XOR<ScreenTypeControlTypeCreateInput, ScreenTypeControlTypeUncheckedCreateInput>
  }

  /**
   * ScreenTypeControlType createMany
   */
  export type ScreenTypeControlTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenTypeControlTypes.
     */
    data: ScreenTypeControlTypeCreateManyInput | ScreenTypeControlTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenTypeControlType createManyAndReturn
   */
  export type ScreenTypeControlTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenTypeControlTypes.
     */
    data: ScreenTypeControlTypeCreateManyInput | ScreenTypeControlTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeControlType update
   */
  export type ScreenTypeControlTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenTypeControlType.
     */
    data: XOR<ScreenTypeControlTypeUpdateInput, ScreenTypeControlTypeUncheckedUpdateInput>
    /**
     * Choose, which ScreenTypeControlType to update.
     */
    where: ScreenTypeControlTypeWhereUniqueInput
  }

  /**
   * ScreenTypeControlType updateMany
   */
  export type ScreenTypeControlTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenTypeControlTypes.
     */
    data: XOR<ScreenTypeControlTypeUpdateManyMutationInput, ScreenTypeControlTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeControlTypes to update
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * Limit how many ScreenTypeControlTypes to update.
     */
    limit?: number
  }

  /**
   * ScreenTypeControlType updateManyAndReturn
   */
  export type ScreenTypeControlTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * The data used to update ScreenTypeControlTypes.
     */
    data: XOR<ScreenTypeControlTypeUpdateManyMutationInput, ScreenTypeControlTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeControlTypes to update
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * Limit how many ScreenTypeControlTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeControlType upsert
   */
  export type ScreenTypeControlTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenTypeControlType to update in case it exists.
     */
    where: ScreenTypeControlTypeWhereUniqueInput
    /**
     * In case the ScreenTypeControlType found by the `where` argument doesn't exist, create a new ScreenTypeControlType with this data.
     */
    create: XOR<ScreenTypeControlTypeCreateInput, ScreenTypeControlTypeUncheckedCreateInput>
    /**
     * In case the ScreenTypeControlType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenTypeControlTypeUpdateInput, ScreenTypeControlTypeUncheckedUpdateInput>
  }

  /**
   * ScreenTypeControlType delete
   */
  export type ScreenTypeControlTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
    /**
     * Filter which ScreenTypeControlType to delete.
     */
    where: ScreenTypeControlTypeWhereUniqueInput
  }

  /**
   * ScreenTypeControlType deleteMany
   */
  export type ScreenTypeControlTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeControlTypes to delete
     */
    where?: ScreenTypeControlTypeWhereInput
    /**
     * Limit how many ScreenTypeControlTypes to delete.
     */
    limit?: number
  }

  /**
   * ScreenTypeControlType without action
   */
  export type ScreenTypeControlTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeControlType
     */
    select?: ScreenTypeControlTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeControlType
     */
    omit?: ScreenTypeControlTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeControlTypeInclude<ExtArgs> | null
  }


  /**
   * Model ScreenTypeSensor
   */

  export type AggregateScreenTypeSensor = {
    _count: ScreenTypeSensorCountAggregateOutputType | null
    _min: ScreenTypeSensorMinAggregateOutputType | null
    _max: ScreenTypeSensorMaxAggregateOutputType | null
  }

  export type ScreenTypeSensorMinAggregateOutputType = {
    screenTypeCode: string | null
    sensorCode: string | null
  }

  export type ScreenTypeSensorMaxAggregateOutputType = {
    screenTypeCode: string | null
    sensorCode: string | null
  }

  export type ScreenTypeSensorCountAggregateOutputType = {
    screenTypeCode: number
    sensorCode: number
    _all: number
  }


  export type ScreenTypeSensorMinAggregateInputType = {
    screenTypeCode?: true
    sensorCode?: true
  }

  export type ScreenTypeSensorMaxAggregateInputType = {
    screenTypeCode?: true
    sensorCode?: true
  }

  export type ScreenTypeSensorCountAggregateInputType = {
    screenTypeCode?: true
    sensorCode?: true
    _all?: true
  }

  export type ScreenTypeSensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeSensor to aggregate.
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeSensors to fetch.
     */
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenTypeSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenTypeSensors
    **/
    _count?: true | ScreenTypeSensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenTypeSensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenTypeSensorMaxAggregateInputType
  }

  export type GetScreenTypeSensorAggregateType<T extends ScreenTypeSensorAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenTypeSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenTypeSensor[P]>
      : GetScalarType<T[P], AggregateScreenTypeSensor[P]>
  }




  export type ScreenTypeSensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTypeSensorWhereInput
    orderBy?: ScreenTypeSensorOrderByWithAggregationInput | ScreenTypeSensorOrderByWithAggregationInput[]
    by: ScreenTypeSensorScalarFieldEnum[] | ScreenTypeSensorScalarFieldEnum
    having?: ScreenTypeSensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenTypeSensorCountAggregateInputType | true
    _min?: ScreenTypeSensorMinAggregateInputType
    _max?: ScreenTypeSensorMaxAggregateInputType
  }

  export type ScreenTypeSensorGroupByOutputType = {
    screenTypeCode: string
    sensorCode: string
    _count: ScreenTypeSensorCountAggregateOutputType | null
    _min: ScreenTypeSensorMinAggregateOutputType | null
    _max: ScreenTypeSensorMaxAggregateOutputType | null
  }

  type GetScreenTypeSensorGroupByPayload<T extends ScreenTypeSensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenTypeSensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenTypeSensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenTypeSensorGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenTypeSensorGroupByOutputType[P]>
        }
      >
    >


  export type ScreenTypeSensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    sensorCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeSensor"]>

  export type ScreenTypeSensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    sensorCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeSensor"]>

  export type ScreenTypeSensorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenTypeCode?: boolean
    sensorCode?: boolean
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTypeSensor"]>

  export type ScreenTypeSensorSelectScalar = {
    screenTypeCode?: boolean
    sensorCode?: boolean
  }

  export type ScreenTypeSensorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"screenTypeCode" | "sensorCode", ExtArgs["result"]["screenTypeSensor"]>
  export type ScreenTypeSensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }
  export type ScreenTypeSensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }
  export type ScreenTypeSensorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenType?: boolean | ScreenTypeDefaultArgs<ExtArgs>
    sensor?: boolean | SensorDefaultArgs<ExtArgs>
  }

  export type $ScreenTypeSensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenTypeSensor"
    objects: {
      screenType: Prisma.$ScreenTypePayload<ExtArgs>
      sensor: Prisma.$SensorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      screenTypeCode: string
      sensorCode: string
    }, ExtArgs["result"]["screenTypeSensor"]>
    composites: {}
  }

  type ScreenTypeSensorGetPayload<S extends boolean | null | undefined | ScreenTypeSensorDefaultArgs> = $Result.GetResult<Prisma.$ScreenTypeSensorPayload, S>

  type ScreenTypeSensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenTypeSensorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenTypeSensorCountAggregateInputType | true
    }

  export interface ScreenTypeSensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenTypeSensor'], meta: { name: 'ScreenTypeSensor' } }
    /**
     * Find zero or one ScreenTypeSensor that matches the filter.
     * @param {ScreenTypeSensorFindUniqueArgs} args - Arguments to find a ScreenTypeSensor
     * @example
     * // Get one ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenTypeSensorFindUniqueArgs>(args: SelectSubset<T, ScreenTypeSensorFindUniqueArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenTypeSensor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenTypeSensorFindUniqueOrThrowArgs} args - Arguments to find a ScreenTypeSensor
     * @example
     * // Get one ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenTypeSensorFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenTypeSensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeSensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorFindFirstArgs} args - Arguments to find a ScreenTypeSensor
     * @example
     * // Get one ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenTypeSensorFindFirstArgs>(args?: SelectSubset<T, ScreenTypeSensorFindFirstArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTypeSensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorFindFirstOrThrowArgs} args - Arguments to find a ScreenTypeSensor
     * @example
     * // Get one ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenTypeSensorFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenTypeSensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenTypeSensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenTypeSensors
     * const screenTypeSensors = await prisma.screenTypeSensor.findMany()
     * 
     * // Get first 10 ScreenTypeSensors
     * const screenTypeSensors = await prisma.screenTypeSensor.findMany({ take: 10 })
     * 
     * // Only select the `screenTypeCode`
     * const screenTypeSensorWithScreenTypeCodeOnly = await prisma.screenTypeSensor.findMany({ select: { screenTypeCode: true } })
     * 
     */
    findMany<T extends ScreenTypeSensorFindManyArgs>(args?: SelectSubset<T, ScreenTypeSensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenTypeSensor.
     * @param {ScreenTypeSensorCreateArgs} args - Arguments to create a ScreenTypeSensor.
     * @example
     * // Create one ScreenTypeSensor
     * const ScreenTypeSensor = await prisma.screenTypeSensor.create({
     *   data: {
     *     // ... data to create a ScreenTypeSensor
     *   }
     * })
     * 
     */
    create<T extends ScreenTypeSensorCreateArgs>(args: SelectSubset<T, ScreenTypeSensorCreateArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenTypeSensors.
     * @param {ScreenTypeSensorCreateManyArgs} args - Arguments to create many ScreenTypeSensors.
     * @example
     * // Create many ScreenTypeSensors
     * const screenTypeSensor = await prisma.screenTypeSensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenTypeSensorCreateManyArgs>(args?: SelectSubset<T, ScreenTypeSensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenTypeSensors and returns the data saved in the database.
     * @param {ScreenTypeSensorCreateManyAndReturnArgs} args - Arguments to create many ScreenTypeSensors.
     * @example
     * // Create many ScreenTypeSensors
     * const screenTypeSensor = await prisma.screenTypeSensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenTypeSensors and only return the `screenTypeCode`
     * const screenTypeSensorWithScreenTypeCodeOnly = await prisma.screenTypeSensor.createManyAndReturn({
     *   select: { screenTypeCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenTypeSensorCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenTypeSensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenTypeSensor.
     * @param {ScreenTypeSensorDeleteArgs} args - Arguments to delete one ScreenTypeSensor.
     * @example
     * // Delete one ScreenTypeSensor
     * const ScreenTypeSensor = await prisma.screenTypeSensor.delete({
     *   where: {
     *     // ... filter to delete one ScreenTypeSensor
     *   }
     * })
     * 
     */
    delete<T extends ScreenTypeSensorDeleteArgs>(args: SelectSubset<T, ScreenTypeSensorDeleteArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenTypeSensor.
     * @param {ScreenTypeSensorUpdateArgs} args - Arguments to update one ScreenTypeSensor.
     * @example
     * // Update one ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenTypeSensorUpdateArgs>(args: SelectSubset<T, ScreenTypeSensorUpdateArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenTypeSensors.
     * @param {ScreenTypeSensorDeleteManyArgs} args - Arguments to filter ScreenTypeSensors to delete.
     * @example
     * // Delete a few ScreenTypeSensors
     * const { count } = await prisma.screenTypeSensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenTypeSensorDeleteManyArgs>(args?: SelectSubset<T, ScreenTypeSensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenTypeSensors
     * const screenTypeSensor = await prisma.screenTypeSensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenTypeSensorUpdateManyArgs>(args: SelectSubset<T, ScreenTypeSensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTypeSensors and returns the data updated in the database.
     * @param {ScreenTypeSensorUpdateManyAndReturnArgs} args - Arguments to update many ScreenTypeSensors.
     * @example
     * // Update many ScreenTypeSensors
     * const screenTypeSensor = await prisma.screenTypeSensor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenTypeSensors and only return the `screenTypeCode`
     * const screenTypeSensorWithScreenTypeCodeOnly = await prisma.screenTypeSensor.updateManyAndReturn({
     *   select: { screenTypeCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenTypeSensorUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenTypeSensorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenTypeSensor.
     * @param {ScreenTypeSensorUpsertArgs} args - Arguments to update or create a ScreenTypeSensor.
     * @example
     * // Update or create a ScreenTypeSensor
     * const screenTypeSensor = await prisma.screenTypeSensor.upsert({
     *   create: {
     *     // ... data to create a ScreenTypeSensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenTypeSensor we want to update
     *   }
     * })
     */
    upsert<T extends ScreenTypeSensorUpsertArgs>(args: SelectSubset<T, ScreenTypeSensorUpsertArgs<ExtArgs>>): Prisma__ScreenTypeSensorClient<$Result.GetResult<Prisma.$ScreenTypeSensorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenTypeSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorCountArgs} args - Arguments to filter ScreenTypeSensors to count.
     * @example
     * // Count the number of ScreenTypeSensors
     * const count = await prisma.screenTypeSensor.count({
     *   where: {
     *     // ... the filter for the ScreenTypeSensors we want to count
     *   }
     * })
    **/
    count<T extends ScreenTypeSensorCountArgs>(
      args?: Subset<T, ScreenTypeSensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenTypeSensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenTypeSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenTypeSensorAggregateArgs>(args: Subset<T, ScreenTypeSensorAggregateArgs>): Prisma.PrismaPromise<GetScreenTypeSensorAggregateType<T>>

    /**
     * Group by ScreenTypeSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTypeSensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenTypeSensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenTypeSensorGroupByArgs['orderBy'] }
        : { orderBy?: ScreenTypeSensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenTypeSensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenTypeSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenTypeSensor model
   */
  readonly fields: ScreenTypeSensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenTypeSensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenTypeSensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screenType<T extends ScreenTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScreenTypeDefaultArgs<ExtArgs>>): Prisma__ScreenTypeClient<$Result.GetResult<Prisma.$ScreenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sensor<T extends SensorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SensorDefaultArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenTypeSensor model
   */
  interface ScreenTypeSensorFieldRefs {
    readonly screenTypeCode: FieldRef<"ScreenTypeSensor", 'String'>
    readonly sensorCode: FieldRef<"ScreenTypeSensor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScreenTypeSensor findUnique
   */
  export type ScreenTypeSensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeSensor to fetch.
     */
    where: ScreenTypeSensorWhereUniqueInput
  }

  /**
   * ScreenTypeSensor findUniqueOrThrow
   */
  export type ScreenTypeSensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeSensor to fetch.
     */
    where: ScreenTypeSensorWhereUniqueInput
  }

  /**
   * ScreenTypeSensor findFirst
   */
  export type ScreenTypeSensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeSensor to fetch.
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeSensors to fetch.
     */
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeSensors.
     */
    cursor?: ScreenTypeSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeSensors.
     */
    distinct?: ScreenTypeSensorScalarFieldEnum | ScreenTypeSensorScalarFieldEnum[]
  }

  /**
   * ScreenTypeSensor findFirstOrThrow
   */
  export type ScreenTypeSensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeSensor to fetch.
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeSensors to fetch.
     */
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTypeSensors.
     */
    cursor?: ScreenTypeSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTypeSensors.
     */
    distinct?: ScreenTypeSensorScalarFieldEnum | ScreenTypeSensorScalarFieldEnum[]
  }

  /**
   * ScreenTypeSensor findMany
   */
  export type ScreenTypeSensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTypeSensors to fetch.
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTypeSensors to fetch.
     */
    orderBy?: ScreenTypeSensorOrderByWithRelationInput | ScreenTypeSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenTypeSensors.
     */
    cursor?: ScreenTypeSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTypeSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTypeSensors.
     */
    skip?: number
    distinct?: ScreenTypeSensorScalarFieldEnum | ScreenTypeSensorScalarFieldEnum[]
  }

  /**
   * ScreenTypeSensor create
   */
  export type ScreenTypeSensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenTypeSensor.
     */
    data: XOR<ScreenTypeSensorCreateInput, ScreenTypeSensorUncheckedCreateInput>
  }

  /**
   * ScreenTypeSensor createMany
   */
  export type ScreenTypeSensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenTypeSensors.
     */
    data: ScreenTypeSensorCreateManyInput | ScreenTypeSensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenTypeSensor createManyAndReturn
   */
  export type ScreenTypeSensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenTypeSensors.
     */
    data: ScreenTypeSensorCreateManyInput | ScreenTypeSensorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeSensor update
   */
  export type ScreenTypeSensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenTypeSensor.
     */
    data: XOR<ScreenTypeSensorUpdateInput, ScreenTypeSensorUncheckedUpdateInput>
    /**
     * Choose, which ScreenTypeSensor to update.
     */
    where: ScreenTypeSensorWhereUniqueInput
  }

  /**
   * ScreenTypeSensor updateMany
   */
  export type ScreenTypeSensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenTypeSensors.
     */
    data: XOR<ScreenTypeSensorUpdateManyMutationInput, ScreenTypeSensorUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeSensors to update
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * Limit how many ScreenTypeSensors to update.
     */
    limit?: number
  }

  /**
   * ScreenTypeSensor updateManyAndReturn
   */
  export type ScreenTypeSensorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * The data used to update ScreenTypeSensors.
     */
    data: XOR<ScreenTypeSensorUpdateManyMutationInput, ScreenTypeSensorUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTypeSensors to update
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * Limit how many ScreenTypeSensors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTypeSensor upsert
   */
  export type ScreenTypeSensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenTypeSensor to update in case it exists.
     */
    where: ScreenTypeSensorWhereUniqueInput
    /**
     * In case the ScreenTypeSensor found by the `where` argument doesn't exist, create a new ScreenTypeSensor with this data.
     */
    create: XOR<ScreenTypeSensorCreateInput, ScreenTypeSensorUncheckedCreateInput>
    /**
     * In case the ScreenTypeSensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenTypeSensorUpdateInput, ScreenTypeSensorUncheckedUpdateInput>
  }

  /**
   * ScreenTypeSensor delete
   */
  export type ScreenTypeSensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
    /**
     * Filter which ScreenTypeSensor to delete.
     */
    where: ScreenTypeSensorWhereUniqueInput
  }

  /**
   * ScreenTypeSensor deleteMany
   */
  export type ScreenTypeSensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTypeSensors to delete
     */
    where?: ScreenTypeSensorWhereInput
    /**
     * Limit how many ScreenTypeSensors to delete.
     */
    limit?: number
  }

  /**
   * ScreenTypeSensor without action
   */
  export type ScreenTypeSensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTypeSensor
     */
    select?: ScreenTypeSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTypeSensor
     */
    omit?: ScreenTypeSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTypeSensorInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategoryRelation
   */

  export type AggregateItemCategoryRelation = {
    _count: ItemCategoryRelationCountAggregateOutputType | null
    _min: ItemCategoryRelationMinAggregateOutputType | null
    _max: ItemCategoryRelationMaxAggregateOutputType | null
  }

  export type ItemCategoryRelationMinAggregateOutputType = {
    itemCode: string | null
    categoryCode: string | null
  }

  export type ItemCategoryRelationMaxAggregateOutputType = {
    itemCode: string | null
    categoryCode: string | null
  }

  export type ItemCategoryRelationCountAggregateOutputType = {
    itemCode: number
    categoryCode: number
    _all: number
  }


  export type ItemCategoryRelationMinAggregateInputType = {
    itemCode?: true
    categoryCode?: true
  }

  export type ItemCategoryRelationMaxAggregateInputType = {
    itemCode?: true
    categoryCode?: true
  }

  export type ItemCategoryRelationCountAggregateInputType = {
    itemCode?: true
    categoryCode?: true
    _all?: true
  }

  export type ItemCategoryRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategoryRelation to aggregate.
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryRelations to fetch.
     */
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategoryRelations
    **/
    _count?: true | ItemCategoryRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryRelationMaxAggregateInputType
  }

  export type GetItemCategoryRelationAggregateType<T extends ItemCategoryRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategoryRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategoryRelation[P]>
      : GetScalarType<T[P], AggregateItemCategoryRelation[P]>
  }




  export type ItemCategoryRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryRelationWhereInput
    orderBy?: ItemCategoryRelationOrderByWithAggregationInput | ItemCategoryRelationOrderByWithAggregationInput[]
    by: ItemCategoryRelationScalarFieldEnum[] | ItemCategoryRelationScalarFieldEnum
    having?: ItemCategoryRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryRelationCountAggregateInputType | true
    _min?: ItemCategoryRelationMinAggregateInputType
    _max?: ItemCategoryRelationMaxAggregateInputType
  }

  export type ItemCategoryRelationGroupByOutputType = {
    itemCode: string
    categoryCode: string
    _count: ItemCategoryRelationCountAggregateOutputType | null
    _min: ItemCategoryRelationMinAggregateOutputType | null
    _max: ItemCategoryRelationMaxAggregateOutputType | null
  }

  type GetItemCategoryRelationGroupByPayload<T extends ItemCategoryRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryRelationGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryRelationGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategoryRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    categoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategoryRelation"]>

  export type ItemCategoryRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    categoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategoryRelation"]>

  export type ItemCategoryRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    categoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategoryRelation"]>

  export type ItemCategoryRelationSelectScalar = {
    itemCode?: boolean
    categoryCode?: boolean
  }

  export type ItemCategoryRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemCode" | "categoryCode", ExtArgs["result"]["itemCategoryRelation"]>
  export type ItemCategoryRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type ItemCategoryRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type ItemCategoryRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $ItemCategoryRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategoryRelation"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      category: Prisma.$ItemCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemCode: string
      categoryCode: string
    }, ExtArgs["result"]["itemCategoryRelation"]>
    composites: {}
  }

  type ItemCategoryRelationGetPayload<S extends boolean | null | undefined | ItemCategoryRelationDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryRelationPayload, S>

  type ItemCategoryRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryRelationCountAggregateInputType | true
    }

  export interface ItemCategoryRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategoryRelation'], meta: { name: 'ItemCategoryRelation' } }
    /**
     * Find zero or one ItemCategoryRelation that matches the filter.
     * @param {ItemCategoryRelationFindUniqueArgs} args - Arguments to find a ItemCategoryRelation
     * @example
     * // Get one ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryRelationFindUniqueArgs>(args: SelectSubset<T, ItemCategoryRelationFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategoryRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryRelationFindUniqueOrThrowArgs} args - Arguments to find a ItemCategoryRelation
     * @example
     * // Get one ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategoryRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationFindFirstArgs} args - Arguments to find a ItemCategoryRelation
     * @example
     * // Get one ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryRelationFindFirstArgs>(args?: SelectSubset<T, ItemCategoryRelationFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategoryRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationFindFirstOrThrowArgs} args - Arguments to find a ItemCategoryRelation
     * @example
     * // Get one ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategoryRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategoryRelations
     * const itemCategoryRelations = await prisma.itemCategoryRelation.findMany()
     * 
     * // Get first 10 ItemCategoryRelations
     * const itemCategoryRelations = await prisma.itemCategoryRelation.findMany({ take: 10 })
     * 
     * // Only select the `itemCode`
     * const itemCategoryRelationWithItemCodeOnly = await prisma.itemCategoryRelation.findMany({ select: { itemCode: true } })
     * 
     */
    findMany<T extends ItemCategoryRelationFindManyArgs>(args?: SelectSubset<T, ItemCategoryRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategoryRelation.
     * @param {ItemCategoryRelationCreateArgs} args - Arguments to create a ItemCategoryRelation.
     * @example
     * // Create one ItemCategoryRelation
     * const ItemCategoryRelation = await prisma.itemCategoryRelation.create({
     *   data: {
     *     // ... data to create a ItemCategoryRelation
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryRelationCreateArgs>(args: SelectSubset<T, ItemCategoryRelationCreateArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategoryRelations.
     * @param {ItemCategoryRelationCreateManyArgs} args - Arguments to create many ItemCategoryRelations.
     * @example
     * // Create many ItemCategoryRelations
     * const itemCategoryRelation = await prisma.itemCategoryRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryRelationCreateManyArgs>(args?: SelectSubset<T, ItemCategoryRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategoryRelations and returns the data saved in the database.
     * @param {ItemCategoryRelationCreateManyAndReturnArgs} args - Arguments to create many ItemCategoryRelations.
     * @example
     * // Create many ItemCategoryRelations
     * const itemCategoryRelation = await prisma.itemCategoryRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategoryRelations and only return the `itemCode`
     * const itemCategoryRelationWithItemCodeOnly = await prisma.itemCategoryRelation.createManyAndReturn({
     *   select: { itemCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategoryRelation.
     * @param {ItemCategoryRelationDeleteArgs} args - Arguments to delete one ItemCategoryRelation.
     * @example
     * // Delete one ItemCategoryRelation
     * const ItemCategoryRelation = await prisma.itemCategoryRelation.delete({
     *   where: {
     *     // ... filter to delete one ItemCategoryRelation
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryRelationDeleteArgs>(args: SelectSubset<T, ItemCategoryRelationDeleteArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategoryRelation.
     * @param {ItemCategoryRelationUpdateArgs} args - Arguments to update one ItemCategoryRelation.
     * @example
     * // Update one ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryRelationUpdateArgs>(args: SelectSubset<T, ItemCategoryRelationUpdateArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategoryRelations.
     * @param {ItemCategoryRelationDeleteManyArgs} args - Arguments to filter ItemCategoryRelations to delete.
     * @example
     * // Delete a few ItemCategoryRelations
     * const { count } = await prisma.itemCategoryRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryRelationDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategoryRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategoryRelations
     * const itemCategoryRelation = await prisma.itemCategoryRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryRelationUpdateManyArgs>(args: SelectSubset<T, ItemCategoryRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategoryRelations and returns the data updated in the database.
     * @param {ItemCategoryRelationUpdateManyAndReturnArgs} args - Arguments to update many ItemCategoryRelations.
     * @example
     * // Update many ItemCategoryRelations
     * const itemCategoryRelation = await prisma.itemCategoryRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategoryRelations and only return the `itemCode`
     * const itemCategoryRelationWithItemCodeOnly = await prisma.itemCategoryRelation.updateManyAndReturn({
     *   select: { itemCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategoryRelation.
     * @param {ItemCategoryRelationUpsertArgs} args - Arguments to update or create a ItemCategoryRelation.
     * @example
     * // Update or create a ItemCategoryRelation
     * const itemCategoryRelation = await prisma.itemCategoryRelation.upsert({
     *   create: {
     *     // ... data to create a ItemCategoryRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategoryRelation we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryRelationUpsertArgs>(args: SelectSubset<T, ItemCategoryRelationUpsertArgs<ExtArgs>>): Prisma__ItemCategoryRelationClient<$Result.GetResult<Prisma.$ItemCategoryRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategoryRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationCountArgs} args - Arguments to filter ItemCategoryRelations to count.
     * @example
     * // Count the number of ItemCategoryRelations
     * const count = await prisma.itemCategoryRelation.count({
     *   where: {
     *     // ... the filter for the ItemCategoryRelations we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryRelationCountArgs>(
      args?: Subset<T, ItemCategoryRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategoryRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryRelationAggregateArgs>(args: Subset<T, ItemCategoryRelationAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryRelationAggregateType<T>>

    /**
     * Group by ItemCategoryRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryRelationGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategoryRelation model
   */
  readonly fields: ItemCategoryRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategoryRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategoryRelation model
   */
  interface ItemCategoryRelationFieldRefs {
    readonly itemCode: FieldRef<"ItemCategoryRelation", 'String'>
    readonly categoryCode: FieldRef<"ItemCategoryRelation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategoryRelation findUnique
   */
  export type ItemCategoryRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryRelation to fetch.
     */
    where: ItemCategoryRelationWhereUniqueInput
  }

  /**
   * ItemCategoryRelation findUniqueOrThrow
   */
  export type ItemCategoryRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryRelation to fetch.
     */
    where: ItemCategoryRelationWhereUniqueInput
  }

  /**
   * ItemCategoryRelation findFirst
   */
  export type ItemCategoryRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryRelation to fetch.
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryRelations to fetch.
     */
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategoryRelations.
     */
    cursor?: ItemCategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategoryRelations.
     */
    distinct?: ItemCategoryRelationScalarFieldEnum | ItemCategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemCategoryRelation findFirstOrThrow
   */
  export type ItemCategoryRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryRelation to fetch.
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryRelations to fetch.
     */
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategoryRelations.
     */
    cursor?: ItemCategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategoryRelations.
     */
    distinct?: ItemCategoryRelationScalarFieldEnum | ItemCategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemCategoryRelation findMany
   */
  export type ItemCategoryRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryRelations to fetch.
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryRelations to fetch.
     */
    orderBy?: ItemCategoryRelationOrderByWithRelationInput | ItemCategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategoryRelations.
     */
    cursor?: ItemCategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryRelations.
     */
    skip?: number
    distinct?: ItemCategoryRelationScalarFieldEnum | ItemCategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemCategoryRelation create
   */
  export type ItemCategoryRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategoryRelation.
     */
    data: XOR<ItemCategoryRelationCreateInput, ItemCategoryRelationUncheckedCreateInput>
  }

  /**
   * ItemCategoryRelation createMany
   */
  export type ItemCategoryRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategoryRelations.
     */
    data: ItemCategoryRelationCreateManyInput | ItemCategoryRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategoryRelation createManyAndReturn
   */
  export type ItemCategoryRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategoryRelations.
     */
    data: ItemCategoryRelationCreateManyInput | ItemCategoryRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategoryRelation update
   */
  export type ItemCategoryRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategoryRelation.
     */
    data: XOR<ItemCategoryRelationUpdateInput, ItemCategoryRelationUncheckedUpdateInput>
    /**
     * Choose, which ItemCategoryRelation to update.
     */
    where: ItemCategoryRelationWhereUniqueInput
  }

  /**
   * ItemCategoryRelation updateMany
   */
  export type ItemCategoryRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategoryRelations.
     */
    data: XOR<ItemCategoryRelationUpdateManyMutationInput, ItemCategoryRelationUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategoryRelations to update
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * Limit how many ItemCategoryRelations to update.
     */
    limit?: number
  }

  /**
   * ItemCategoryRelation updateManyAndReturn
   */
  export type ItemCategoryRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategoryRelations.
     */
    data: XOR<ItemCategoryRelationUpdateManyMutationInput, ItemCategoryRelationUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategoryRelations to update
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * Limit how many ItemCategoryRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategoryRelation upsert
   */
  export type ItemCategoryRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategoryRelation to update in case it exists.
     */
    where: ItemCategoryRelationWhereUniqueInput
    /**
     * In case the ItemCategoryRelation found by the `where` argument doesn't exist, create a new ItemCategoryRelation with this data.
     */
    create: XOR<ItemCategoryRelationCreateInput, ItemCategoryRelationUncheckedCreateInput>
    /**
     * In case the ItemCategoryRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryRelationUpdateInput, ItemCategoryRelationUncheckedUpdateInput>
  }

  /**
   * ItemCategoryRelation delete
   */
  export type ItemCategoryRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
    /**
     * Filter which ItemCategoryRelation to delete.
     */
    where: ItemCategoryRelationWhereUniqueInput
  }

  /**
   * ItemCategoryRelation deleteMany
   */
  export type ItemCategoryRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategoryRelations to delete
     */
    where?: ItemCategoryRelationWhereInput
    /**
     * Limit how many ItemCategoryRelations to delete.
     */
    limit?: number
  }

  /**
   * ItemCategoryRelation without action
   */
  export type ItemCategoryRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryRelation
     */
    select?: ItemCategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryRelation
     */
    omit?: ItemCategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryRelationInclude<ExtArgs> | null
  }


  /**
   * Model ItemSubcategoryRelation
   */

  export type AggregateItemSubcategoryRelation = {
    _count: ItemSubcategoryRelationCountAggregateOutputType | null
    _min: ItemSubcategoryRelationMinAggregateOutputType | null
    _max: ItemSubcategoryRelationMaxAggregateOutputType | null
  }

  export type ItemSubcategoryRelationMinAggregateOutputType = {
    itemCode: string | null
    subcategoryCode: string | null
  }

  export type ItemSubcategoryRelationMaxAggregateOutputType = {
    itemCode: string | null
    subcategoryCode: string | null
  }

  export type ItemSubcategoryRelationCountAggregateOutputType = {
    itemCode: number
    subcategoryCode: number
    _all: number
  }


  export type ItemSubcategoryRelationMinAggregateInputType = {
    itemCode?: true
    subcategoryCode?: true
  }

  export type ItemSubcategoryRelationMaxAggregateInputType = {
    itemCode?: true
    subcategoryCode?: true
  }

  export type ItemSubcategoryRelationCountAggregateInputType = {
    itemCode?: true
    subcategoryCode?: true
    _all?: true
  }

  export type ItemSubcategoryRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSubcategoryRelation to aggregate.
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategoryRelations to fetch.
     */
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemSubcategoryRelations
    **/
    _count?: true | ItemSubcategoryRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemSubcategoryRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemSubcategoryRelationMaxAggregateInputType
  }

  export type GetItemSubcategoryRelationAggregateType<T extends ItemSubcategoryRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateItemSubcategoryRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemSubcategoryRelation[P]>
      : GetScalarType<T[P], AggregateItemSubcategoryRelation[P]>
  }




  export type ItemSubcategoryRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSubcategoryRelationWhereInput
    orderBy?: ItemSubcategoryRelationOrderByWithAggregationInput | ItemSubcategoryRelationOrderByWithAggregationInput[]
    by: ItemSubcategoryRelationScalarFieldEnum[] | ItemSubcategoryRelationScalarFieldEnum
    having?: ItemSubcategoryRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemSubcategoryRelationCountAggregateInputType | true
    _min?: ItemSubcategoryRelationMinAggregateInputType
    _max?: ItemSubcategoryRelationMaxAggregateInputType
  }

  export type ItemSubcategoryRelationGroupByOutputType = {
    itemCode: string
    subcategoryCode: string
    _count: ItemSubcategoryRelationCountAggregateOutputType | null
    _min: ItemSubcategoryRelationMinAggregateOutputType | null
    _max: ItemSubcategoryRelationMaxAggregateOutputType | null
  }

  type GetItemSubcategoryRelationGroupByPayload<T extends ItemSubcategoryRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemSubcategoryRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemSubcategoryRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemSubcategoryRelationGroupByOutputType[P]>
            : GetScalarType<T[P], ItemSubcategoryRelationGroupByOutputType[P]>
        }
      >
    >


  export type ItemSubcategoryRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    subcategoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSubcategoryRelation"]>

  export type ItemSubcategoryRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    subcategoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSubcategoryRelation"]>

  export type ItemSubcategoryRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    subcategoryCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSubcategoryRelation"]>

  export type ItemSubcategoryRelationSelectScalar = {
    itemCode?: boolean
    subcategoryCode?: boolean
  }

  export type ItemSubcategoryRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemCode" | "subcategoryCode", ExtArgs["result"]["itemSubcategoryRelation"]>
  export type ItemSubcategoryRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ItemSubcategoryRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ItemSubcategoryRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }

  export type $ItemSubcategoryRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemSubcategoryRelation"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      subcategory: Prisma.$ItemSubcategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemCode: string
      subcategoryCode: string
    }, ExtArgs["result"]["itemSubcategoryRelation"]>
    composites: {}
  }

  type ItemSubcategoryRelationGetPayload<S extends boolean | null | undefined | ItemSubcategoryRelationDefaultArgs> = $Result.GetResult<Prisma.$ItemSubcategoryRelationPayload, S>

  type ItemSubcategoryRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemSubcategoryRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemSubcategoryRelationCountAggregateInputType | true
    }

  export interface ItemSubcategoryRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemSubcategoryRelation'], meta: { name: 'ItemSubcategoryRelation' } }
    /**
     * Find zero or one ItemSubcategoryRelation that matches the filter.
     * @param {ItemSubcategoryRelationFindUniqueArgs} args - Arguments to find a ItemSubcategoryRelation
     * @example
     * // Get one ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemSubcategoryRelationFindUniqueArgs>(args: SelectSubset<T, ItemSubcategoryRelationFindUniqueArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemSubcategoryRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemSubcategoryRelationFindUniqueOrThrowArgs} args - Arguments to find a ItemSubcategoryRelation
     * @example
     * // Get one ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemSubcategoryRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemSubcategoryRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSubcategoryRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationFindFirstArgs} args - Arguments to find a ItemSubcategoryRelation
     * @example
     * // Get one ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemSubcategoryRelationFindFirstArgs>(args?: SelectSubset<T, ItemSubcategoryRelationFindFirstArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSubcategoryRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationFindFirstOrThrowArgs} args - Arguments to find a ItemSubcategoryRelation
     * @example
     * // Get one ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemSubcategoryRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemSubcategoryRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemSubcategoryRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemSubcategoryRelations
     * const itemSubcategoryRelations = await prisma.itemSubcategoryRelation.findMany()
     * 
     * // Get first 10 ItemSubcategoryRelations
     * const itemSubcategoryRelations = await prisma.itemSubcategoryRelation.findMany({ take: 10 })
     * 
     * // Only select the `itemCode`
     * const itemSubcategoryRelationWithItemCodeOnly = await prisma.itemSubcategoryRelation.findMany({ select: { itemCode: true } })
     * 
     */
    findMany<T extends ItemSubcategoryRelationFindManyArgs>(args?: SelectSubset<T, ItemSubcategoryRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemSubcategoryRelation.
     * @param {ItemSubcategoryRelationCreateArgs} args - Arguments to create a ItemSubcategoryRelation.
     * @example
     * // Create one ItemSubcategoryRelation
     * const ItemSubcategoryRelation = await prisma.itemSubcategoryRelation.create({
     *   data: {
     *     // ... data to create a ItemSubcategoryRelation
     *   }
     * })
     * 
     */
    create<T extends ItemSubcategoryRelationCreateArgs>(args: SelectSubset<T, ItemSubcategoryRelationCreateArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemSubcategoryRelations.
     * @param {ItemSubcategoryRelationCreateManyArgs} args - Arguments to create many ItemSubcategoryRelations.
     * @example
     * // Create many ItemSubcategoryRelations
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemSubcategoryRelationCreateManyArgs>(args?: SelectSubset<T, ItemSubcategoryRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemSubcategoryRelations and returns the data saved in the database.
     * @param {ItemSubcategoryRelationCreateManyAndReturnArgs} args - Arguments to create many ItemSubcategoryRelations.
     * @example
     * // Create many ItemSubcategoryRelations
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemSubcategoryRelations and only return the `itemCode`
     * const itemSubcategoryRelationWithItemCodeOnly = await prisma.itemSubcategoryRelation.createManyAndReturn({
     *   select: { itemCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemSubcategoryRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemSubcategoryRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemSubcategoryRelation.
     * @param {ItemSubcategoryRelationDeleteArgs} args - Arguments to delete one ItemSubcategoryRelation.
     * @example
     * // Delete one ItemSubcategoryRelation
     * const ItemSubcategoryRelation = await prisma.itemSubcategoryRelation.delete({
     *   where: {
     *     // ... filter to delete one ItemSubcategoryRelation
     *   }
     * })
     * 
     */
    delete<T extends ItemSubcategoryRelationDeleteArgs>(args: SelectSubset<T, ItemSubcategoryRelationDeleteArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemSubcategoryRelation.
     * @param {ItemSubcategoryRelationUpdateArgs} args - Arguments to update one ItemSubcategoryRelation.
     * @example
     * // Update one ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemSubcategoryRelationUpdateArgs>(args: SelectSubset<T, ItemSubcategoryRelationUpdateArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemSubcategoryRelations.
     * @param {ItemSubcategoryRelationDeleteManyArgs} args - Arguments to filter ItemSubcategoryRelations to delete.
     * @example
     * // Delete a few ItemSubcategoryRelations
     * const { count } = await prisma.itemSubcategoryRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemSubcategoryRelationDeleteManyArgs>(args?: SelectSubset<T, ItemSubcategoryRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSubcategoryRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemSubcategoryRelations
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemSubcategoryRelationUpdateManyArgs>(args: SelectSubset<T, ItemSubcategoryRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSubcategoryRelations and returns the data updated in the database.
     * @param {ItemSubcategoryRelationUpdateManyAndReturnArgs} args - Arguments to update many ItemSubcategoryRelations.
     * @example
     * // Update many ItemSubcategoryRelations
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemSubcategoryRelations and only return the `itemCode`
     * const itemSubcategoryRelationWithItemCodeOnly = await prisma.itemSubcategoryRelation.updateManyAndReturn({
     *   select: { itemCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemSubcategoryRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemSubcategoryRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemSubcategoryRelation.
     * @param {ItemSubcategoryRelationUpsertArgs} args - Arguments to update or create a ItemSubcategoryRelation.
     * @example
     * // Update or create a ItemSubcategoryRelation
     * const itemSubcategoryRelation = await prisma.itemSubcategoryRelation.upsert({
     *   create: {
     *     // ... data to create a ItemSubcategoryRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemSubcategoryRelation we want to update
     *   }
     * })
     */
    upsert<T extends ItemSubcategoryRelationUpsertArgs>(args: SelectSubset<T, ItemSubcategoryRelationUpsertArgs<ExtArgs>>): Prisma__ItemSubcategoryRelationClient<$Result.GetResult<Prisma.$ItemSubcategoryRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemSubcategoryRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationCountArgs} args - Arguments to filter ItemSubcategoryRelations to count.
     * @example
     * // Count the number of ItemSubcategoryRelations
     * const count = await prisma.itemSubcategoryRelation.count({
     *   where: {
     *     // ... the filter for the ItemSubcategoryRelations we want to count
     *   }
     * })
    **/
    count<T extends ItemSubcategoryRelationCountArgs>(
      args?: Subset<T, ItemSubcategoryRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemSubcategoryRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemSubcategoryRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemSubcategoryRelationAggregateArgs>(args: Subset<T, ItemSubcategoryRelationAggregateArgs>): Prisma.PrismaPromise<GetItemSubcategoryRelationAggregateType<T>>

    /**
     * Group by ItemSubcategoryRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSubcategoryRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemSubcategoryRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemSubcategoryRelationGroupByArgs['orderBy'] }
        : { orderBy?: ItemSubcategoryRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemSubcategoryRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemSubcategoryRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemSubcategoryRelation model
   */
  readonly fields: ItemSubcategoryRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemSubcategoryRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemSubcategoryRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ItemSubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategoryDefaultArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemSubcategoryRelation model
   */
  interface ItemSubcategoryRelationFieldRefs {
    readonly itemCode: FieldRef<"ItemSubcategoryRelation", 'String'>
    readonly subcategoryCode: FieldRef<"ItemSubcategoryRelation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemSubcategoryRelation findUnique
   */
  export type ItemSubcategoryRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategoryRelation to fetch.
     */
    where: ItemSubcategoryRelationWhereUniqueInput
  }

  /**
   * ItemSubcategoryRelation findUniqueOrThrow
   */
  export type ItemSubcategoryRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategoryRelation to fetch.
     */
    where: ItemSubcategoryRelationWhereUniqueInput
  }

  /**
   * ItemSubcategoryRelation findFirst
   */
  export type ItemSubcategoryRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategoryRelation to fetch.
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategoryRelations to fetch.
     */
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSubcategoryRelations.
     */
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSubcategoryRelations.
     */
    distinct?: ItemSubcategoryRelationScalarFieldEnum | ItemSubcategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemSubcategoryRelation findFirstOrThrow
   */
  export type ItemSubcategoryRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategoryRelation to fetch.
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategoryRelations to fetch.
     */
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSubcategoryRelations.
     */
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategoryRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSubcategoryRelations.
     */
    distinct?: ItemSubcategoryRelationScalarFieldEnum | ItemSubcategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemSubcategoryRelation findMany
   */
  export type ItemSubcategoryRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter, which ItemSubcategoryRelations to fetch.
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSubcategoryRelations to fetch.
     */
    orderBy?: ItemSubcategoryRelationOrderByWithRelationInput | ItemSubcategoryRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemSubcategoryRelations.
     */
    cursor?: ItemSubcategoryRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSubcategoryRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSubcategoryRelations.
     */
    skip?: number
    distinct?: ItemSubcategoryRelationScalarFieldEnum | ItemSubcategoryRelationScalarFieldEnum[]
  }

  /**
   * ItemSubcategoryRelation create
   */
  export type ItemSubcategoryRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemSubcategoryRelation.
     */
    data: XOR<ItemSubcategoryRelationCreateInput, ItemSubcategoryRelationUncheckedCreateInput>
  }

  /**
   * ItemSubcategoryRelation createMany
   */
  export type ItemSubcategoryRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemSubcategoryRelations.
     */
    data: ItemSubcategoryRelationCreateManyInput | ItemSubcategoryRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemSubcategoryRelation createManyAndReturn
   */
  export type ItemSubcategoryRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * The data used to create many ItemSubcategoryRelations.
     */
    data: ItemSubcategoryRelationCreateManyInput | ItemSubcategoryRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSubcategoryRelation update
   */
  export type ItemSubcategoryRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemSubcategoryRelation.
     */
    data: XOR<ItemSubcategoryRelationUpdateInput, ItemSubcategoryRelationUncheckedUpdateInput>
    /**
     * Choose, which ItemSubcategoryRelation to update.
     */
    where: ItemSubcategoryRelationWhereUniqueInput
  }

  /**
   * ItemSubcategoryRelation updateMany
   */
  export type ItemSubcategoryRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemSubcategoryRelations.
     */
    data: XOR<ItemSubcategoryRelationUpdateManyMutationInput, ItemSubcategoryRelationUncheckedUpdateManyInput>
    /**
     * Filter which ItemSubcategoryRelations to update
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * Limit how many ItemSubcategoryRelations to update.
     */
    limit?: number
  }

  /**
   * ItemSubcategoryRelation updateManyAndReturn
   */
  export type ItemSubcategoryRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * The data used to update ItemSubcategoryRelations.
     */
    data: XOR<ItemSubcategoryRelationUpdateManyMutationInput, ItemSubcategoryRelationUncheckedUpdateManyInput>
    /**
     * Filter which ItemSubcategoryRelations to update
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * Limit how many ItemSubcategoryRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSubcategoryRelation upsert
   */
  export type ItemSubcategoryRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemSubcategoryRelation to update in case it exists.
     */
    where: ItemSubcategoryRelationWhereUniqueInput
    /**
     * In case the ItemSubcategoryRelation found by the `where` argument doesn't exist, create a new ItemSubcategoryRelation with this data.
     */
    create: XOR<ItemSubcategoryRelationCreateInput, ItemSubcategoryRelationUncheckedCreateInput>
    /**
     * In case the ItemSubcategoryRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemSubcategoryRelationUpdateInput, ItemSubcategoryRelationUncheckedUpdateInput>
  }

  /**
   * ItemSubcategoryRelation delete
   */
  export type ItemSubcategoryRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
    /**
     * Filter which ItemSubcategoryRelation to delete.
     */
    where: ItemSubcategoryRelationWhereUniqueInput
  }

  /**
   * ItemSubcategoryRelation deleteMany
   */
  export type ItemSubcategoryRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSubcategoryRelations to delete
     */
    where?: ItemSubcategoryRelationWhereInput
    /**
     * Limit how many ItemSubcategoryRelations to delete.
     */
    limit?: number
  }

  /**
   * ItemSubcategoryRelation without action
   */
  export type ItemSubcategoryRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSubcategoryRelation
     */
    select?: ItemSubcategoryRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSubcategoryRelation
     */
    omit?: ItemSubcategoryRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSubcategoryRelationInclude<ExtArgs> | null
  }


  /**
   * Model ItemPrice
   */

  export type AggregateItemPrice = {
    _count: ItemPriceCountAggregateOutputType | null
    _avg: ItemPriceAvgAggregateOutputType | null
    _sum: ItemPriceSumAggregateOutputType | null
    _min: ItemPriceMinAggregateOutputType | null
    _max: ItemPriceMaxAggregateOutputType | null
  }

  export type ItemPriceAvgAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ItemPriceSumAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ItemPriceMinAggregateOutputType = {
    itemCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ItemPriceMaxAggregateOutputType = {
    itemCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ItemPriceCountAggregateOutputType = {
    itemCode: number
    priceUsd: number
    priceRub: number
    _all: number
  }


  export type ItemPriceAvgAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type ItemPriceSumAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type ItemPriceMinAggregateInputType = {
    itemCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type ItemPriceMaxAggregateInputType = {
    itemCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type ItemPriceCountAggregateInputType = {
    itemCode?: true
    priceUsd?: true
    priceRub?: true
    _all?: true
  }

  export type ItemPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPrice to aggregate.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemPrices
    **/
    _count?: true | ItemPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemPriceMaxAggregateInputType
  }

  export type GetItemPriceAggregateType<T extends ItemPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateItemPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemPrice[P]>
      : GetScalarType<T[P], AggregateItemPrice[P]>
  }




  export type ItemPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemPriceWhereInput
    orderBy?: ItemPriceOrderByWithAggregationInput | ItemPriceOrderByWithAggregationInput[]
    by: ItemPriceScalarFieldEnum[] | ItemPriceScalarFieldEnum
    having?: ItemPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemPriceCountAggregateInputType | true
    _avg?: ItemPriceAvgAggregateInputType
    _sum?: ItemPriceSumAggregateInputType
    _min?: ItemPriceMinAggregateInputType
    _max?: ItemPriceMaxAggregateInputType
  }

  export type ItemPriceGroupByOutputType = {
    itemCode: string
    priceUsd: Decimal | null
    priceRub: Decimal | null
    _count: ItemPriceCountAggregateOutputType | null
    _avg: ItemPriceAvgAggregateOutputType | null
    _sum: ItemPriceSumAggregateOutputType | null
    _min: ItemPriceMinAggregateOutputType | null
    _max: ItemPriceMaxAggregateOutputType | null
  }

  type GetItemPriceGroupByPayload<T extends ItemPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemPriceGroupByOutputType[P]>
            : GetScalarType<T[P], ItemPriceGroupByOutputType[P]>
        }
      >
    >


  export type ItemPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemPrice"]>

  export type ItemPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemPrice"]>

  export type ItemPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemPrice"]>

  export type ItemPriceSelectScalar = {
    itemCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
  }

  export type ItemPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemCode" | "priceUsd" | "priceRub", ExtArgs["result"]["itemPrice"]>
  export type ItemPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemPrice"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemCode: string
      priceUsd: Prisma.Decimal | null
      priceRub: Prisma.Decimal | null
    }, ExtArgs["result"]["itemPrice"]>
    composites: {}
  }

  type ItemPriceGetPayload<S extends boolean | null | undefined | ItemPriceDefaultArgs> = $Result.GetResult<Prisma.$ItemPricePayload, S>

  type ItemPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemPriceCountAggregateInputType | true
    }

  export interface ItemPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemPrice'], meta: { name: 'ItemPrice' } }
    /**
     * Find zero or one ItemPrice that matches the filter.
     * @param {ItemPriceFindUniqueArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemPriceFindUniqueArgs>(args: SelectSubset<T, ItemPriceFindUniqueArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemPriceFindUniqueOrThrowArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindFirstArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemPriceFindFirstArgs>(args?: SelectSubset<T, ItemPriceFindFirstArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindFirstOrThrowArgs} args - Arguments to find a ItemPrice
     * @example
     * // Get one ItemPrice
     * const itemPrice = await prisma.itemPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemPrices
     * const itemPrices = await prisma.itemPrice.findMany()
     * 
     * // Get first 10 ItemPrices
     * const itemPrices = await prisma.itemPrice.findMany({ take: 10 })
     * 
     * // Only select the `itemCode`
     * const itemPriceWithItemCodeOnly = await prisma.itemPrice.findMany({ select: { itemCode: true } })
     * 
     */
    findMany<T extends ItemPriceFindManyArgs>(args?: SelectSubset<T, ItemPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemPrice.
     * @param {ItemPriceCreateArgs} args - Arguments to create a ItemPrice.
     * @example
     * // Create one ItemPrice
     * const ItemPrice = await prisma.itemPrice.create({
     *   data: {
     *     // ... data to create a ItemPrice
     *   }
     * })
     * 
     */
    create<T extends ItemPriceCreateArgs>(args: SelectSubset<T, ItemPriceCreateArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemPrices.
     * @param {ItemPriceCreateManyArgs} args - Arguments to create many ItemPrices.
     * @example
     * // Create many ItemPrices
     * const itemPrice = await prisma.itemPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemPriceCreateManyArgs>(args?: SelectSubset<T, ItemPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemPrices and returns the data saved in the database.
     * @param {ItemPriceCreateManyAndReturnArgs} args - Arguments to create many ItemPrices.
     * @example
     * // Create many ItemPrices
     * const itemPrice = await prisma.itemPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemPrices and only return the `itemCode`
     * const itemPriceWithItemCodeOnly = await prisma.itemPrice.createManyAndReturn({
     *   select: { itemCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemPrice.
     * @param {ItemPriceDeleteArgs} args - Arguments to delete one ItemPrice.
     * @example
     * // Delete one ItemPrice
     * const ItemPrice = await prisma.itemPrice.delete({
     *   where: {
     *     // ... filter to delete one ItemPrice
     *   }
     * })
     * 
     */
    delete<T extends ItemPriceDeleteArgs>(args: SelectSubset<T, ItemPriceDeleteArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemPrice.
     * @param {ItemPriceUpdateArgs} args - Arguments to update one ItemPrice.
     * @example
     * // Update one ItemPrice
     * const itemPrice = await prisma.itemPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemPriceUpdateArgs>(args: SelectSubset<T, ItemPriceUpdateArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemPrices.
     * @param {ItemPriceDeleteManyArgs} args - Arguments to filter ItemPrices to delete.
     * @example
     * // Delete a few ItemPrices
     * const { count } = await prisma.itemPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemPriceDeleteManyArgs>(args?: SelectSubset<T, ItemPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemPrices
     * const itemPrice = await prisma.itemPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemPriceUpdateManyArgs>(args: SelectSubset<T, ItemPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemPrices and returns the data updated in the database.
     * @param {ItemPriceUpdateManyAndReturnArgs} args - Arguments to update many ItemPrices.
     * @example
     * // Update many ItemPrices
     * const itemPrice = await prisma.itemPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemPrices and only return the `itemCode`
     * const itemPriceWithItemCodeOnly = await prisma.itemPrice.updateManyAndReturn({
     *   select: { itemCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemPrice.
     * @param {ItemPriceUpsertArgs} args - Arguments to update or create a ItemPrice.
     * @example
     * // Update or create a ItemPrice
     * const itemPrice = await prisma.itemPrice.upsert({
     *   create: {
     *     // ... data to create a ItemPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemPrice we want to update
     *   }
     * })
     */
    upsert<T extends ItemPriceUpsertArgs>(args: SelectSubset<T, ItemPriceUpsertArgs<ExtArgs>>): Prisma__ItemPriceClient<$Result.GetResult<Prisma.$ItemPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceCountArgs} args - Arguments to filter ItemPrices to count.
     * @example
     * // Count the number of ItemPrices
     * const count = await prisma.itemPrice.count({
     *   where: {
     *     // ... the filter for the ItemPrices we want to count
     *   }
     * })
    **/
    count<T extends ItemPriceCountArgs>(
      args?: Subset<T, ItemPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemPriceAggregateArgs>(args: Subset<T, ItemPriceAggregateArgs>): Prisma.PrismaPromise<GetItemPriceAggregateType<T>>

    /**
     * Group by ItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemPriceGroupByArgs['orderBy'] }
        : { orderBy?: ItemPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemPrice model
   */
  readonly fields: ItemPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemPrice model
   */
  interface ItemPriceFieldRefs {
    readonly itemCode: FieldRef<"ItemPrice", 'String'>
    readonly priceUsd: FieldRef<"ItemPrice", 'Decimal'>
    readonly priceRub: FieldRef<"ItemPrice", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ItemPrice findUnique
   */
  export type ItemPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice findUniqueOrThrow
   */
  export type ItemPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice findFirst
   */
  export type ItemPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPrices.
     */
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice findFirstOrThrow
   */
  export type ItemPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrice to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPrices.
     */
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice findMany
   */
  export type ItemPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which ItemPrices to fetch.
     */
    where?: ItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPrices to fetch.
     */
    orderBy?: ItemPriceOrderByWithRelationInput | ItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemPrices.
     */
    cursor?: ItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPrices.
     */
    skip?: number
    distinct?: ItemPriceScalarFieldEnum | ItemPriceScalarFieldEnum[]
  }

  /**
   * ItemPrice create
   */
  export type ItemPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemPrice.
     */
    data: XOR<ItemPriceCreateInput, ItemPriceUncheckedCreateInput>
  }

  /**
   * ItemPrice createMany
   */
  export type ItemPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemPrices.
     */
    data: ItemPriceCreateManyInput | ItemPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemPrice createManyAndReturn
   */
  export type ItemPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * The data used to create many ItemPrices.
     */
    data: ItemPriceCreateManyInput | ItemPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemPrice update
   */
  export type ItemPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemPrice.
     */
    data: XOR<ItemPriceUpdateInput, ItemPriceUncheckedUpdateInput>
    /**
     * Choose, which ItemPrice to update.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice updateMany
   */
  export type ItemPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemPrices.
     */
    data: XOR<ItemPriceUpdateManyMutationInput, ItemPriceUncheckedUpdateManyInput>
    /**
     * Filter which ItemPrices to update
     */
    where?: ItemPriceWhereInput
    /**
     * Limit how many ItemPrices to update.
     */
    limit?: number
  }

  /**
   * ItemPrice updateManyAndReturn
   */
  export type ItemPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * The data used to update ItemPrices.
     */
    data: XOR<ItemPriceUpdateManyMutationInput, ItemPriceUncheckedUpdateManyInput>
    /**
     * Filter which ItemPrices to update
     */
    where?: ItemPriceWhereInput
    /**
     * Limit how many ItemPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemPrice upsert
   */
  export type ItemPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemPrice to update in case it exists.
     */
    where: ItemPriceWhereUniqueInput
    /**
     * In case the ItemPrice found by the `where` argument doesn't exist, create a new ItemPrice with this data.
     */
    create: XOR<ItemPriceCreateInput, ItemPriceUncheckedCreateInput>
    /**
     * In case the ItemPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemPriceUpdateInput, ItemPriceUncheckedUpdateInput>
  }

  /**
   * ItemPrice delete
   */
  export type ItemPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
    /**
     * Filter which ItemPrice to delete.
     */
    where: ItemPriceWhereUniqueInput
  }

  /**
   * ItemPrice deleteMany
   */
  export type ItemPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPrices to delete
     */
    where?: ItemPriceWhereInput
    /**
     * Limit how many ItemPrices to delete.
     */
    limit?: number
  }

  /**
   * ItemPrice without action
   */
  export type ItemPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPrice
     */
    select?: ItemPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemPrice
     */
    omit?: ItemPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemPriceInclude<ExtArgs> | null
  }


  /**
   * Model ItemSupplier
   */

  export type AggregateItemSupplier = {
    _count: ItemSupplierCountAggregateOutputType | null
    _min: ItemSupplierMinAggregateOutputType | null
    _max: ItemSupplierMaxAggregateOutputType | null
  }

  export type ItemSupplierMinAggregateOutputType = {
    itemCode: string | null
    supplierCode: string | null
  }

  export type ItemSupplierMaxAggregateOutputType = {
    itemCode: string | null
    supplierCode: string | null
  }

  export type ItemSupplierCountAggregateOutputType = {
    itemCode: number
    supplierCode: number
    _all: number
  }


  export type ItemSupplierMinAggregateInputType = {
    itemCode?: true
    supplierCode?: true
  }

  export type ItemSupplierMaxAggregateInputType = {
    itemCode?: true
    supplierCode?: true
  }

  export type ItemSupplierCountAggregateInputType = {
    itemCode?: true
    supplierCode?: true
    _all?: true
  }

  export type ItemSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSupplier to aggregate.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemSuppliers
    **/
    _count?: true | ItemSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemSupplierMaxAggregateInputType
  }

  export type GetItemSupplierAggregateType<T extends ItemSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateItemSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemSupplier[P]>
      : GetScalarType<T[P], AggregateItemSupplier[P]>
  }




  export type ItemSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithAggregationInput | ItemSupplierOrderByWithAggregationInput[]
    by: ItemSupplierScalarFieldEnum[] | ItemSupplierScalarFieldEnum
    having?: ItemSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemSupplierCountAggregateInputType | true
    _min?: ItemSupplierMinAggregateInputType
    _max?: ItemSupplierMaxAggregateInputType
  }

  export type ItemSupplierGroupByOutputType = {
    itemCode: string
    supplierCode: string
    _count: ItemSupplierCountAggregateOutputType | null
    _min: ItemSupplierMinAggregateOutputType | null
    _max: ItemSupplierMaxAggregateOutputType | null
  }

  type GetItemSupplierGroupByPayload<T extends ItemSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], ItemSupplierGroupByOutputType[P]>
        }
      >
    >


  export type ItemSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    supplierCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    supplierCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemCode?: boolean
    supplierCode?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectScalar = {
    itemCode?: boolean
    supplierCode?: boolean
  }

  export type ItemSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemCode" | "supplierCode", ExtArgs["result"]["itemSupplier"]>
  export type ItemSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type ItemSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type ItemSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $ItemSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemSupplier"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemCode: string
      supplierCode: string
    }, ExtArgs["result"]["itemSupplier"]>
    composites: {}
  }

  type ItemSupplierGetPayload<S extends boolean | null | undefined | ItemSupplierDefaultArgs> = $Result.GetResult<Prisma.$ItemSupplierPayload, S>

  type ItemSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemSupplierCountAggregateInputType | true
    }

  export interface ItemSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemSupplier'], meta: { name: 'ItemSupplier' } }
    /**
     * Find zero or one ItemSupplier that matches the filter.
     * @param {ItemSupplierFindUniqueArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemSupplierFindUniqueArgs>(args: SelectSubset<T, ItemSupplierFindUniqueArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemSupplierFindUniqueOrThrowArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindFirstArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemSupplierFindFirstArgs>(args?: SelectSubset<T, ItemSupplierFindFirstArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindFirstOrThrowArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemSuppliers
     * const itemSuppliers = await prisma.itemSupplier.findMany()
     * 
     * // Get first 10 ItemSuppliers
     * const itemSuppliers = await prisma.itemSupplier.findMany({ take: 10 })
     * 
     * // Only select the `itemCode`
     * const itemSupplierWithItemCodeOnly = await prisma.itemSupplier.findMany({ select: { itemCode: true } })
     * 
     */
    findMany<T extends ItemSupplierFindManyArgs>(args?: SelectSubset<T, ItemSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemSupplier.
     * @param {ItemSupplierCreateArgs} args - Arguments to create a ItemSupplier.
     * @example
     * // Create one ItemSupplier
     * const ItemSupplier = await prisma.itemSupplier.create({
     *   data: {
     *     // ... data to create a ItemSupplier
     *   }
     * })
     * 
     */
    create<T extends ItemSupplierCreateArgs>(args: SelectSubset<T, ItemSupplierCreateArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemSuppliers.
     * @param {ItemSupplierCreateManyArgs} args - Arguments to create many ItemSuppliers.
     * @example
     * // Create many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemSupplierCreateManyArgs>(args?: SelectSubset<T, ItemSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemSuppliers and returns the data saved in the database.
     * @param {ItemSupplierCreateManyAndReturnArgs} args - Arguments to create many ItemSuppliers.
     * @example
     * // Create many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemSuppliers and only return the `itemCode`
     * const itemSupplierWithItemCodeOnly = await prisma.itemSupplier.createManyAndReturn({
     *   select: { itemCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemSupplier.
     * @param {ItemSupplierDeleteArgs} args - Arguments to delete one ItemSupplier.
     * @example
     * // Delete one ItemSupplier
     * const ItemSupplier = await prisma.itemSupplier.delete({
     *   where: {
     *     // ... filter to delete one ItemSupplier
     *   }
     * })
     * 
     */
    delete<T extends ItemSupplierDeleteArgs>(args: SelectSubset<T, ItemSupplierDeleteArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemSupplier.
     * @param {ItemSupplierUpdateArgs} args - Arguments to update one ItemSupplier.
     * @example
     * // Update one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemSupplierUpdateArgs>(args: SelectSubset<T, ItemSupplierUpdateArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemSuppliers.
     * @param {ItemSupplierDeleteManyArgs} args - Arguments to filter ItemSuppliers to delete.
     * @example
     * // Delete a few ItemSuppliers
     * const { count } = await prisma.itemSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemSupplierDeleteManyArgs>(args?: SelectSubset<T, ItemSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemSupplierUpdateManyArgs>(args: SelectSubset<T, ItemSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSuppliers and returns the data updated in the database.
     * @param {ItemSupplierUpdateManyAndReturnArgs} args - Arguments to update many ItemSuppliers.
     * @example
     * // Update many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemSuppliers and only return the `itemCode`
     * const itemSupplierWithItemCodeOnly = await prisma.itemSupplier.updateManyAndReturn({
     *   select: { itemCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemSupplier.
     * @param {ItemSupplierUpsertArgs} args - Arguments to update or create a ItemSupplier.
     * @example
     * // Update or create a ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.upsert({
     *   create: {
     *     // ... data to create a ItemSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemSupplier we want to update
     *   }
     * })
     */
    upsert<T extends ItemSupplierUpsertArgs>(args: SelectSubset<T, ItemSupplierUpsertArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierCountArgs} args - Arguments to filter ItemSuppliers to count.
     * @example
     * // Count the number of ItemSuppliers
     * const count = await prisma.itemSupplier.count({
     *   where: {
     *     // ... the filter for the ItemSuppliers we want to count
     *   }
     * })
    **/
    count<T extends ItemSupplierCountArgs>(
      args?: Subset<T, ItemSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemSupplierAggregateArgs>(args: Subset<T, ItemSupplierAggregateArgs>): Prisma.PrismaPromise<GetItemSupplierAggregateType<T>>

    /**
     * Group by ItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemSupplierGroupByArgs['orderBy'] }
        : { orderBy?: ItemSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemSupplier model
   */
  readonly fields: ItemSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemSupplier model
   */
  interface ItemSupplierFieldRefs {
    readonly itemCode: FieldRef<"ItemSupplier", 'String'>
    readonly supplierCode: FieldRef<"ItemSupplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemSupplier findUnique
   */
  export type ItemSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier findUniqueOrThrow
   */
  export type ItemSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier findFirst
   */
  export type ItemSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSuppliers.
     */
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier findFirstOrThrow
   */
  export type ItemSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSuppliers.
     */
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier findMany
   */
  export type ItemSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSuppliers to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier create
   */
  export type ItemSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemSupplier.
     */
    data: XOR<ItemSupplierCreateInput, ItemSupplierUncheckedCreateInput>
  }

  /**
   * ItemSupplier createMany
   */
  export type ItemSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemSuppliers.
     */
    data: ItemSupplierCreateManyInput | ItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemSupplier createManyAndReturn
   */
  export type ItemSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many ItemSuppliers.
     */
    data: ItemSupplierCreateManyInput | ItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSupplier update
   */
  export type ItemSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemSupplier.
     */
    data: XOR<ItemSupplierUpdateInput, ItemSupplierUncheckedUpdateInput>
    /**
     * Choose, which ItemSupplier to update.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier updateMany
   */
  export type ItemSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemSuppliers.
     */
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which ItemSuppliers to update
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to update.
     */
    limit?: number
  }

  /**
   * ItemSupplier updateManyAndReturn
   */
  export type ItemSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to update ItemSuppliers.
     */
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which ItemSuppliers to update
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSupplier upsert
   */
  export type ItemSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemSupplier to update in case it exists.
     */
    where: ItemSupplierWhereUniqueInput
    /**
     * In case the ItemSupplier found by the `where` argument doesn't exist, create a new ItemSupplier with this data.
     */
    create: XOR<ItemSupplierCreateInput, ItemSupplierUncheckedCreateInput>
    /**
     * In case the ItemSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemSupplierUpdateInput, ItemSupplierUncheckedUpdateInput>
  }

  /**
   * ItemSupplier delete
   */
  export type ItemSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter which ItemSupplier to delete.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier deleteMany
   */
  export type ItemSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSuppliers to delete
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to delete.
     */
    limit?: number
  }

  /**
   * ItemSupplier without action
   */
  export type ItemSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategorySubcategory
   */

  export type AggregateItemCategorySubcategory = {
    _count: ItemCategorySubcategoryCountAggregateOutputType | null
    _min: ItemCategorySubcategoryMinAggregateOutputType | null
    _max: ItemCategorySubcategoryMaxAggregateOutputType | null
  }

  export type ItemCategorySubcategoryMinAggregateOutputType = {
    categoryCode: string | null
    subcategoryCode: string | null
  }

  export type ItemCategorySubcategoryMaxAggregateOutputType = {
    categoryCode: string | null
    subcategoryCode: string | null
  }

  export type ItemCategorySubcategoryCountAggregateOutputType = {
    categoryCode: number
    subcategoryCode: number
    _all: number
  }


  export type ItemCategorySubcategoryMinAggregateInputType = {
    categoryCode?: true
    subcategoryCode?: true
  }

  export type ItemCategorySubcategoryMaxAggregateInputType = {
    categoryCode?: true
    subcategoryCode?: true
  }

  export type ItemCategorySubcategoryCountAggregateInputType = {
    categoryCode?: true
    subcategoryCode?: true
    _all?: true
  }

  export type ItemCategorySubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategorySubcategory to aggregate.
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategorySubcategories to fetch.
     */
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategorySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategorySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategorySubcategories
    **/
    _count?: true | ItemCategorySubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategorySubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategorySubcategoryMaxAggregateInputType
  }

  export type GetItemCategorySubcategoryAggregateType<T extends ItemCategorySubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategorySubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategorySubcategory[P]>
      : GetScalarType<T[P], AggregateItemCategorySubcategory[P]>
  }




  export type ItemCategorySubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategorySubcategoryWhereInput
    orderBy?: ItemCategorySubcategoryOrderByWithAggregationInput | ItemCategorySubcategoryOrderByWithAggregationInput[]
    by: ItemCategorySubcategoryScalarFieldEnum[] | ItemCategorySubcategoryScalarFieldEnum
    having?: ItemCategorySubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategorySubcategoryCountAggregateInputType | true
    _min?: ItemCategorySubcategoryMinAggregateInputType
    _max?: ItemCategorySubcategoryMaxAggregateInputType
  }

  export type ItemCategorySubcategoryGroupByOutputType = {
    categoryCode: string
    subcategoryCode: string
    _count: ItemCategorySubcategoryCountAggregateOutputType | null
    _min: ItemCategorySubcategoryMinAggregateOutputType | null
    _max: ItemCategorySubcategoryMaxAggregateOutputType | null
  }

  type GetItemCategorySubcategoryGroupByPayload<T extends ItemCategorySubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategorySubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategorySubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategorySubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategorySubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryCode?: boolean
    subcategoryCode?: boolean
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategorySubcategory"]>

  export type ItemCategorySubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryCode?: boolean
    subcategoryCode?: boolean
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategorySubcategory"]>

  export type ItemCategorySubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryCode?: boolean
    subcategoryCode?: boolean
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategorySubcategory"]>

  export type ItemCategorySubcategorySelectScalar = {
    categoryCode?: boolean
    subcategoryCode?: boolean
  }

  export type ItemCategorySubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"categoryCode" | "subcategoryCode", ExtArgs["result"]["itemCategorySubcategory"]>
  export type ItemCategorySubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ItemCategorySubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ItemCategorySubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }

  export type $ItemCategorySubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategorySubcategory"
    objects: {
      category: Prisma.$ItemCategoryPayload<ExtArgs>
      subcategory: Prisma.$ItemSubcategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      categoryCode: string
      subcategoryCode: string
    }, ExtArgs["result"]["itemCategorySubcategory"]>
    composites: {}
  }

  type ItemCategorySubcategoryGetPayload<S extends boolean | null | undefined | ItemCategorySubcategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategorySubcategoryPayload, S>

  type ItemCategorySubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategorySubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategorySubcategoryCountAggregateInputType | true
    }

  export interface ItemCategorySubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategorySubcategory'], meta: { name: 'ItemCategorySubcategory' } }
    /**
     * Find zero or one ItemCategorySubcategory that matches the filter.
     * @param {ItemCategorySubcategoryFindUniqueArgs} args - Arguments to find a ItemCategorySubcategory
     * @example
     * // Get one ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategorySubcategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategorySubcategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategorySubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategorySubcategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategorySubcategory
     * @example
     * // Get one ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategorySubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategorySubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategorySubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryFindFirstArgs} args - Arguments to find a ItemCategorySubcategory
     * @example
     * // Get one ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategorySubcategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategorySubcategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategorySubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategorySubcategory
     * @example
     * // Get one ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategorySubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategorySubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategorySubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategorySubcategories
     * const itemCategorySubcategories = await prisma.itemCategorySubcategory.findMany()
     * 
     * // Get first 10 ItemCategorySubcategories
     * const itemCategorySubcategories = await prisma.itemCategorySubcategory.findMany({ take: 10 })
     * 
     * // Only select the `categoryCode`
     * const itemCategorySubcategoryWithCategoryCodeOnly = await prisma.itemCategorySubcategory.findMany({ select: { categoryCode: true } })
     * 
     */
    findMany<T extends ItemCategorySubcategoryFindManyArgs>(args?: SelectSubset<T, ItemCategorySubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategorySubcategory.
     * @param {ItemCategorySubcategoryCreateArgs} args - Arguments to create a ItemCategorySubcategory.
     * @example
     * // Create one ItemCategorySubcategory
     * const ItemCategorySubcategory = await prisma.itemCategorySubcategory.create({
     *   data: {
     *     // ... data to create a ItemCategorySubcategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategorySubcategoryCreateArgs>(args: SelectSubset<T, ItemCategorySubcategoryCreateArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategorySubcategories.
     * @param {ItemCategorySubcategoryCreateManyArgs} args - Arguments to create many ItemCategorySubcategories.
     * @example
     * // Create many ItemCategorySubcategories
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategorySubcategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategorySubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategorySubcategories and returns the data saved in the database.
     * @param {ItemCategorySubcategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategorySubcategories.
     * @example
     * // Create many ItemCategorySubcategories
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategorySubcategories and only return the `categoryCode`
     * const itemCategorySubcategoryWithCategoryCodeOnly = await prisma.itemCategorySubcategory.createManyAndReturn({
     *   select: { categoryCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategorySubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategorySubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategorySubcategory.
     * @param {ItemCategorySubcategoryDeleteArgs} args - Arguments to delete one ItemCategorySubcategory.
     * @example
     * // Delete one ItemCategorySubcategory
     * const ItemCategorySubcategory = await prisma.itemCategorySubcategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategorySubcategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategorySubcategoryDeleteArgs>(args: SelectSubset<T, ItemCategorySubcategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategorySubcategory.
     * @param {ItemCategorySubcategoryUpdateArgs} args - Arguments to update one ItemCategorySubcategory.
     * @example
     * // Update one ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategorySubcategoryUpdateArgs>(args: SelectSubset<T, ItemCategorySubcategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategorySubcategories.
     * @param {ItemCategorySubcategoryDeleteManyArgs} args - Arguments to filter ItemCategorySubcategories to delete.
     * @example
     * // Delete a few ItemCategorySubcategories
     * const { count } = await prisma.itemCategorySubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategorySubcategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategorySubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategorySubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategorySubcategories
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategorySubcategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategorySubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategorySubcategories and returns the data updated in the database.
     * @param {ItemCategorySubcategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemCategorySubcategories.
     * @example
     * // Update many ItemCategorySubcategories
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategorySubcategories and only return the `categoryCode`
     * const itemCategorySubcategoryWithCategoryCodeOnly = await prisma.itemCategorySubcategory.updateManyAndReturn({
     *   select: { categoryCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategorySubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategorySubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategorySubcategory.
     * @param {ItemCategorySubcategoryUpsertArgs} args - Arguments to update or create a ItemCategorySubcategory.
     * @example
     * // Update or create a ItemCategorySubcategory
     * const itemCategorySubcategory = await prisma.itemCategorySubcategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategorySubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategorySubcategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategorySubcategoryUpsertArgs>(args: SelectSubset<T, ItemCategorySubcategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategorySubcategoryClient<$Result.GetResult<Prisma.$ItemCategorySubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategorySubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryCountArgs} args - Arguments to filter ItemCategorySubcategories to count.
     * @example
     * // Count the number of ItemCategorySubcategories
     * const count = await prisma.itemCategorySubcategory.count({
     *   where: {
     *     // ... the filter for the ItemCategorySubcategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategorySubcategoryCountArgs>(
      args?: Subset<T, ItemCategorySubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategorySubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategorySubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategorySubcategoryAggregateArgs>(args: Subset<T, ItemCategorySubcategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategorySubcategoryAggregateType<T>>

    /**
     * Group by ItemCategorySubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategorySubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategorySubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategorySubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategorySubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategorySubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategorySubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategorySubcategory model
   */
  readonly fields: ItemCategorySubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategorySubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategorySubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ItemSubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategoryDefaultArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategorySubcategory model
   */
  interface ItemCategorySubcategoryFieldRefs {
    readonly categoryCode: FieldRef<"ItemCategorySubcategory", 'String'>
    readonly subcategoryCode: FieldRef<"ItemCategorySubcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategorySubcategory findUnique
   */
  export type ItemCategorySubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategorySubcategory to fetch.
     */
    where: ItemCategorySubcategoryWhereUniqueInput
  }

  /**
   * ItemCategorySubcategory findUniqueOrThrow
   */
  export type ItemCategorySubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategorySubcategory to fetch.
     */
    where: ItemCategorySubcategoryWhereUniqueInput
  }

  /**
   * ItemCategorySubcategory findFirst
   */
  export type ItemCategorySubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategorySubcategory to fetch.
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategorySubcategories to fetch.
     */
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategorySubcategories.
     */
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategorySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategorySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategorySubcategories.
     */
    distinct?: ItemCategorySubcategoryScalarFieldEnum | ItemCategorySubcategoryScalarFieldEnum[]
  }

  /**
   * ItemCategorySubcategory findFirstOrThrow
   */
  export type ItemCategorySubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategorySubcategory to fetch.
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategorySubcategories to fetch.
     */
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategorySubcategories.
     */
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategorySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategorySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategorySubcategories.
     */
    distinct?: ItemCategorySubcategoryScalarFieldEnum | ItemCategorySubcategoryScalarFieldEnum[]
  }

  /**
   * ItemCategorySubcategory findMany
   */
  export type ItemCategorySubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategorySubcategories to fetch.
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategorySubcategories to fetch.
     */
    orderBy?: ItemCategorySubcategoryOrderByWithRelationInput | ItemCategorySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategorySubcategories.
     */
    cursor?: ItemCategorySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategorySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategorySubcategories.
     */
    skip?: number
    distinct?: ItemCategorySubcategoryScalarFieldEnum | ItemCategorySubcategoryScalarFieldEnum[]
  }

  /**
   * ItemCategorySubcategory create
   */
  export type ItemCategorySubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategorySubcategory.
     */
    data: XOR<ItemCategorySubcategoryCreateInput, ItemCategorySubcategoryUncheckedCreateInput>
  }

  /**
   * ItemCategorySubcategory createMany
   */
  export type ItemCategorySubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategorySubcategories.
     */
    data: ItemCategorySubcategoryCreateManyInput | ItemCategorySubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategorySubcategory createManyAndReturn
   */
  export type ItemCategorySubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategorySubcategories.
     */
    data: ItemCategorySubcategoryCreateManyInput | ItemCategorySubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategorySubcategory update
   */
  export type ItemCategorySubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategorySubcategory.
     */
    data: XOR<ItemCategorySubcategoryUpdateInput, ItemCategorySubcategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategorySubcategory to update.
     */
    where: ItemCategorySubcategoryWhereUniqueInput
  }

  /**
   * ItemCategorySubcategory updateMany
   */
  export type ItemCategorySubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategorySubcategories.
     */
    data: XOR<ItemCategorySubcategoryUpdateManyMutationInput, ItemCategorySubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategorySubcategories to update
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * Limit how many ItemCategorySubcategories to update.
     */
    limit?: number
  }

  /**
   * ItemCategorySubcategory updateManyAndReturn
   */
  export type ItemCategorySubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategorySubcategories.
     */
    data: XOR<ItemCategorySubcategoryUpdateManyMutationInput, ItemCategorySubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategorySubcategories to update
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * Limit how many ItemCategorySubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategorySubcategory upsert
   */
  export type ItemCategorySubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategorySubcategory to update in case it exists.
     */
    where: ItemCategorySubcategoryWhereUniqueInput
    /**
     * In case the ItemCategorySubcategory found by the `where` argument doesn't exist, create a new ItemCategorySubcategory with this data.
     */
    create: XOR<ItemCategorySubcategoryCreateInput, ItemCategorySubcategoryUncheckedCreateInput>
    /**
     * In case the ItemCategorySubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategorySubcategoryUpdateInput, ItemCategorySubcategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategorySubcategory delete
   */
  export type ItemCategorySubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategorySubcategory to delete.
     */
    where: ItemCategorySubcategoryWhereUniqueInput
  }

  /**
   * ItemCategorySubcategory deleteMany
   */
  export type ItemCategorySubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategorySubcategories to delete
     */
    where?: ItemCategorySubcategoryWhereInput
    /**
     * Limit how many ItemCategorySubcategories to delete.
     */
    limit?: number
  }

  /**
   * ItemCategorySubcategory without action
   */
  export type ItemCategorySubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategorySubcategory
     */
    select?: ItemCategorySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategorySubcategory
     */
    omit?: ItemCategorySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategorySubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model CabinetCategory
   */

  export type AggregateCabinetCategory = {
    _count: CabinetCategoryCountAggregateOutputType | null
    _min: CabinetCategoryMinAggregateOutputType | null
    _max: CabinetCategoryMaxAggregateOutputType | null
  }

  export type CabinetCategoryMinAggregateOutputType = {
    cabinetCode: string | null
    categoryCode: string | null
  }

  export type CabinetCategoryMaxAggregateOutputType = {
    cabinetCode: string | null
    categoryCode: string | null
  }

  export type CabinetCategoryCountAggregateOutputType = {
    cabinetCode: number
    categoryCode: number
    _all: number
  }


  export type CabinetCategoryMinAggregateInputType = {
    cabinetCode?: true
    categoryCode?: true
  }

  export type CabinetCategoryMaxAggregateInputType = {
    cabinetCode?: true
    categoryCode?: true
  }

  export type CabinetCategoryCountAggregateInputType = {
    cabinetCode?: true
    categoryCode?: true
    _all?: true
  }

  export type CabinetCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetCategory to aggregate.
     */
    where?: CabinetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCategories to fetch.
     */
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetCategories
    **/
    _count?: true | CabinetCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetCategoryMaxAggregateInputType
  }

  export type GetCabinetCategoryAggregateType<T extends CabinetCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetCategory[P]>
      : GetScalarType<T[P], AggregateCabinetCategory[P]>
  }




  export type CabinetCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCategoryWhereInput
    orderBy?: CabinetCategoryOrderByWithAggregationInput | CabinetCategoryOrderByWithAggregationInput[]
    by: CabinetCategoryScalarFieldEnum[] | CabinetCategoryScalarFieldEnum
    having?: CabinetCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetCategoryCountAggregateInputType | true
    _min?: CabinetCategoryMinAggregateInputType
    _max?: CabinetCategoryMaxAggregateInputType
  }

  export type CabinetCategoryGroupByOutputType = {
    cabinetCode: string
    categoryCode: string
    _count: CabinetCategoryCountAggregateOutputType | null
    _min: CabinetCategoryMinAggregateOutputType | null
    _max: CabinetCategoryMaxAggregateOutputType | null
  }

  type GetCabinetCategoryGroupByPayload<T extends CabinetCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CabinetCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    categoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCategory"]>

  export type CabinetCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    categoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCategory"]>

  export type CabinetCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    categoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCategory"]>

  export type CabinetCategorySelectScalar = {
    cabinetCode?: boolean
    categoryCode?: boolean
  }

  export type CabinetCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "categoryCode", ExtArgs["result"]["cabinetCategory"]>
  export type CabinetCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type CabinetCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type CabinetCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $CabinetCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetCategory"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      category: Prisma.$ItemCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      categoryCode: string
    }, ExtArgs["result"]["cabinetCategory"]>
    composites: {}
  }

  type CabinetCategoryGetPayload<S extends boolean | null | undefined | CabinetCategoryDefaultArgs> = $Result.GetResult<Prisma.$CabinetCategoryPayload, S>

  type CabinetCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetCategoryCountAggregateInputType | true
    }

  export interface CabinetCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetCategory'], meta: { name: 'CabinetCategory' } }
    /**
     * Find zero or one CabinetCategory that matches the filter.
     * @param {CabinetCategoryFindUniqueArgs} args - Arguments to find a CabinetCategory
     * @example
     * // Get one CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetCategoryFindUniqueArgs>(args: SelectSubset<T, CabinetCategoryFindUniqueArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetCategoryFindUniqueOrThrowArgs} args - Arguments to find a CabinetCategory
     * @example
     * // Get one CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryFindFirstArgs} args - Arguments to find a CabinetCategory
     * @example
     * // Get one CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetCategoryFindFirstArgs>(args?: SelectSubset<T, CabinetCategoryFindFirstArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryFindFirstOrThrowArgs} args - Arguments to find a CabinetCategory
     * @example
     * // Get one CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetCategories
     * const cabinetCategories = await prisma.cabinetCategory.findMany()
     * 
     * // Get first 10 CabinetCategories
     * const cabinetCategories = await prisma.cabinetCategory.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetCategoryWithCabinetCodeOnly = await prisma.cabinetCategory.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetCategoryFindManyArgs>(args?: SelectSubset<T, CabinetCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetCategory.
     * @param {CabinetCategoryCreateArgs} args - Arguments to create a CabinetCategory.
     * @example
     * // Create one CabinetCategory
     * const CabinetCategory = await prisma.cabinetCategory.create({
     *   data: {
     *     // ... data to create a CabinetCategory
     *   }
     * })
     * 
     */
    create<T extends CabinetCategoryCreateArgs>(args: SelectSubset<T, CabinetCategoryCreateArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetCategories.
     * @param {CabinetCategoryCreateManyArgs} args - Arguments to create many CabinetCategories.
     * @example
     * // Create many CabinetCategories
     * const cabinetCategory = await prisma.cabinetCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetCategoryCreateManyArgs>(args?: SelectSubset<T, CabinetCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetCategories and returns the data saved in the database.
     * @param {CabinetCategoryCreateManyAndReturnArgs} args - Arguments to create many CabinetCategories.
     * @example
     * // Create many CabinetCategories
     * const cabinetCategory = await prisma.cabinetCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetCategories and only return the `cabinetCode`
     * const cabinetCategoryWithCabinetCodeOnly = await prisma.cabinetCategory.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetCategory.
     * @param {CabinetCategoryDeleteArgs} args - Arguments to delete one CabinetCategory.
     * @example
     * // Delete one CabinetCategory
     * const CabinetCategory = await prisma.cabinetCategory.delete({
     *   where: {
     *     // ... filter to delete one CabinetCategory
     *   }
     * })
     * 
     */
    delete<T extends CabinetCategoryDeleteArgs>(args: SelectSubset<T, CabinetCategoryDeleteArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetCategory.
     * @param {CabinetCategoryUpdateArgs} args - Arguments to update one CabinetCategory.
     * @example
     * // Update one CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetCategoryUpdateArgs>(args: SelectSubset<T, CabinetCategoryUpdateArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetCategories.
     * @param {CabinetCategoryDeleteManyArgs} args - Arguments to filter CabinetCategories to delete.
     * @example
     * // Delete a few CabinetCategories
     * const { count } = await prisma.cabinetCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetCategoryDeleteManyArgs>(args?: SelectSubset<T, CabinetCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetCategories
     * const cabinetCategory = await prisma.cabinetCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetCategoryUpdateManyArgs>(args: SelectSubset<T, CabinetCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetCategories and returns the data updated in the database.
     * @param {CabinetCategoryUpdateManyAndReturnArgs} args - Arguments to update many CabinetCategories.
     * @example
     * // Update many CabinetCategories
     * const cabinetCategory = await prisma.cabinetCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetCategories and only return the `cabinetCode`
     * const cabinetCategoryWithCabinetCodeOnly = await prisma.cabinetCategory.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetCategory.
     * @param {CabinetCategoryUpsertArgs} args - Arguments to update or create a CabinetCategory.
     * @example
     * // Update or create a CabinetCategory
     * const cabinetCategory = await prisma.cabinetCategory.upsert({
     *   create: {
     *     // ... data to create a CabinetCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetCategory we want to update
     *   }
     * })
     */
    upsert<T extends CabinetCategoryUpsertArgs>(args: SelectSubset<T, CabinetCategoryUpsertArgs<ExtArgs>>): Prisma__CabinetCategoryClient<$Result.GetResult<Prisma.$CabinetCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryCountArgs} args - Arguments to filter CabinetCategories to count.
     * @example
     * // Count the number of CabinetCategories
     * const count = await prisma.cabinetCategory.count({
     *   where: {
     *     // ... the filter for the CabinetCategories we want to count
     *   }
     * })
    **/
    count<T extends CabinetCategoryCountArgs>(
      args?: Subset<T, CabinetCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetCategoryAggregateArgs>(args: Subset<T, CabinetCategoryAggregateArgs>): Prisma.PrismaPromise<GetCabinetCategoryAggregateType<T>>

    /**
     * Group by CabinetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CabinetCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetCategory model
   */
  readonly fields: CabinetCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetCategory model
   */
  interface CabinetCategoryFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetCategory", 'String'>
    readonly categoryCode: FieldRef<"CabinetCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetCategory findUnique
   */
  export type CabinetCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCategory to fetch.
     */
    where: CabinetCategoryWhereUniqueInput
  }

  /**
   * CabinetCategory findUniqueOrThrow
   */
  export type CabinetCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCategory to fetch.
     */
    where: CabinetCategoryWhereUniqueInput
  }

  /**
   * CabinetCategory findFirst
   */
  export type CabinetCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCategory to fetch.
     */
    where?: CabinetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCategories to fetch.
     */
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetCategories.
     */
    cursor?: CabinetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetCategories.
     */
    distinct?: CabinetCategoryScalarFieldEnum | CabinetCategoryScalarFieldEnum[]
  }

  /**
   * CabinetCategory findFirstOrThrow
   */
  export type CabinetCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCategory to fetch.
     */
    where?: CabinetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCategories to fetch.
     */
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetCategories.
     */
    cursor?: CabinetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetCategories.
     */
    distinct?: CabinetCategoryScalarFieldEnum | CabinetCategoryScalarFieldEnum[]
  }

  /**
   * CabinetCategory findMany
   */
  export type CabinetCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCategories to fetch.
     */
    where?: CabinetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCategories to fetch.
     */
    orderBy?: CabinetCategoryOrderByWithRelationInput | CabinetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetCategories.
     */
    cursor?: CabinetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCategories.
     */
    skip?: number
    distinct?: CabinetCategoryScalarFieldEnum | CabinetCategoryScalarFieldEnum[]
  }

  /**
   * CabinetCategory create
   */
  export type CabinetCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetCategory.
     */
    data: XOR<CabinetCategoryCreateInput, CabinetCategoryUncheckedCreateInput>
  }

  /**
   * CabinetCategory createMany
   */
  export type CabinetCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetCategories.
     */
    data: CabinetCategoryCreateManyInput | CabinetCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetCategory createManyAndReturn
   */
  export type CabinetCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetCategories.
     */
    data: CabinetCategoryCreateManyInput | CabinetCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetCategory update
   */
  export type CabinetCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetCategory.
     */
    data: XOR<CabinetCategoryUpdateInput, CabinetCategoryUncheckedUpdateInput>
    /**
     * Choose, which CabinetCategory to update.
     */
    where: CabinetCategoryWhereUniqueInput
  }

  /**
   * CabinetCategory updateMany
   */
  export type CabinetCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetCategories.
     */
    data: XOR<CabinetCategoryUpdateManyMutationInput, CabinetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CabinetCategories to update
     */
    where?: CabinetCategoryWhereInput
    /**
     * Limit how many CabinetCategories to update.
     */
    limit?: number
  }

  /**
   * CabinetCategory updateManyAndReturn
   */
  export type CabinetCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * The data used to update CabinetCategories.
     */
    data: XOR<CabinetCategoryUpdateManyMutationInput, CabinetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CabinetCategories to update
     */
    where?: CabinetCategoryWhereInput
    /**
     * Limit how many CabinetCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetCategory upsert
   */
  export type CabinetCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetCategory to update in case it exists.
     */
    where: CabinetCategoryWhereUniqueInput
    /**
     * In case the CabinetCategory found by the `where` argument doesn't exist, create a new CabinetCategory with this data.
     */
    create: XOR<CabinetCategoryCreateInput, CabinetCategoryUncheckedCreateInput>
    /**
     * In case the CabinetCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetCategoryUpdateInput, CabinetCategoryUncheckedUpdateInput>
  }

  /**
   * CabinetCategory delete
   */
  export type CabinetCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
    /**
     * Filter which CabinetCategory to delete.
     */
    where: CabinetCategoryWhereUniqueInput
  }

  /**
   * CabinetCategory deleteMany
   */
  export type CabinetCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetCategories to delete
     */
    where?: CabinetCategoryWhereInput
    /**
     * Limit how many CabinetCategories to delete.
     */
    limit?: number
  }

  /**
   * CabinetCategory without action
   */
  export type CabinetCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCategory
     */
    select?: CabinetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCategory
     */
    omit?: CabinetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CabinetSubcategory
   */

  export type AggregateCabinetSubcategory = {
    _count: CabinetSubcategoryCountAggregateOutputType | null
    _min: CabinetSubcategoryMinAggregateOutputType | null
    _max: CabinetSubcategoryMaxAggregateOutputType | null
  }

  export type CabinetSubcategoryMinAggregateOutputType = {
    cabinetCode: string | null
    subcategoryCode: string | null
  }

  export type CabinetSubcategoryMaxAggregateOutputType = {
    cabinetCode: string | null
    subcategoryCode: string | null
  }

  export type CabinetSubcategoryCountAggregateOutputType = {
    cabinetCode: number
    subcategoryCode: number
    _all: number
  }


  export type CabinetSubcategoryMinAggregateInputType = {
    cabinetCode?: true
    subcategoryCode?: true
  }

  export type CabinetSubcategoryMaxAggregateInputType = {
    cabinetCode?: true
    subcategoryCode?: true
  }

  export type CabinetSubcategoryCountAggregateInputType = {
    cabinetCode?: true
    subcategoryCode?: true
    _all?: true
  }

  export type CabinetSubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSubcategory to aggregate.
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSubcategories to fetch.
     */
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetSubcategories
    **/
    _count?: true | CabinetSubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetSubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetSubcategoryMaxAggregateInputType
  }

  export type GetCabinetSubcategoryAggregateType<T extends CabinetSubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetSubcategory[P]>
      : GetScalarType<T[P], AggregateCabinetSubcategory[P]>
  }




  export type CabinetSubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSubcategoryWhereInput
    orderBy?: CabinetSubcategoryOrderByWithAggregationInput | CabinetSubcategoryOrderByWithAggregationInput[]
    by: CabinetSubcategoryScalarFieldEnum[] | CabinetSubcategoryScalarFieldEnum
    having?: CabinetSubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetSubcategoryCountAggregateInputType | true
    _min?: CabinetSubcategoryMinAggregateInputType
    _max?: CabinetSubcategoryMaxAggregateInputType
  }

  export type CabinetSubcategoryGroupByOutputType = {
    cabinetCode: string
    subcategoryCode: string
    _count: CabinetSubcategoryCountAggregateOutputType | null
    _min: CabinetSubcategoryMinAggregateOutputType | null
    _max: CabinetSubcategoryMaxAggregateOutputType | null
  }

  type GetCabinetSubcategoryGroupByPayload<T extends CabinetSubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetSubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetSubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetSubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetSubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type CabinetSubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    subcategoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSubcategory"]>

  export type CabinetSubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    subcategoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSubcategory"]>

  export type CabinetSubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    subcategoryCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSubcategory"]>

  export type CabinetSubcategorySelectScalar = {
    cabinetCode?: boolean
    subcategoryCode?: boolean
  }

  export type CabinetSubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "subcategoryCode", ExtArgs["result"]["cabinetSubcategory"]>
  export type CabinetSubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type CabinetSubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type CabinetSubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }

  export type $CabinetSubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetSubcategory"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      subcategory: Prisma.$ItemSubcategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      subcategoryCode: string
    }, ExtArgs["result"]["cabinetSubcategory"]>
    composites: {}
  }

  type CabinetSubcategoryGetPayload<S extends boolean | null | undefined | CabinetSubcategoryDefaultArgs> = $Result.GetResult<Prisma.$CabinetSubcategoryPayload, S>

  type CabinetSubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetSubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetSubcategoryCountAggregateInputType | true
    }

  export interface CabinetSubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetSubcategory'], meta: { name: 'CabinetSubcategory' } }
    /**
     * Find zero or one CabinetSubcategory that matches the filter.
     * @param {CabinetSubcategoryFindUniqueArgs} args - Arguments to find a CabinetSubcategory
     * @example
     * // Get one CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetSubcategoryFindUniqueArgs>(args: SelectSubset<T, CabinetSubcategoryFindUniqueArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetSubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetSubcategoryFindUniqueOrThrowArgs} args - Arguments to find a CabinetSubcategory
     * @example
     * // Get one CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetSubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetSubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryFindFirstArgs} args - Arguments to find a CabinetSubcategory
     * @example
     * // Get one CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetSubcategoryFindFirstArgs>(args?: SelectSubset<T, CabinetSubcategoryFindFirstArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryFindFirstOrThrowArgs} args - Arguments to find a CabinetSubcategory
     * @example
     * // Get one CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetSubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetSubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetSubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetSubcategories
     * const cabinetSubcategories = await prisma.cabinetSubcategory.findMany()
     * 
     * // Get first 10 CabinetSubcategories
     * const cabinetSubcategories = await prisma.cabinetSubcategory.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetSubcategoryWithCabinetCodeOnly = await prisma.cabinetSubcategory.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetSubcategoryFindManyArgs>(args?: SelectSubset<T, CabinetSubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetSubcategory.
     * @param {CabinetSubcategoryCreateArgs} args - Arguments to create a CabinetSubcategory.
     * @example
     * // Create one CabinetSubcategory
     * const CabinetSubcategory = await prisma.cabinetSubcategory.create({
     *   data: {
     *     // ... data to create a CabinetSubcategory
     *   }
     * })
     * 
     */
    create<T extends CabinetSubcategoryCreateArgs>(args: SelectSubset<T, CabinetSubcategoryCreateArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetSubcategories.
     * @param {CabinetSubcategoryCreateManyArgs} args - Arguments to create many CabinetSubcategories.
     * @example
     * // Create many CabinetSubcategories
     * const cabinetSubcategory = await prisma.cabinetSubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetSubcategoryCreateManyArgs>(args?: SelectSubset<T, CabinetSubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetSubcategories and returns the data saved in the database.
     * @param {CabinetSubcategoryCreateManyAndReturnArgs} args - Arguments to create many CabinetSubcategories.
     * @example
     * // Create many CabinetSubcategories
     * const cabinetSubcategory = await prisma.cabinetSubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetSubcategories and only return the `cabinetCode`
     * const cabinetSubcategoryWithCabinetCodeOnly = await prisma.cabinetSubcategory.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetSubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetSubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetSubcategory.
     * @param {CabinetSubcategoryDeleteArgs} args - Arguments to delete one CabinetSubcategory.
     * @example
     * // Delete one CabinetSubcategory
     * const CabinetSubcategory = await prisma.cabinetSubcategory.delete({
     *   where: {
     *     // ... filter to delete one CabinetSubcategory
     *   }
     * })
     * 
     */
    delete<T extends CabinetSubcategoryDeleteArgs>(args: SelectSubset<T, CabinetSubcategoryDeleteArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetSubcategory.
     * @param {CabinetSubcategoryUpdateArgs} args - Arguments to update one CabinetSubcategory.
     * @example
     * // Update one CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetSubcategoryUpdateArgs>(args: SelectSubset<T, CabinetSubcategoryUpdateArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetSubcategories.
     * @param {CabinetSubcategoryDeleteManyArgs} args - Arguments to filter CabinetSubcategories to delete.
     * @example
     * // Delete a few CabinetSubcategories
     * const { count } = await prisma.cabinetSubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetSubcategoryDeleteManyArgs>(args?: SelectSubset<T, CabinetSubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetSubcategories
     * const cabinetSubcategory = await prisma.cabinetSubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetSubcategoryUpdateManyArgs>(args: SelectSubset<T, CabinetSubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSubcategories and returns the data updated in the database.
     * @param {CabinetSubcategoryUpdateManyAndReturnArgs} args - Arguments to update many CabinetSubcategories.
     * @example
     * // Update many CabinetSubcategories
     * const cabinetSubcategory = await prisma.cabinetSubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetSubcategories and only return the `cabinetCode`
     * const cabinetSubcategoryWithCabinetCodeOnly = await prisma.cabinetSubcategory.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetSubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetSubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetSubcategory.
     * @param {CabinetSubcategoryUpsertArgs} args - Arguments to update or create a CabinetSubcategory.
     * @example
     * // Update or create a CabinetSubcategory
     * const cabinetSubcategory = await prisma.cabinetSubcategory.upsert({
     *   create: {
     *     // ... data to create a CabinetSubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetSubcategory we want to update
     *   }
     * })
     */
    upsert<T extends CabinetSubcategoryUpsertArgs>(args: SelectSubset<T, CabinetSubcategoryUpsertArgs<ExtArgs>>): Prisma__CabinetSubcategoryClient<$Result.GetResult<Prisma.$CabinetSubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryCountArgs} args - Arguments to filter CabinetSubcategories to count.
     * @example
     * // Count the number of CabinetSubcategories
     * const count = await prisma.cabinetSubcategory.count({
     *   where: {
     *     // ... the filter for the CabinetSubcategories we want to count
     *   }
     * })
    **/
    count<T extends CabinetSubcategoryCountArgs>(
      args?: Subset<T, CabinetSubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetSubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetSubcategoryAggregateArgs>(args: Subset<T, CabinetSubcategoryAggregateArgs>): Prisma.PrismaPromise<GetCabinetSubcategoryAggregateType<T>>

    /**
     * Group by CabinetSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetSubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetSubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: CabinetSubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetSubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetSubcategory model
   */
  readonly fields: CabinetSubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetSubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetSubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ItemSubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategoryDefaultArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetSubcategory model
   */
  interface CabinetSubcategoryFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetSubcategory", 'String'>
    readonly subcategoryCode: FieldRef<"CabinetSubcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetSubcategory findUnique
   */
  export type CabinetSubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSubcategory to fetch.
     */
    where: CabinetSubcategoryWhereUniqueInput
  }

  /**
   * CabinetSubcategory findUniqueOrThrow
   */
  export type CabinetSubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSubcategory to fetch.
     */
    where: CabinetSubcategoryWhereUniqueInput
  }

  /**
   * CabinetSubcategory findFirst
   */
  export type CabinetSubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSubcategory to fetch.
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSubcategories to fetch.
     */
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSubcategories.
     */
    cursor?: CabinetSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSubcategories.
     */
    distinct?: CabinetSubcategoryScalarFieldEnum | CabinetSubcategoryScalarFieldEnum[]
  }

  /**
   * CabinetSubcategory findFirstOrThrow
   */
  export type CabinetSubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSubcategory to fetch.
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSubcategories to fetch.
     */
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSubcategories.
     */
    cursor?: CabinetSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSubcategories.
     */
    distinct?: CabinetSubcategoryScalarFieldEnum | CabinetSubcategoryScalarFieldEnum[]
  }

  /**
   * CabinetSubcategory findMany
   */
  export type CabinetSubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSubcategories to fetch.
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSubcategories to fetch.
     */
    orderBy?: CabinetSubcategoryOrderByWithRelationInput | CabinetSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetSubcategories.
     */
    cursor?: CabinetSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSubcategories.
     */
    skip?: number
    distinct?: CabinetSubcategoryScalarFieldEnum | CabinetSubcategoryScalarFieldEnum[]
  }

  /**
   * CabinetSubcategory create
   */
  export type CabinetSubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetSubcategory.
     */
    data: XOR<CabinetSubcategoryCreateInput, CabinetSubcategoryUncheckedCreateInput>
  }

  /**
   * CabinetSubcategory createMany
   */
  export type CabinetSubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetSubcategories.
     */
    data: CabinetSubcategoryCreateManyInput | CabinetSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetSubcategory createManyAndReturn
   */
  export type CabinetSubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetSubcategories.
     */
    data: CabinetSubcategoryCreateManyInput | CabinetSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSubcategory update
   */
  export type CabinetSubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetSubcategory.
     */
    data: XOR<CabinetSubcategoryUpdateInput, CabinetSubcategoryUncheckedUpdateInput>
    /**
     * Choose, which CabinetSubcategory to update.
     */
    where: CabinetSubcategoryWhereUniqueInput
  }

  /**
   * CabinetSubcategory updateMany
   */
  export type CabinetSubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetSubcategories.
     */
    data: XOR<CabinetSubcategoryUpdateManyMutationInput, CabinetSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSubcategories to update
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * Limit how many CabinetSubcategories to update.
     */
    limit?: number
  }

  /**
   * CabinetSubcategory updateManyAndReturn
   */
  export type CabinetSubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update CabinetSubcategories.
     */
    data: XOR<CabinetSubcategoryUpdateManyMutationInput, CabinetSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSubcategories to update
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * Limit how many CabinetSubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSubcategory upsert
   */
  export type CabinetSubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetSubcategory to update in case it exists.
     */
    where: CabinetSubcategoryWhereUniqueInput
    /**
     * In case the CabinetSubcategory found by the `where` argument doesn't exist, create a new CabinetSubcategory with this data.
     */
    create: XOR<CabinetSubcategoryCreateInput, CabinetSubcategoryUncheckedCreateInput>
    /**
     * In case the CabinetSubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetSubcategoryUpdateInput, CabinetSubcategoryUncheckedUpdateInput>
  }

  /**
   * CabinetSubcategory delete
   */
  export type CabinetSubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
    /**
     * Filter which CabinetSubcategory to delete.
     */
    where: CabinetSubcategoryWhereUniqueInput
  }

  /**
   * CabinetSubcategory deleteMany
   */
  export type CabinetSubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSubcategories to delete
     */
    where?: CabinetSubcategoryWhereInput
    /**
     * Limit how many CabinetSubcategories to delete.
     */
    limit?: number
  }

  /**
   * CabinetSubcategory without action
   */
  export type CabinetSubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSubcategory
     */
    select?: CabinetSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSubcategory
     */
    omit?: CabinetSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model CabinetLocation
   */

  export type AggregateCabinetLocation = {
    _count: CabinetLocationCountAggregateOutputType | null
    _min: CabinetLocationMinAggregateOutputType | null
    _max: CabinetLocationMaxAggregateOutputType | null
  }

  export type CabinetLocationMinAggregateOutputType = {
    cabinetCode: string | null
    locationCode: string | null
  }

  export type CabinetLocationMaxAggregateOutputType = {
    cabinetCode: string | null
    locationCode: string | null
  }

  export type CabinetLocationCountAggregateOutputType = {
    cabinetCode: number
    locationCode: number
    _all: number
  }


  export type CabinetLocationMinAggregateInputType = {
    cabinetCode?: true
    locationCode?: true
  }

  export type CabinetLocationMaxAggregateInputType = {
    cabinetCode?: true
    locationCode?: true
  }

  export type CabinetLocationCountAggregateInputType = {
    cabinetCode?: true
    locationCode?: true
    _all?: true
  }

  export type CabinetLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetLocation to aggregate.
     */
    where?: CabinetLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetLocations to fetch.
     */
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetLocations
    **/
    _count?: true | CabinetLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetLocationMaxAggregateInputType
  }

  export type GetCabinetLocationAggregateType<T extends CabinetLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetLocation[P]>
      : GetScalarType<T[P], AggregateCabinetLocation[P]>
  }




  export type CabinetLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetLocationWhereInput
    orderBy?: CabinetLocationOrderByWithAggregationInput | CabinetLocationOrderByWithAggregationInput[]
    by: CabinetLocationScalarFieldEnum[] | CabinetLocationScalarFieldEnum
    having?: CabinetLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetLocationCountAggregateInputType | true
    _min?: CabinetLocationMinAggregateInputType
    _max?: CabinetLocationMaxAggregateInputType
  }

  export type CabinetLocationGroupByOutputType = {
    cabinetCode: string
    locationCode: string
    _count: CabinetLocationCountAggregateOutputType | null
    _min: CabinetLocationMinAggregateOutputType | null
    _max: CabinetLocationMaxAggregateOutputType | null
  }

  type GetCabinetLocationGroupByPayload<T extends CabinetLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetLocationGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetLocationGroupByOutputType[P]>
        }
      >
    >


  export type CabinetLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    locationCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetLocation"]>

  export type CabinetLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    locationCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetLocation"]>

  export type CabinetLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    locationCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetLocation"]>

  export type CabinetLocationSelectScalar = {
    cabinetCode?: boolean
    locationCode?: boolean
  }

  export type CabinetLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "locationCode", ExtArgs["result"]["cabinetLocation"]>
  export type CabinetLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type CabinetLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type CabinetLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $CabinetLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetLocation"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      locationCode: string
    }, ExtArgs["result"]["cabinetLocation"]>
    composites: {}
  }

  type CabinetLocationGetPayload<S extends boolean | null | undefined | CabinetLocationDefaultArgs> = $Result.GetResult<Prisma.$CabinetLocationPayload, S>

  type CabinetLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetLocationCountAggregateInputType | true
    }

  export interface CabinetLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetLocation'], meta: { name: 'CabinetLocation' } }
    /**
     * Find zero or one CabinetLocation that matches the filter.
     * @param {CabinetLocationFindUniqueArgs} args - Arguments to find a CabinetLocation
     * @example
     * // Get one CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetLocationFindUniqueArgs>(args: SelectSubset<T, CabinetLocationFindUniqueArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetLocationFindUniqueOrThrowArgs} args - Arguments to find a CabinetLocation
     * @example
     * // Get one CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationFindFirstArgs} args - Arguments to find a CabinetLocation
     * @example
     * // Get one CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetLocationFindFirstArgs>(args?: SelectSubset<T, CabinetLocationFindFirstArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationFindFirstOrThrowArgs} args - Arguments to find a CabinetLocation
     * @example
     * // Get one CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetLocations
     * const cabinetLocations = await prisma.cabinetLocation.findMany()
     * 
     * // Get first 10 CabinetLocations
     * const cabinetLocations = await prisma.cabinetLocation.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetLocationWithCabinetCodeOnly = await prisma.cabinetLocation.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetLocationFindManyArgs>(args?: SelectSubset<T, CabinetLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetLocation.
     * @param {CabinetLocationCreateArgs} args - Arguments to create a CabinetLocation.
     * @example
     * // Create one CabinetLocation
     * const CabinetLocation = await prisma.cabinetLocation.create({
     *   data: {
     *     // ... data to create a CabinetLocation
     *   }
     * })
     * 
     */
    create<T extends CabinetLocationCreateArgs>(args: SelectSubset<T, CabinetLocationCreateArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetLocations.
     * @param {CabinetLocationCreateManyArgs} args - Arguments to create many CabinetLocations.
     * @example
     * // Create many CabinetLocations
     * const cabinetLocation = await prisma.cabinetLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetLocationCreateManyArgs>(args?: SelectSubset<T, CabinetLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetLocations and returns the data saved in the database.
     * @param {CabinetLocationCreateManyAndReturnArgs} args - Arguments to create many CabinetLocations.
     * @example
     * // Create many CabinetLocations
     * const cabinetLocation = await prisma.cabinetLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetLocations and only return the `cabinetCode`
     * const cabinetLocationWithCabinetCodeOnly = await prisma.cabinetLocation.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetLocation.
     * @param {CabinetLocationDeleteArgs} args - Arguments to delete one CabinetLocation.
     * @example
     * // Delete one CabinetLocation
     * const CabinetLocation = await prisma.cabinetLocation.delete({
     *   where: {
     *     // ... filter to delete one CabinetLocation
     *   }
     * })
     * 
     */
    delete<T extends CabinetLocationDeleteArgs>(args: SelectSubset<T, CabinetLocationDeleteArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetLocation.
     * @param {CabinetLocationUpdateArgs} args - Arguments to update one CabinetLocation.
     * @example
     * // Update one CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetLocationUpdateArgs>(args: SelectSubset<T, CabinetLocationUpdateArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetLocations.
     * @param {CabinetLocationDeleteManyArgs} args - Arguments to filter CabinetLocations to delete.
     * @example
     * // Delete a few CabinetLocations
     * const { count } = await prisma.cabinetLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetLocationDeleteManyArgs>(args?: SelectSubset<T, CabinetLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetLocations
     * const cabinetLocation = await prisma.cabinetLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetLocationUpdateManyArgs>(args: SelectSubset<T, CabinetLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetLocations and returns the data updated in the database.
     * @param {CabinetLocationUpdateManyAndReturnArgs} args - Arguments to update many CabinetLocations.
     * @example
     * // Update many CabinetLocations
     * const cabinetLocation = await prisma.cabinetLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetLocations and only return the `cabinetCode`
     * const cabinetLocationWithCabinetCodeOnly = await prisma.cabinetLocation.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetLocation.
     * @param {CabinetLocationUpsertArgs} args - Arguments to update or create a CabinetLocation.
     * @example
     * // Update or create a CabinetLocation
     * const cabinetLocation = await prisma.cabinetLocation.upsert({
     *   create: {
     *     // ... data to create a CabinetLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetLocation we want to update
     *   }
     * })
     */
    upsert<T extends CabinetLocationUpsertArgs>(args: SelectSubset<T, CabinetLocationUpsertArgs<ExtArgs>>): Prisma__CabinetLocationClient<$Result.GetResult<Prisma.$CabinetLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationCountArgs} args - Arguments to filter CabinetLocations to count.
     * @example
     * // Count the number of CabinetLocations
     * const count = await prisma.cabinetLocation.count({
     *   where: {
     *     // ... the filter for the CabinetLocations we want to count
     *   }
     * })
    **/
    count<T extends CabinetLocationCountArgs>(
      args?: Subset<T, CabinetLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetLocationAggregateArgs>(args: Subset<T, CabinetLocationAggregateArgs>): Prisma.PrismaPromise<GetCabinetLocationAggregateType<T>>

    /**
     * Group by CabinetLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetLocationGroupByArgs['orderBy'] }
        : { orderBy?: CabinetLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetLocation model
   */
  readonly fields: CabinetLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetLocation model
   */
  interface CabinetLocationFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetLocation", 'String'>
    readonly locationCode: FieldRef<"CabinetLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetLocation findUnique
   */
  export type CabinetLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter, which CabinetLocation to fetch.
     */
    where: CabinetLocationWhereUniqueInput
  }

  /**
   * CabinetLocation findUniqueOrThrow
   */
  export type CabinetLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter, which CabinetLocation to fetch.
     */
    where: CabinetLocationWhereUniqueInput
  }

  /**
   * CabinetLocation findFirst
   */
  export type CabinetLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter, which CabinetLocation to fetch.
     */
    where?: CabinetLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetLocations to fetch.
     */
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetLocations.
     */
    cursor?: CabinetLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetLocations.
     */
    distinct?: CabinetLocationScalarFieldEnum | CabinetLocationScalarFieldEnum[]
  }

  /**
   * CabinetLocation findFirstOrThrow
   */
  export type CabinetLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter, which CabinetLocation to fetch.
     */
    where?: CabinetLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetLocations to fetch.
     */
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetLocations.
     */
    cursor?: CabinetLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetLocations.
     */
    distinct?: CabinetLocationScalarFieldEnum | CabinetLocationScalarFieldEnum[]
  }

  /**
   * CabinetLocation findMany
   */
  export type CabinetLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter, which CabinetLocations to fetch.
     */
    where?: CabinetLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetLocations to fetch.
     */
    orderBy?: CabinetLocationOrderByWithRelationInput | CabinetLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetLocations.
     */
    cursor?: CabinetLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetLocations.
     */
    skip?: number
    distinct?: CabinetLocationScalarFieldEnum | CabinetLocationScalarFieldEnum[]
  }

  /**
   * CabinetLocation create
   */
  export type CabinetLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetLocation.
     */
    data: XOR<CabinetLocationCreateInput, CabinetLocationUncheckedCreateInput>
  }

  /**
   * CabinetLocation createMany
   */
  export type CabinetLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetLocations.
     */
    data: CabinetLocationCreateManyInput | CabinetLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetLocation createManyAndReturn
   */
  export type CabinetLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetLocations.
     */
    data: CabinetLocationCreateManyInput | CabinetLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetLocation update
   */
  export type CabinetLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetLocation.
     */
    data: XOR<CabinetLocationUpdateInput, CabinetLocationUncheckedUpdateInput>
    /**
     * Choose, which CabinetLocation to update.
     */
    where: CabinetLocationWhereUniqueInput
  }

  /**
   * CabinetLocation updateMany
   */
  export type CabinetLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetLocations.
     */
    data: XOR<CabinetLocationUpdateManyMutationInput, CabinetLocationUncheckedUpdateManyInput>
    /**
     * Filter which CabinetLocations to update
     */
    where?: CabinetLocationWhereInput
    /**
     * Limit how many CabinetLocations to update.
     */
    limit?: number
  }

  /**
   * CabinetLocation updateManyAndReturn
   */
  export type CabinetLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * The data used to update CabinetLocations.
     */
    data: XOR<CabinetLocationUpdateManyMutationInput, CabinetLocationUncheckedUpdateManyInput>
    /**
     * Filter which CabinetLocations to update
     */
    where?: CabinetLocationWhereInput
    /**
     * Limit how many CabinetLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetLocation upsert
   */
  export type CabinetLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetLocation to update in case it exists.
     */
    where: CabinetLocationWhereUniqueInput
    /**
     * In case the CabinetLocation found by the `where` argument doesn't exist, create a new CabinetLocation with this data.
     */
    create: XOR<CabinetLocationCreateInput, CabinetLocationUncheckedCreateInput>
    /**
     * In case the CabinetLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetLocationUpdateInput, CabinetLocationUncheckedUpdateInput>
  }

  /**
   * CabinetLocation delete
   */
  export type CabinetLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
    /**
     * Filter which CabinetLocation to delete.
     */
    where: CabinetLocationWhereUniqueInput
  }

  /**
   * CabinetLocation deleteMany
   */
  export type CabinetLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetLocations to delete
     */
    where?: CabinetLocationWhereInput
    /**
     * Limit how many CabinetLocations to delete.
     */
    limit?: number
  }

  /**
   * CabinetLocation without action
   */
  export type CabinetLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetLocation
     */
    select?: CabinetLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetLocation
     */
    omit?: CabinetLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetLocationInclude<ExtArgs> | null
  }


  /**
   * Model CabinetPlacement
   */

  export type AggregateCabinetPlacement = {
    _count: CabinetPlacementCountAggregateOutputType | null
    _min: CabinetPlacementMinAggregateOutputType | null
    _max: CabinetPlacementMaxAggregateOutputType | null
  }

  export type CabinetPlacementMinAggregateOutputType = {
    cabinetCode: string | null
    placementCode: string | null
  }

  export type CabinetPlacementMaxAggregateOutputType = {
    cabinetCode: string | null
    placementCode: string | null
  }

  export type CabinetPlacementCountAggregateOutputType = {
    cabinetCode: number
    placementCode: number
    _all: number
  }


  export type CabinetPlacementMinAggregateInputType = {
    cabinetCode?: true
    placementCode?: true
  }

  export type CabinetPlacementMaxAggregateInputType = {
    cabinetCode?: true
    placementCode?: true
  }

  export type CabinetPlacementCountAggregateInputType = {
    cabinetCode?: true
    placementCode?: true
    _all?: true
  }

  export type CabinetPlacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPlacement to aggregate.
     */
    where?: CabinetPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPlacements to fetch.
     */
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetPlacements
    **/
    _count?: true | CabinetPlacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetPlacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetPlacementMaxAggregateInputType
  }

  export type GetCabinetPlacementAggregateType<T extends CabinetPlacementAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetPlacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetPlacement[P]>
      : GetScalarType<T[P], AggregateCabinetPlacement[P]>
  }




  export type CabinetPlacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPlacementWhereInput
    orderBy?: CabinetPlacementOrderByWithAggregationInput | CabinetPlacementOrderByWithAggregationInput[]
    by: CabinetPlacementScalarFieldEnum[] | CabinetPlacementScalarFieldEnum
    having?: CabinetPlacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetPlacementCountAggregateInputType | true
    _min?: CabinetPlacementMinAggregateInputType
    _max?: CabinetPlacementMaxAggregateInputType
  }

  export type CabinetPlacementGroupByOutputType = {
    cabinetCode: string
    placementCode: string
    _count: CabinetPlacementCountAggregateOutputType | null
    _min: CabinetPlacementMinAggregateOutputType | null
    _max: CabinetPlacementMaxAggregateOutputType | null
  }

  type GetCabinetPlacementGroupByPayload<T extends CabinetPlacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetPlacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetPlacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetPlacementGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetPlacementGroupByOutputType[P]>
        }
      >
    >


  export type CabinetPlacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    placementCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPlacement"]>

  export type CabinetPlacementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    placementCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPlacement"]>

  export type CabinetPlacementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    placementCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPlacement"]>

  export type CabinetPlacementSelectScalar = {
    cabinetCode?: boolean
    placementCode?: boolean
  }

  export type CabinetPlacementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "placementCode", ExtArgs["result"]["cabinetPlacement"]>
  export type CabinetPlacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }
  export type CabinetPlacementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }
  export type CabinetPlacementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }

  export type $CabinetPlacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetPlacement"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      placement: Prisma.$PlacementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      placementCode: string
    }, ExtArgs["result"]["cabinetPlacement"]>
    composites: {}
  }

  type CabinetPlacementGetPayload<S extends boolean | null | undefined | CabinetPlacementDefaultArgs> = $Result.GetResult<Prisma.$CabinetPlacementPayload, S>

  type CabinetPlacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetPlacementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetPlacementCountAggregateInputType | true
    }

  export interface CabinetPlacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetPlacement'], meta: { name: 'CabinetPlacement' } }
    /**
     * Find zero or one CabinetPlacement that matches the filter.
     * @param {CabinetPlacementFindUniqueArgs} args - Arguments to find a CabinetPlacement
     * @example
     * // Get one CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetPlacementFindUniqueArgs>(args: SelectSubset<T, CabinetPlacementFindUniqueArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetPlacement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetPlacementFindUniqueOrThrowArgs} args - Arguments to find a CabinetPlacement
     * @example
     * // Get one CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetPlacementFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetPlacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPlacement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementFindFirstArgs} args - Arguments to find a CabinetPlacement
     * @example
     * // Get one CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetPlacementFindFirstArgs>(args?: SelectSubset<T, CabinetPlacementFindFirstArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPlacement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementFindFirstOrThrowArgs} args - Arguments to find a CabinetPlacement
     * @example
     * // Get one CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetPlacementFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetPlacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetPlacements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetPlacements
     * const cabinetPlacements = await prisma.cabinetPlacement.findMany()
     * 
     * // Get first 10 CabinetPlacements
     * const cabinetPlacements = await prisma.cabinetPlacement.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetPlacementWithCabinetCodeOnly = await prisma.cabinetPlacement.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetPlacementFindManyArgs>(args?: SelectSubset<T, CabinetPlacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetPlacement.
     * @param {CabinetPlacementCreateArgs} args - Arguments to create a CabinetPlacement.
     * @example
     * // Create one CabinetPlacement
     * const CabinetPlacement = await prisma.cabinetPlacement.create({
     *   data: {
     *     // ... data to create a CabinetPlacement
     *   }
     * })
     * 
     */
    create<T extends CabinetPlacementCreateArgs>(args: SelectSubset<T, CabinetPlacementCreateArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetPlacements.
     * @param {CabinetPlacementCreateManyArgs} args - Arguments to create many CabinetPlacements.
     * @example
     * // Create many CabinetPlacements
     * const cabinetPlacement = await prisma.cabinetPlacement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetPlacementCreateManyArgs>(args?: SelectSubset<T, CabinetPlacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetPlacements and returns the data saved in the database.
     * @param {CabinetPlacementCreateManyAndReturnArgs} args - Arguments to create many CabinetPlacements.
     * @example
     * // Create many CabinetPlacements
     * const cabinetPlacement = await prisma.cabinetPlacement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetPlacements and only return the `cabinetCode`
     * const cabinetPlacementWithCabinetCodeOnly = await prisma.cabinetPlacement.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetPlacementCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetPlacementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetPlacement.
     * @param {CabinetPlacementDeleteArgs} args - Arguments to delete one CabinetPlacement.
     * @example
     * // Delete one CabinetPlacement
     * const CabinetPlacement = await prisma.cabinetPlacement.delete({
     *   where: {
     *     // ... filter to delete one CabinetPlacement
     *   }
     * })
     * 
     */
    delete<T extends CabinetPlacementDeleteArgs>(args: SelectSubset<T, CabinetPlacementDeleteArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetPlacement.
     * @param {CabinetPlacementUpdateArgs} args - Arguments to update one CabinetPlacement.
     * @example
     * // Update one CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetPlacementUpdateArgs>(args: SelectSubset<T, CabinetPlacementUpdateArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetPlacements.
     * @param {CabinetPlacementDeleteManyArgs} args - Arguments to filter CabinetPlacements to delete.
     * @example
     * // Delete a few CabinetPlacements
     * const { count } = await prisma.cabinetPlacement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetPlacementDeleteManyArgs>(args?: SelectSubset<T, CabinetPlacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetPlacements
     * const cabinetPlacement = await prisma.cabinetPlacement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetPlacementUpdateManyArgs>(args: SelectSubset<T, CabinetPlacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPlacements and returns the data updated in the database.
     * @param {CabinetPlacementUpdateManyAndReturnArgs} args - Arguments to update many CabinetPlacements.
     * @example
     * // Update many CabinetPlacements
     * const cabinetPlacement = await prisma.cabinetPlacement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetPlacements and only return the `cabinetCode`
     * const cabinetPlacementWithCabinetCodeOnly = await prisma.cabinetPlacement.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetPlacementUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetPlacementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetPlacement.
     * @param {CabinetPlacementUpsertArgs} args - Arguments to update or create a CabinetPlacement.
     * @example
     * // Update or create a CabinetPlacement
     * const cabinetPlacement = await prisma.cabinetPlacement.upsert({
     *   create: {
     *     // ... data to create a CabinetPlacement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetPlacement we want to update
     *   }
     * })
     */
    upsert<T extends CabinetPlacementUpsertArgs>(args: SelectSubset<T, CabinetPlacementUpsertArgs<ExtArgs>>): Prisma__CabinetPlacementClient<$Result.GetResult<Prisma.$CabinetPlacementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementCountArgs} args - Arguments to filter CabinetPlacements to count.
     * @example
     * // Count the number of CabinetPlacements
     * const count = await prisma.cabinetPlacement.count({
     *   where: {
     *     // ... the filter for the CabinetPlacements we want to count
     *   }
     * })
    **/
    count<T extends CabinetPlacementCountArgs>(
      args?: Subset<T, CabinetPlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetPlacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetPlacementAggregateArgs>(args: Subset<T, CabinetPlacementAggregateArgs>): Prisma.PrismaPromise<GetCabinetPlacementAggregateType<T>>

    /**
     * Group by CabinetPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetPlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetPlacementGroupByArgs['orderBy'] }
        : { orderBy?: CabinetPlacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetPlacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetPlacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetPlacement model
   */
  readonly fields: CabinetPlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetPlacement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetPlacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    placement<T extends PlacementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlacementDefaultArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetPlacement model
   */
  interface CabinetPlacementFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetPlacement", 'String'>
    readonly placementCode: FieldRef<"CabinetPlacement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetPlacement findUnique
   */
  export type CabinetPlacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPlacement to fetch.
     */
    where: CabinetPlacementWhereUniqueInput
  }

  /**
   * CabinetPlacement findUniqueOrThrow
   */
  export type CabinetPlacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPlacement to fetch.
     */
    where: CabinetPlacementWhereUniqueInput
  }

  /**
   * CabinetPlacement findFirst
   */
  export type CabinetPlacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPlacement to fetch.
     */
    where?: CabinetPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPlacements to fetch.
     */
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPlacements.
     */
    cursor?: CabinetPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPlacements.
     */
    distinct?: CabinetPlacementScalarFieldEnum | CabinetPlacementScalarFieldEnum[]
  }

  /**
   * CabinetPlacement findFirstOrThrow
   */
  export type CabinetPlacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPlacement to fetch.
     */
    where?: CabinetPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPlacements to fetch.
     */
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPlacements.
     */
    cursor?: CabinetPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPlacements.
     */
    distinct?: CabinetPlacementScalarFieldEnum | CabinetPlacementScalarFieldEnum[]
  }

  /**
   * CabinetPlacement findMany
   */
  export type CabinetPlacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPlacements to fetch.
     */
    where?: CabinetPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPlacements to fetch.
     */
    orderBy?: CabinetPlacementOrderByWithRelationInput | CabinetPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetPlacements.
     */
    cursor?: CabinetPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPlacements.
     */
    skip?: number
    distinct?: CabinetPlacementScalarFieldEnum | CabinetPlacementScalarFieldEnum[]
  }

  /**
   * CabinetPlacement create
   */
  export type CabinetPlacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetPlacement.
     */
    data: XOR<CabinetPlacementCreateInput, CabinetPlacementUncheckedCreateInput>
  }

  /**
   * CabinetPlacement createMany
   */
  export type CabinetPlacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetPlacements.
     */
    data: CabinetPlacementCreateManyInput | CabinetPlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetPlacement createManyAndReturn
   */
  export type CabinetPlacementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetPlacements.
     */
    data: CabinetPlacementCreateManyInput | CabinetPlacementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPlacement update
   */
  export type CabinetPlacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetPlacement.
     */
    data: XOR<CabinetPlacementUpdateInput, CabinetPlacementUncheckedUpdateInput>
    /**
     * Choose, which CabinetPlacement to update.
     */
    where: CabinetPlacementWhereUniqueInput
  }

  /**
   * CabinetPlacement updateMany
   */
  export type CabinetPlacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetPlacements.
     */
    data: XOR<CabinetPlacementUpdateManyMutationInput, CabinetPlacementUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPlacements to update
     */
    where?: CabinetPlacementWhereInput
    /**
     * Limit how many CabinetPlacements to update.
     */
    limit?: number
  }

  /**
   * CabinetPlacement updateManyAndReturn
   */
  export type CabinetPlacementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * The data used to update CabinetPlacements.
     */
    data: XOR<CabinetPlacementUpdateManyMutationInput, CabinetPlacementUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPlacements to update
     */
    where?: CabinetPlacementWhereInput
    /**
     * Limit how many CabinetPlacements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPlacement upsert
   */
  export type CabinetPlacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetPlacement to update in case it exists.
     */
    where: CabinetPlacementWhereUniqueInput
    /**
     * In case the CabinetPlacement found by the `where` argument doesn't exist, create a new CabinetPlacement with this data.
     */
    create: XOR<CabinetPlacementCreateInput, CabinetPlacementUncheckedCreateInput>
    /**
     * In case the CabinetPlacement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetPlacementUpdateInput, CabinetPlacementUncheckedUpdateInput>
  }

  /**
   * CabinetPlacement delete
   */
  export type CabinetPlacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
    /**
     * Filter which CabinetPlacement to delete.
     */
    where: CabinetPlacementWhereUniqueInput
  }

  /**
   * CabinetPlacement deleteMany
   */
  export type CabinetPlacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPlacements to delete
     */
    where?: CabinetPlacementWhereInput
    /**
     * Limit how many CabinetPlacements to delete.
     */
    limit?: number
  }

  /**
   * CabinetPlacement without action
   */
  export type CabinetPlacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPlacement
     */
    select?: CabinetPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPlacement
     */
    omit?: CabinetPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPlacementInclude<ExtArgs> | null
  }


  /**
   * Model CabinetMaterial
   */

  export type AggregateCabinetMaterial = {
    _count: CabinetMaterialCountAggregateOutputType | null
    _min: CabinetMaterialMinAggregateOutputType | null
    _max: CabinetMaterialMaxAggregateOutputType | null
  }

  export type CabinetMaterialMinAggregateOutputType = {
    cabinetCode: string | null
    materialCode: string | null
  }

  export type CabinetMaterialMaxAggregateOutputType = {
    cabinetCode: string | null
    materialCode: string | null
  }

  export type CabinetMaterialCountAggregateOutputType = {
    cabinetCode: number
    materialCode: number
    _all: number
  }


  export type CabinetMaterialMinAggregateInputType = {
    cabinetCode?: true
    materialCode?: true
  }

  export type CabinetMaterialMaxAggregateInputType = {
    cabinetCode?: true
    materialCode?: true
  }

  export type CabinetMaterialCountAggregateInputType = {
    cabinetCode?: true
    materialCode?: true
    _all?: true
  }

  export type CabinetMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetMaterial to aggregate.
     */
    where?: CabinetMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetMaterials to fetch.
     */
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetMaterials
    **/
    _count?: true | CabinetMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetMaterialMaxAggregateInputType
  }

  export type GetCabinetMaterialAggregateType<T extends CabinetMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetMaterial[P]>
      : GetScalarType<T[P], AggregateCabinetMaterial[P]>
  }




  export type CabinetMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetMaterialWhereInput
    orderBy?: CabinetMaterialOrderByWithAggregationInput | CabinetMaterialOrderByWithAggregationInput[]
    by: CabinetMaterialScalarFieldEnum[] | CabinetMaterialScalarFieldEnum
    having?: CabinetMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetMaterialCountAggregateInputType | true
    _min?: CabinetMaterialMinAggregateInputType
    _max?: CabinetMaterialMaxAggregateInputType
  }

  export type CabinetMaterialGroupByOutputType = {
    cabinetCode: string
    materialCode: string
    _count: CabinetMaterialCountAggregateOutputType | null
    _min: CabinetMaterialMinAggregateOutputType | null
    _max: CabinetMaterialMaxAggregateOutputType | null
  }

  type GetCabinetMaterialGroupByPayload<T extends CabinetMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetMaterialGroupByOutputType[P]>
        }
      >
    >


  export type CabinetMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    materialCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetMaterial"]>

  export type CabinetMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    materialCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetMaterial"]>

  export type CabinetMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    materialCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetMaterial"]>

  export type CabinetMaterialSelectScalar = {
    cabinetCode?: boolean
    materialCode?: boolean
  }

  export type CabinetMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "materialCode", ExtArgs["result"]["cabinetMaterial"]>
  export type CabinetMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type CabinetMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type CabinetMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $CabinetMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetMaterial"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      materialCode: string
    }, ExtArgs["result"]["cabinetMaterial"]>
    composites: {}
  }

  type CabinetMaterialGetPayload<S extends boolean | null | undefined | CabinetMaterialDefaultArgs> = $Result.GetResult<Prisma.$CabinetMaterialPayload, S>

  type CabinetMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetMaterialCountAggregateInputType | true
    }

  export interface CabinetMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetMaterial'], meta: { name: 'CabinetMaterial' } }
    /**
     * Find zero or one CabinetMaterial that matches the filter.
     * @param {CabinetMaterialFindUniqueArgs} args - Arguments to find a CabinetMaterial
     * @example
     * // Get one CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetMaterialFindUniqueArgs>(args: SelectSubset<T, CabinetMaterialFindUniqueArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetMaterialFindUniqueOrThrowArgs} args - Arguments to find a CabinetMaterial
     * @example
     * // Get one CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialFindFirstArgs} args - Arguments to find a CabinetMaterial
     * @example
     * // Get one CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetMaterialFindFirstArgs>(args?: SelectSubset<T, CabinetMaterialFindFirstArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialFindFirstOrThrowArgs} args - Arguments to find a CabinetMaterial
     * @example
     * // Get one CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetMaterials
     * const cabinetMaterials = await prisma.cabinetMaterial.findMany()
     * 
     * // Get first 10 CabinetMaterials
     * const cabinetMaterials = await prisma.cabinetMaterial.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetMaterialWithCabinetCodeOnly = await prisma.cabinetMaterial.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetMaterialFindManyArgs>(args?: SelectSubset<T, CabinetMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetMaterial.
     * @param {CabinetMaterialCreateArgs} args - Arguments to create a CabinetMaterial.
     * @example
     * // Create one CabinetMaterial
     * const CabinetMaterial = await prisma.cabinetMaterial.create({
     *   data: {
     *     // ... data to create a CabinetMaterial
     *   }
     * })
     * 
     */
    create<T extends CabinetMaterialCreateArgs>(args: SelectSubset<T, CabinetMaterialCreateArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetMaterials.
     * @param {CabinetMaterialCreateManyArgs} args - Arguments to create many CabinetMaterials.
     * @example
     * // Create many CabinetMaterials
     * const cabinetMaterial = await prisma.cabinetMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetMaterialCreateManyArgs>(args?: SelectSubset<T, CabinetMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetMaterials and returns the data saved in the database.
     * @param {CabinetMaterialCreateManyAndReturnArgs} args - Arguments to create many CabinetMaterials.
     * @example
     * // Create many CabinetMaterials
     * const cabinetMaterial = await prisma.cabinetMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetMaterials and only return the `cabinetCode`
     * const cabinetMaterialWithCabinetCodeOnly = await prisma.cabinetMaterial.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetMaterial.
     * @param {CabinetMaterialDeleteArgs} args - Arguments to delete one CabinetMaterial.
     * @example
     * // Delete one CabinetMaterial
     * const CabinetMaterial = await prisma.cabinetMaterial.delete({
     *   where: {
     *     // ... filter to delete one CabinetMaterial
     *   }
     * })
     * 
     */
    delete<T extends CabinetMaterialDeleteArgs>(args: SelectSubset<T, CabinetMaterialDeleteArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetMaterial.
     * @param {CabinetMaterialUpdateArgs} args - Arguments to update one CabinetMaterial.
     * @example
     * // Update one CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetMaterialUpdateArgs>(args: SelectSubset<T, CabinetMaterialUpdateArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetMaterials.
     * @param {CabinetMaterialDeleteManyArgs} args - Arguments to filter CabinetMaterials to delete.
     * @example
     * // Delete a few CabinetMaterials
     * const { count } = await prisma.cabinetMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetMaterialDeleteManyArgs>(args?: SelectSubset<T, CabinetMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetMaterials
     * const cabinetMaterial = await prisma.cabinetMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetMaterialUpdateManyArgs>(args: SelectSubset<T, CabinetMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetMaterials and returns the data updated in the database.
     * @param {CabinetMaterialUpdateManyAndReturnArgs} args - Arguments to update many CabinetMaterials.
     * @example
     * // Update many CabinetMaterials
     * const cabinetMaterial = await prisma.cabinetMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetMaterials and only return the `cabinetCode`
     * const cabinetMaterialWithCabinetCodeOnly = await prisma.cabinetMaterial.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetMaterial.
     * @param {CabinetMaterialUpsertArgs} args - Arguments to update or create a CabinetMaterial.
     * @example
     * // Update or create a CabinetMaterial
     * const cabinetMaterial = await prisma.cabinetMaterial.upsert({
     *   create: {
     *     // ... data to create a CabinetMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetMaterial we want to update
     *   }
     * })
     */
    upsert<T extends CabinetMaterialUpsertArgs>(args: SelectSubset<T, CabinetMaterialUpsertArgs<ExtArgs>>): Prisma__CabinetMaterialClient<$Result.GetResult<Prisma.$CabinetMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialCountArgs} args - Arguments to filter CabinetMaterials to count.
     * @example
     * // Count the number of CabinetMaterials
     * const count = await prisma.cabinetMaterial.count({
     *   where: {
     *     // ... the filter for the CabinetMaterials we want to count
     *   }
     * })
    **/
    count<T extends CabinetMaterialCountArgs>(
      args?: Subset<T, CabinetMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetMaterialAggregateArgs>(args: Subset<T, CabinetMaterialAggregateArgs>): Prisma.PrismaPromise<GetCabinetMaterialAggregateType<T>>

    /**
     * Group by CabinetMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetMaterialGroupByArgs['orderBy'] }
        : { orderBy?: CabinetMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetMaterial model
   */
  readonly fields: CabinetMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetMaterial model
   */
  interface CabinetMaterialFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetMaterial", 'String'>
    readonly materialCode: FieldRef<"CabinetMaterial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetMaterial findUnique
   */
  export type CabinetMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter, which CabinetMaterial to fetch.
     */
    where: CabinetMaterialWhereUniqueInput
  }

  /**
   * CabinetMaterial findUniqueOrThrow
   */
  export type CabinetMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter, which CabinetMaterial to fetch.
     */
    where: CabinetMaterialWhereUniqueInput
  }

  /**
   * CabinetMaterial findFirst
   */
  export type CabinetMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter, which CabinetMaterial to fetch.
     */
    where?: CabinetMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetMaterials to fetch.
     */
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetMaterials.
     */
    cursor?: CabinetMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetMaterials.
     */
    distinct?: CabinetMaterialScalarFieldEnum | CabinetMaterialScalarFieldEnum[]
  }

  /**
   * CabinetMaterial findFirstOrThrow
   */
  export type CabinetMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter, which CabinetMaterial to fetch.
     */
    where?: CabinetMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetMaterials to fetch.
     */
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetMaterials.
     */
    cursor?: CabinetMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetMaterials.
     */
    distinct?: CabinetMaterialScalarFieldEnum | CabinetMaterialScalarFieldEnum[]
  }

  /**
   * CabinetMaterial findMany
   */
  export type CabinetMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter, which CabinetMaterials to fetch.
     */
    where?: CabinetMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetMaterials to fetch.
     */
    orderBy?: CabinetMaterialOrderByWithRelationInput | CabinetMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetMaterials.
     */
    cursor?: CabinetMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetMaterials.
     */
    skip?: number
    distinct?: CabinetMaterialScalarFieldEnum | CabinetMaterialScalarFieldEnum[]
  }

  /**
   * CabinetMaterial create
   */
  export type CabinetMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetMaterial.
     */
    data: XOR<CabinetMaterialCreateInput, CabinetMaterialUncheckedCreateInput>
  }

  /**
   * CabinetMaterial createMany
   */
  export type CabinetMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetMaterials.
     */
    data: CabinetMaterialCreateManyInput | CabinetMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetMaterial createManyAndReturn
   */
  export type CabinetMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetMaterials.
     */
    data: CabinetMaterialCreateManyInput | CabinetMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetMaterial update
   */
  export type CabinetMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetMaterial.
     */
    data: XOR<CabinetMaterialUpdateInput, CabinetMaterialUncheckedUpdateInput>
    /**
     * Choose, which CabinetMaterial to update.
     */
    where: CabinetMaterialWhereUniqueInput
  }

  /**
   * CabinetMaterial updateMany
   */
  export type CabinetMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetMaterials.
     */
    data: XOR<CabinetMaterialUpdateManyMutationInput, CabinetMaterialUncheckedUpdateManyInput>
    /**
     * Filter which CabinetMaterials to update
     */
    where?: CabinetMaterialWhereInput
    /**
     * Limit how many CabinetMaterials to update.
     */
    limit?: number
  }

  /**
   * CabinetMaterial updateManyAndReturn
   */
  export type CabinetMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * The data used to update CabinetMaterials.
     */
    data: XOR<CabinetMaterialUpdateManyMutationInput, CabinetMaterialUncheckedUpdateManyInput>
    /**
     * Filter which CabinetMaterials to update
     */
    where?: CabinetMaterialWhereInput
    /**
     * Limit how many CabinetMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetMaterial upsert
   */
  export type CabinetMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetMaterial to update in case it exists.
     */
    where: CabinetMaterialWhereUniqueInput
    /**
     * In case the CabinetMaterial found by the `where` argument doesn't exist, create a new CabinetMaterial with this data.
     */
    create: XOR<CabinetMaterialCreateInput, CabinetMaterialUncheckedCreateInput>
    /**
     * In case the CabinetMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetMaterialUpdateInput, CabinetMaterialUncheckedUpdateInput>
  }

  /**
   * CabinetMaterial delete
   */
  export type CabinetMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
    /**
     * Filter which CabinetMaterial to delete.
     */
    where: CabinetMaterialWhereUniqueInput
  }

  /**
   * CabinetMaterial deleteMany
   */
  export type CabinetMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetMaterials to delete
     */
    where?: CabinetMaterialWhereInput
    /**
     * Limit how many CabinetMaterials to delete.
     */
    limit?: number
  }

  /**
   * CabinetMaterial without action
   */
  export type CabinetMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetMaterial
     */
    select?: CabinetMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetMaterial
     */
    omit?: CabinetMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetMaterialInclude<ExtArgs> | null
  }


  /**
   * Model CabinetCabinetSize
   */

  export type AggregateCabinetCabinetSize = {
    _count: CabinetCabinetSizeCountAggregateOutputType | null
    _min: CabinetCabinetSizeMinAggregateOutputType | null
    _max: CabinetCabinetSizeMaxAggregateOutputType | null
  }

  export type CabinetCabinetSizeMinAggregateOutputType = {
    cabinetCode: string | null
    cabinetSizeCode: string | null
  }

  export type CabinetCabinetSizeMaxAggregateOutputType = {
    cabinetCode: string | null
    cabinetSizeCode: string | null
  }

  export type CabinetCabinetSizeCountAggregateOutputType = {
    cabinetCode: number
    cabinetSizeCode: number
    _all: number
  }


  export type CabinetCabinetSizeMinAggregateInputType = {
    cabinetCode?: true
    cabinetSizeCode?: true
  }

  export type CabinetCabinetSizeMaxAggregateInputType = {
    cabinetCode?: true
    cabinetSizeCode?: true
  }

  export type CabinetCabinetSizeCountAggregateInputType = {
    cabinetCode?: true
    cabinetSizeCode?: true
    _all?: true
  }

  export type CabinetCabinetSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetCabinetSize to aggregate.
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCabinetSizes to fetch.
     */
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetCabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetCabinetSizes
    **/
    _count?: true | CabinetCabinetSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetCabinetSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetCabinetSizeMaxAggregateInputType
  }

  export type GetCabinetCabinetSizeAggregateType<T extends CabinetCabinetSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetCabinetSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetCabinetSize[P]>
      : GetScalarType<T[P], AggregateCabinetCabinetSize[P]>
  }




  export type CabinetCabinetSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetCabinetSizeWhereInput
    orderBy?: CabinetCabinetSizeOrderByWithAggregationInput | CabinetCabinetSizeOrderByWithAggregationInput[]
    by: CabinetCabinetSizeScalarFieldEnum[] | CabinetCabinetSizeScalarFieldEnum
    having?: CabinetCabinetSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetCabinetSizeCountAggregateInputType | true
    _min?: CabinetCabinetSizeMinAggregateInputType
    _max?: CabinetCabinetSizeMaxAggregateInputType
  }

  export type CabinetCabinetSizeGroupByOutputType = {
    cabinetCode: string
    cabinetSizeCode: string
    _count: CabinetCabinetSizeCountAggregateOutputType | null
    _min: CabinetCabinetSizeMinAggregateOutputType | null
    _max: CabinetCabinetSizeMaxAggregateOutputType | null
  }

  type GetCabinetCabinetSizeGroupByPayload<T extends CabinetCabinetSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetCabinetSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetCabinetSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetCabinetSizeGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetCabinetSizeGroupByOutputType[P]>
        }
      >
    >


  export type CabinetCabinetSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    cabinetSizeCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCabinetSize"]>

  export type CabinetCabinetSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    cabinetSizeCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCabinetSize"]>

  export type CabinetCabinetSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    cabinetSizeCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetCabinetSize"]>

  export type CabinetCabinetSizeSelectScalar = {
    cabinetCode?: boolean
    cabinetSizeCode?: boolean
  }

  export type CabinetCabinetSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "cabinetSizeCode", ExtArgs["result"]["cabinetCabinetSize"]>
  export type CabinetCabinetSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }
  export type CabinetCabinetSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }
  export type CabinetCabinetSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    size?: boolean | CabinetSizeDefaultArgs<ExtArgs>
  }

  export type $CabinetCabinetSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetCabinetSize"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      size: Prisma.$CabinetSizePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      cabinetSizeCode: string
    }, ExtArgs["result"]["cabinetCabinetSize"]>
    composites: {}
  }

  type CabinetCabinetSizeGetPayload<S extends boolean | null | undefined | CabinetCabinetSizeDefaultArgs> = $Result.GetResult<Prisma.$CabinetCabinetSizePayload, S>

  type CabinetCabinetSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetCabinetSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetCabinetSizeCountAggregateInputType | true
    }

  export interface CabinetCabinetSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetCabinetSize'], meta: { name: 'CabinetCabinetSize' } }
    /**
     * Find zero or one CabinetCabinetSize that matches the filter.
     * @param {CabinetCabinetSizeFindUniqueArgs} args - Arguments to find a CabinetCabinetSize
     * @example
     * // Get one CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetCabinetSizeFindUniqueArgs>(args: SelectSubset<T, CabinetCabinetSizeFindUniqueArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetCabinetSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetCabinetSizeFindUniqueOrThrowArgs} args - Arguments to find a CabinetCabinetSize
     * @example
     * // Get one CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetCabinetSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetCabinetSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetCabinetSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeFindFirstArgs} args - Arguments to find a CabinetCabinetSize
     * @example
     * // Get one CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetCabinetSizeFindFirstArgs>(args?: SelectSubset<T, CabinetCabinetSizeFindFirstArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetCabinetSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeFindFirstOrThrowArgs} args - Arguments to find a CabinetCabinetSize
     * @example
     * // Get one CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetCabinetSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetCabinetSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetCabinetSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetCabinetSizes
     * const cabinetCabinetSizes = await prisma.cabinetCabinetSize.findMany()
     * 
     * // Get first 10 CabinetCabinetSizes
     * const cabinetCabinetSizes = await prisma.cabinetCabinetSize.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetCabinetSizeWithCabinetCodeOnly = await prisma.cabinetCabinetSize.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetCabinetSizeFindManyArgs>(args?: SelectSubset<T, CabinetCabinetSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetCabinetSize.
     * @param {CabinetCabinetSizeCreateArgs} args - Arguments to create a CabinetCabinetSize.
     * @example
     * // Create one CabinetCabinetSize
     * const CabinetCabinetSize = await prisma.cabinetCabinetSize.create({
     *   data: {
     *     // ... data to create a CabinetCabinetSize
     *   }
     * })
     * 
     */
    create<T extends CabinetCabinetSizeCreateArgs>(args: SelectSubset<T, CabinetCabinetSizeCreateArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetCabinetSizes.
     * @param {CabinetCabinetSizeCreateManyArgs} args - Arguments to create many CabinetCabinetSizes.
     * @example
     * // Create many CabinetCabinetSizes
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetCabinetSizeCreateManyArgs>(args?: SelectSubset<T, CabinetCabinetSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetCabinetSizes and returns the data saved in the database.
     * @param {CabinetCabinetSizeCreateManyAndReturnArgs} args - Arguments to create many CabinetCabinetSizes.
     * @example
     * // Create many CabinetCabinetSizes
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetCabinetSizes and only return the `cabinetCode`
     * const cabinetCabinetSizeWithCabinetCodeOnly = await prisma.cabinetCabinetSize.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetCabinetSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetCabinetSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetCabinetSize.
     * @param {CabinetCabinetSizeDeleteArgs} args - Arguments to delete one CabinetCabinetSize.
     * @example
     * // Delete one CabinetCabinetSize
     * const CabinetCabinetSize = await prisma.cabinetCabinetSize.delete({
     *   where: {
     *     // ... filter to delete one CabinetCabinetSize
     *   }
     * })
     * 
     */
    delete<T extends CabinetCabinetSizeDeleteArgs>(args: SelectSubset<T, CabinetCabinetSizeDeleteArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetCabinetSize.
     * @param {CabinetCabinetSizeUpdateArgs} args - Arguments to update one CabinetCabinetSize.
     * @example
     * // Update one CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetCabinetSizeUpdateArgs>(args: SelectSubset<T, CabinetCabinetSizeUpdateArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetCabinetSizes.
     * @param {CabinetCabinetSizeDeleteManyArgs} args - Arguments to filter CabinetCabinetSizes to delete.
     * @example
     * // Delete a few CabinetCabinetSizes
     * const { count } = await prisma.cabinetCabinetSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetCabinetSizeDeleteManyArgs>(args?: SelectSubset<T, CabinetCabinetSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetCabinetSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetCabinetSizes
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetCabinetSizeUpdateManyArgs>(args: SelectSubset<T, CabinetCabinetSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetCabinetSizes and returns the data updated in the database.
     * @param {CabinetCabinetSizeUpdateManyAndReturnArgs} args - Arguments to update many CabinetCabinetSizes.
     * @example
     * // Update many CabinetCabinetSizes
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetCabinetSizes and only return the `cabinetCode`
     * const cabinetCabinetSizeWithCabinetCodeOnly = await prisma.cabinetCabinetSize.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetCabinetSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetCabinetSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetCabinetSize.
     * @param {CabinetCabinetSizeUpsertArgs} args - Arguments to update or create a CabinetCabinetSize.
     * @example
     * // Update or create a CabinetCabinetSize
     * const cabinetCabinetSize = await prisma.cabinetCabinetSize.upsert({
     *   create: {
     *     // ... data to create a CabinetCabinetSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetCabinetSize we want to update
     *   }
     * })
     */
    upsert<T extends CabinetCabinetSizeUpsertArgs>(args: SelectSubset<T, CabinetCabinetSizeUpsertArgs<ExtArgs>>): Prisma__CabinetCabinetSizeClient<$Result.GetResult<Prisma.$CabinetCabinetSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetCabinetSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeCountArgs} args - Arguments to filter CabinetCabinetSizes to count.
     * @example
     * // Count the number of CabinetCabinetSizes
     * const count = await prisma.cabinetCabinetSize.count({
     *   where: {
     *     // ... the filter for the CabinetCabinetSizes we want to count
     *   }
     * })
    **/
    count<T extends CabinetCabinetSizeCountArgs>(
      args?: Subset<T, CabinetCabinetSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetCabinetSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetCabinetSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetCabinetSizeAggregateArgs>(args: Subset<T, CabinetCabinetSizeAggregateArgs>): Prisma.PrismaPromise<GetCabinetCabinetSizeAggregateType<T>>

    /**
     * Group by CabinetCabinetSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetCabinetSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetCabinetSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetCabinetSizeGroupByArgs['orderBy'] }
        : { orderBy?: CabinetCabinetSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetCabinetSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetCabinetSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetCabinetSize model
   */
  readonly fields: CabinetCabinetSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetCabinetSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetCabinetSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    size<T extends CabinetSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetSizeDefaultArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetCabinetSize model
   */
  interface CabinetCabinetSizeFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetCabinetSize", 'String'>
    readonly cabinetSizeCode: FieldRef<"CabinetCabinetSize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetCabinetSize findUnique
   */
  export type CabinetCabinetSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCabinetSize to fetch.
     */
    where: CabinetCabinetSizeWhereUniqueInput
  }

  /**
   * CabinetCabinetSize findUniqueOrThrow
   */
  export type CabinetCabinetSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCabinetSize to fetch.
     */
    where: CabinetCabinetSizeWhereUniqueInput
  }

  /**
   * CabinetCabinetSize findFirst
   */
  export type CabinetCabinetSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCabinetSize to fetch.
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCabinetSizes to fetch.
     */
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetCabinetSizes.
     */
    cursor?: CabinetCabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetCabinetSizes.
     */
    distinct?: CabinetCabinetSizeScalarFieldEnum | CabinetCabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetCabinetSize findFirstOrThrow
   */
  export type CabinetCabinetSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCabinetSize to fetch.
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCabinetSizes to fetch.
     */
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetCabinetSizes.
     */
    cursor?: CabinetCabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCabinetSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetCabinetSizes.
     */
    distinct?: CabinetCabinetSizeScalarFieldEnum | CabinetCabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetCabinetSize findMany
   */
  export type CabinetCabinetSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetCabinetSizes to fetch.
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetCabinetSizes to fetch.
     */
    orderBy?: CabinetCabinetSizeOrderByWithRelationInput | CabinetCabinetSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetCabinetSizes.
     */
    cursor?: CabinetCabinetSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetCabinetSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetCabinetSizes.
     */
    skip?: number
    distinct?: CabinetCabinetSizeScalarFieldEnum | CabinetCabinetSizeScalarFieldEnum[]
  }

  /**
   * CabinetCabinetSize create
   */
  export type CabinetCabinetSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetCabinetSize.
     */
    data: XOR<CabinetCabinetSizeCreateInput, CabinetCabinetSizeUncheckedCreateInput>
  }

  /**
   * CabinetCabinetSize createMany
   */
  export type CabinetCabinetSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetCabinetSizes.
     */
    data: CabinetCabinetSizeCreateManyInput | CabinetCabinetSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetCabinetSize createManyAndReturn
   */
  export type CabinetCabinetSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetCabinetSizes.
     */
    data: CabinetCabinetSizeCreateManyInput | CabinetCabinetSizeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetCabinetSize update
   */
  export type CabinetCabinetSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetCabinetSize.
     */
    data: XOR<CabinetCabinetSizeUpdateInput, CabinetCabinetSizeUncheckedUpdateInput>
    /**
     * Choose, which CabinetCabinetSize to update.
     */
    where: CabinetCabinetSizeWhereUniqueInput
  }

  /**
   * CabinetCabinetSize updateMany
   */
  export type CabinetCabinetSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetCabinetSizes.
     */
    data: XOR<CabinetCabinetSizeUpdateManyMutationInput, CabinetCabinetSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetCabinetSizes to update
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * Limit how many CabinetCabinetSizes to update.
     */
    limit?: number
  }

  /**
   * CabinetCabinetSize updateManyAndReturn
   */
  export type CabinetCabinetSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * The data used to update CabinetCabinetSizes.
     */
    data: XOR<CabinetCabinetSizeUpdateManyMutationInput, CabinetCabinetSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetCabinetSizes to update
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * Limit how many CabinetCabinetSizes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetCabinetSize upsert
   */
  export type CabinetCabinetSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetCabinetSize to update in case it exists.
     */
    where: CabinetCabinetSizeWhereUniqueInput
    /**
     * In case the CabinetCabinetSize found by the `where` argument doesn't exist, create a new CabinetCabinetSize with this data.
     */
    create: XOR<CabinetCabinetSizeCreateInput, CabinetCabinetSizeUncheckedCreateInput>
    /**
     * In case the CabinetCabinetSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetCabinetSizeUpdateInput, CabinetCabinetSizeUncheckedUpdateInput>
  }

  /**
   * CabinetCabinetSize delete
   */
  export type CabinetCabinetSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
    /**
     * Filter which CabinetCabinetSize to delete.
     */
    where: CabinetCabinetSizeWhereUniqueInput
  }

  /**
   * CabinetCabinetSize deleteMany
   */
  export type CabinetCabinetSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetCabinetSizes to delete
     */
    where?: CabinetCabinetSizeWhereInput
    /**
     * Limit how many CabinetCabinetSizes to delete.
     */
    limit?: number
  }

  /**
   * CabinetCabinetSize without action
   */
  export type CabinetCabinetSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetCabinetSize
     */
    select?: CabinetCabinetSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetCabinetSize
     */
    omit?: CabinetCabinetSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetCabinetSizeInclude<ExtArgs> | null
  }


  /**
   * Model CabinetPitch
   */

  export type AggregateCabinetPitch = {
    _count: CabinetPitchCountAggregateOutputType | null
    _min: CabinetPitchMinAggregateOutputType | null
    _max: CabinetPitchMaxAggregateOutputType | null
  }

  export type CabinetPitchMinAggregateOutputType = {
    cabinetCode: string | null
    pitchCode: string | null
  }

  export type CabinetPitchMaxAggregateOutputType = {
    cabinetCode: string | null
    pitchCode: string | null
  }

  export type CabinetPitchCountAggregateOutputType = {
    cabinetCode: number
    pitchCode: number
    _all: number
  }


  export type CabinetPitchMinAggregateInputType = {
    cabinetCode?: true
    pitchCode?: true
  }

  export type CabinetPitchMaxAggregateInputType = {
    cabinetCode?: true
    pitchCode?: true
  }

  export type CabinetPitchCountAggregateInputType = {
    cabinetCode?: true
    pitchCode?: true
    _all?: true
  }

  export type CabinetPitchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPitch to aggregate.
     */
    where?: CabinetPitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPitches to fetch.
     */
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetPitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetPitches
    **/
    _count?: true | CabinetPitchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetPitchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetPitchMaxAggregateInputType
  }

  export type GetCabinetPitchAggregateType<T extends CabinetPitchAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetPitch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetPitch[P]>
      : GetScalarType<T[P], AggregateCabinetPitch[P]>
  }




  export type CabinetPitchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPitchWhereInput
    orderBy?: CabinetPitchOrderByWithAggregationInput | CabinetPitchOrderByWithAggregationInput[]
    by: CabinetPitchScalarFieldEnum[] | CabinetPitchScalarFieldEnum
    having?: CabinetPitchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetPitchCountAggregateInputType | true
    _min?: CabinetPitchMinAggregateInputType
    _max?: CabinetPitchMaxAggregateInputType
  }

  export type CabinetPitchGroupByOutputType = {
    cabinetCode: string
    pitchCode: string
    _count: CabinetPitchCountAggregateOutputType | null
    _min: CabinetPitchMinAggregateOutputType | null
    _max: CabinetPitchMaxAggregateOutputType | null
  }

  type GetCabinetPitchGroupByPayload<T extends CabinetPitchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetPitchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetPitchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetPitchGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetPitchGroupByOutputType[P]>
        }
      >
    >


  export type CabinetPitchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    pitchCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPitch"]>

  export type CabinetPitchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    pitchCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPitch"]>

  export type CabinetPitchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    pitchCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPitch"]>

  export type CabinetPitchSelectScalar = {
    cabinetCode?: boolean
    pitchCode?: boolean
  }

  export type CabinetPitchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "pitchCode", ExtArgs["result"]["cabinetPitch"]>
  export type CabinetPitchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }
  export type CabinetPitchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }
  export type CabinetPitchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }

  export type $CabinetPitchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetPitch"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      pitch: Prisma.$PitchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      pitchCode: string
    }, ExtArgs["result"]["cabinetPitch"]>
    composites: {}
  }

  type CabinetPitchGetPayload<S extends boolean | null | undefined | CabinetPitchDefaultArgs> = $Result.GetResult<Prisma.$CabinetPitchPayload, S>

  type CabinetPitchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetPitchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetPitchCountAggregateInputType | true
    }

  export interface CabinetPitchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetPitch'], meta: { name: 'CabinetPitch' } }
    /**
     * Find zero or one CabinetPitch that matches the filter.
     * @param {CabinetPitchFindUniqueArgs} args - Arguments to find a CabinetPitch
     * @example
     * // Get one CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetPitchFindUniqueArgs>(args: SelectSubset<T, CabinetPitchFindUniqueArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetPitch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetPitchFindUniqueOrThrowArgs} args - Arguments to find a CabinetPitch
     * @example
     * // Get one CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetPitchFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetPitchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPitch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchFindFirstArgs} args - Arguments to find a CabinetPitch
     * @example
     * // Get one CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetPitchFindFirstArgs>(args?: SelectSubset<T, CabinetPitchFindFirstArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPitch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchFindFirstOrThrowArgs} args - Arguments to find a CabinetPitch
     * @example
     * // Get one CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetPitchFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetPitchFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetPitches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetPitches
     * const cabinetPitches = await prisma.cabinetPitch.findMany()
     * 
     * // Get first 10 CabinetPitches
     * const cabinetPitches = await prisma.cabinetPitch.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetPitchWithCabinetCodeOnly = await prisma.cabinetPitch.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetPitchFindManyArgs>(args?: SelectSubset<T, CabinetPitchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetPitch.
     * @param {CabinetPitchCreateArgs} args - Arguments to create a CabinetPitch.
     * @example
     * // Create one CabinetPitch
     * const CabinetPitch = await prisma.cabinetPitch.create({
     *   data: {
     *     // ... data to create a CabinetPitch
     *   }
     * })
     * 
     */
    create<T extends CabinetPitchCreateArgs>(args: SelectSubset<T, CabinetPitchCreateArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetPitches.
     * @param {CabinetPitchCreateManyArgs} args - Arguments to create many CabinetPitches.
     * @example
     * // Create many CabinetPitches
     * const cabinetPitch = await prisma.cabinetPitch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetPitchCreateManyArgs>(args?: SelectSubset<T, CabinetPitchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetPitches and returns the data saved in the database.
     * @param {CabinetPitchCreateManyAndReturnArgs} args - Arguments to create many CabinetPitches.
     * @example
     * // Create many CabinetPitches
     * const cabinetPitch = await prisma.cabinetPitch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetPitches and only return the `cabinetCode`
     * const cabinetPitchWithCabinetCodeOnly = await prisma.cabinetPitch.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetPitchCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetPitchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetPitch.
     * @param {CabinetPitchDeleteArgs} args - Arguments to delete one CabinetPitch.
     * @example
     * // Delete one CabinetPitch
     * const CabinetPitch = await prisma.cabinetPitch.delete({
     *   where: {
     *     // ... filter to delete one CabinetPitch
     *   }
     * })
     * 
     */
    delete<T extends CabinetPitchDeleteArgs>(args: SelectSubset<T, CabinetPitchDeleteArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetPitch.
     * @param {CabinetPitchUpdateArgs} args - Arguments to update one CabinetPitch.
     * @example
     * // Update one CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetPitchUpdateArgs>(args: SelectSubset<T, CabinetPitchUpdateArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetPitches.
     * @param {CabinetPitchDeleteManyArgs} args - Arguments to filter CabinetPitches to delete.
     * @example
     * // Delete a few CabinetPitches
     * const { count } = await prisma.cabinetPitch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetPitchDeleteManyArgs>(args?: SelectSubset<T, CabinetPitchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetPitches
     * const cabinetPitch = await prisma.cabinetPitch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetPitchUpdateManyArgs>(args: SelectSubset<T, CabinetPitchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPitches and returns the data updated in the database.
     * @param {CabinetPitchUpdateManyAndReturnArgs} args - Arguments to update many CabinetPitches.
     * @example
     * // Update many CabinetPitches
     * const cabinetPitch = await prisma.cabinetPitch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetPitches and only return the `cabinetCode`
     * const cabinetPitchWithCabinetCodeOnly = await prisma.cabinetPitch.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetPitchUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetPitchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetPitch.
     * @param {CabinetPitchUpsertArgs} args - Arguments to update or create a CabinetPitch.
     * @example
     * // Update or create a CabinetPitch
     * const cabinetPitch = await prisma.cabinetPitch.upsert({
     *   create: {
     *     // ... data to create a CabinetPitch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetPitch we want to update
     *   }
     * })
     */
    upsert<T extends CabinetPitchUpsertArgs>(args: SelectSubset<T, CabinetPitchUpsertArgs<ExtArgs>>): Prisma__CabinetPitchClient<$Result.GetResult<Prisma.$CabinetPitchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetPitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchCountArgs} args - Arguments to filter CabinetPitches to count.
     * @example
     * // Count the number of CabinetPitches
     * const count = await prisma.cabinetPitch.count({
     *   where: {
     *     // ... the filter for the CabinetPitches we want to count
     *   }
     * })
    **/
    count<T extends CabinetPitchCountArgs>(
      args?: Subset<T, CabinetPitchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetPitchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetPitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetPitchAggregateArgs>(args: Subset<T, CabinetPitchAggregateArgs>): Prisma.PrismaPromise<GetCabinetPitchAggregateType<T>>

    /**
     * Group by CabinetPitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPitchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetPitchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetPitchGroupByArgs['orderBy'] }
        : { orderBy?: CabinetPitchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetPitchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetPitchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetPitch model
   */
  readonly fields: CabinetPitchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetPitch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetPitchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pitch<T extends PitchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PitchDefaultArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetPitch model
   */
  interface CabinetPitchFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetPitch", 'String'>
    readonly pitchCode: FieldRef<"CabinetPitch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetPitch findUnique
   */
  export type CabinetPitchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPitch to fetch.
     */
    where: CabinetPitchWhereUniqueInput
  }

  /**
   * CabinetPitch findUniqueOrThrow
   */
  export type CabinetPitchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPitch to fetch.
     */
    where: CabinetPitchWhereUniqueInput
  }

  /**
   * CabinetPitch findFirst
   */
  export type CabinetPitchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPitch to fetch.
     */
    where?: CabinetPitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPitches to fetch.
     */
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPitches.
     */
    cursor?: CabinetPitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPitches.
     */
    distinct?: CabinetPitchScalarFieldEnum | CabinetPitchScalarFieldEnum[]
  }

  /**
   * CabinetPitch findFirstOrThrow
   */
  export type CabinetPitchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPitch to fetch.
     */
    where?: CabinetPitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPitches to fetch.
     */
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPitches.
     */
    cursor?: CabinetPitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPitches.
     */
    distinct?: CabinetPitchScalarFieldEnum | CabinetPitchScalarFieldEnum[]
  }

  /**
   * CabinetPitch findMany
   */
  export type CabinetPitchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPitches to fetch.
     */
    where?: CabinetPitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPitches to fetch.
     */
    orderBy?: CabinetPitchOrderByWithRelationInput | CabinetPitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetPitches.
     */
    cursor?: CabinetPitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPitches.
     */
    skip?: number
    distinct?: CabinetPitchScalarFieldEnum | CabinetPitchScalarFieldEnum[]
  }

  /**
   * CabinetPitch create
   */
  export type CabinetPitchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetPitch.
     */
    data: XOR<CabinetPitchCreateInput, CabinetPitchUncheckedCreateInput>
  }

  /**
   * CabinetPitch createMany
   */
  export type CabinetPitchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetPitches.
     */
    data: CabinetPitchCreateManyInput | CabinetPitchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetPitch createManyAndReturn
   */
  export type CabinetPitchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetPitches.
     */
    data: CabinetPitchCreateManyInput | CabinetPitchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPitch update
   */
  export type CabinetPitchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetPitch.
     */
    data: XOR<CabinetPitchUpdateInput, CabinetPitchUncheckedUpdateInput>
    /**
     * Choose, which CabinetPitch to update.
     */
    where: CabinetPitchWhereUniqueInput
  }

  /**
   * CabinetPitch updateMany
   */
  export type CabinetPitchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetPitches.
     */
    data: XOR<CabinetPitchUpdateManyMutationInput, CabinetPitchUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPitches to update
     */
    where?: CabinetPitchWhereInput
    /**
     * Limit how many CabinetPitches to update.
     */
    limit?: number
  }

  /**
   * CabinetPitch updateManyAndReturn
   */
  export type CabinetPitchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * The data used to update CabinetPitches.
     */
    data: XOR<CabinetPitchUpdateManyMutationInput, CabinetPitchUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPitches to update
     */
    where?: CabinetPitchWhereInput
    /**
     * Limit how many CabinetPitches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPitch upsert
   */
  export type CabinetPitchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetPitch to update in case it exists.
     */
    where: CabinetPitchWhereUniqueInput
    /**
     * In case the CabinetPitch found by the `where` argument doesn't exist, create a new CabinetPitch with this data.
     */
    create: XOR<CabinetPitchCreateInput, CabinetPitchUncheckedCreateInput>
    /**
     * In case the CabinetPitch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetPitchUpdateInput, CabinetPitchUncheckedUpdateInput>
  }

  /**
   * CabinetPitch delete
   */
  export type CabinetPitchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
    /**
     * Filter which CabinetPitch to delete.
     */
    where: CabinetPitchWhereUniqueInput
  }

  /**
   * CabinetPitch deleteMany
   */
  export type CabinetPitchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPitches to delete
     */
    where?: CabinetPitchWhereInput
    /**
     * Limit how many CabinetPitches to delete.
     */
    limit?: number
  }

  /**
   * CabinetPitch without action
   */
  export type CabinetPitchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPitch
     */
    select?: CabinetPitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPitch
     */
    omit?: CabinetPitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPitchInclude<ExtArgs> | null
  }


  /**
   * Model CabinetManufacturer
   */

  export type AggregateCabinetManufacturer = {
    _count: CabinetManufacturerCountAggregateOutputType | null
    _min: CabinetManufacturerMinAggregateOutputType | null
    _max: CabinetManufacturerMaxAggregateOutputType | null
  }

  export type CabinetManufacturerMinAggregateOutputType = {
    cabinetCode: string | null
    manufacturerCode: string | null
  }

  export type CabinetManufacturerMaxAggregateOutputType = {
    cabinetCode: string | null
    manufacturerCode: string | null
  }

  export type CabinetManufacturerCountAggregateOutputType = {
    cabinetCode: number
    manufacturerCode: number
    _all: number
  }


  export type CabinetManufacturerMinAggregateInputType = {
    cabinetCode?: true
    manufacturerCode?: true
  }

  export type CabinetManufacturerMaxAggregateInputType = {
    cabinetCode?: true
    manufacturerCode?: true
  }

  export type CabinetManufacturerCountAggregateInputType = {
    cabinetCode?: true
    manufacturerCode?: true
    _all?: true
  }

  export type CabinetManufacturerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetManufacturer to aggregate.
     */
    where?: CabinetManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetManufacturers to fetch.
     */
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetManufacturers
    **/
    _count?: true | CabinetManufacturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetManufacturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetManufacturerMaxAggregateInputType
  }

  export type GetCabinetManufacturerAggregateType<T extends CabinetManufacturerAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetManufacturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetManufacturer[P]>
      : GetScalarType<T[P], AggregateCabinetManufacturer[P]>
  }




  export type CabinetManufacturerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetManufacturerWhereInput
    orderBy?: CabinetManufacturerOrderByWithAggregationInput | CabinetManufacturerOrderByWithAggregationInput[]
    by: CabinetManufacturerScalarFieldEnum[] | CabinetManufacturerScalarFieldEnum
    having?: CabinetManufacturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetManufacturerCountAggregateInputType | true
    _min?: CabinetManufacturerMinAggregateInputType
    _max?: CabinetManufacturerMaxAggregateInputType
  }

  export type CabinetManufacturerGroupByOutputType = {
    cabinetCode: string
    manufacturerCode: string
    _count: CabinetManufacturerCountAggregateOutputType | null
    _min: CabinetManufacturerMinAggregateOutputType | null
    _max: CabinetManufacturerMaxAggregateOutputType | null
  }

  type GetCabinetManufacturerGroupByPayload<T extends CabinetManufacturerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetManufacturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetManufacturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetManufacturerGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetManufacturerGroupByOutputType[P]>
        }
      >
    >


  export type CabinetManufacturerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    manufacturerCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetManufacturer"]>

  export type CabinetManufacturerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    manufacturerCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetManufacturer"]>

  export type CabinetManufacturerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    manufacturerCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetManufacturer"]>

  export type CabinetManufacturerSelectScalar = {
    cabinetCode?: boolean
    manufacturerCode?: boolean
  }

  export type CabinetManufacturerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "manufacturerCode", ExtArgs["result"]["cabinetManufacturer"]>
  export type CabinetManufacturerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }
  export type CabinetManufacturerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }
  export type CabinetManufacturerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }

  export type $CabinetManufacturerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetManufacturer"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      manufacturer: Prisma.$ManufacturerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      manufacturerCode: string
    }, ExtArgs["result"]["cabinetManufacturer"]>
    composites: {}
  }

  type CabinetManufacturerGetPayload<S extends boolean | null | undefined | CabinetManufacturerDefaultArgs> = $Result.GetResult<Prisma.$CabinetManufacturerPayload, S>

  type CabinetManufacturerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetManufacturerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetManufacturerCountAggregateInputType | true
    }

  export interface CabinetManufacturerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetManufacturer'], meta: { name: 'CabinetManufacturer' } }
    /**
     * Find zero or one CabinetManufacturer that matches the filter.
     * @param {CabinetManufacturerFindUniqueArgs} args - Arguments to find a CabinetManufacturer
     * @example
     * // Get one CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetManufacturerFindUniqueArgs>(args: SelectSubset<T, CabinetManufacturerFindUniqueArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetManufacturer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetManufacturerFindUniqueOrThrowArgs} args - Arguments to find a CabinetManufacturer
     * @example
     * // Get one CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetManufacturerFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetManufacturerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetManufacturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerFindFirstArgs} args - Arguments to find a CabinetManufacturer
     * @example
     * // Get one CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetManufacturerFindFirstArgs>(args?: SelectSubset<T, CabinetManufacturerFindFirstArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetManufacturer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerFindFirstOrThrowArgs} args - Arguments to find a CabinetManufacturer
     * @example
     * // Get one CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetManufacturerFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetManufacturerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetManufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetManufacturers
     * const cabinetManufacturers = await prisma.cabinetManufacturer.findMany()
     * 
     * // Get first 10 CabinetManufacturers
     * const cabinetManufacturers = await prisma.cabinetManufacturer.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetManufacturerWithCabinetCodeOnly = await prisma.cabinetManufacturer.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetManufacturerFindManyArgs>(args?: SelectSubset<T, CabinetManufacturerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetManufacturer.
     * @param {CabinetManufacturerCreateArgs} args - Arguments to create a CabinetManufacturer.
     * @example
     * // Create one CabinetManufacturer
     * const CabinetManufacturer = await prisma.cabinetManufacturer.create({
     *   data: {
     *     // ... data to create a CabinetManufacturer
     *   }
     * })
     * 
     */
    create<T extends CabinetManufacturerCreateArgs>(args: SelectSubset<T, CabinetManufacturerCreateArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetManufacturers.
     * @param {CabinetManufacturerCreateManyArgs} args - Arguments to create many CabinetManufacturers.
     * @example
     * // Create many CabinetManufacturers
     * const cabinetManufacturer = await prisma.cabinetManufacturer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetManufacturerCreateManyArgs>(args?: SelectSubset<T, CabinetManufacturerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetManufacturers and returns the data saved in the database.
     * @param {CabinetManufacturerCreateManyAndReturnArgs} args - Arguments to create many CabinetManufacturers.
     * @example
     * // Create many CabinetManufacturers
     * const cabinetManufacturer = await prisma.cabinetManufacturer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetManufacturers and only return the `cabinetCode`
     * const cabinetManufacturerWithCabinetCodeOnly = await prisma.cabinetManufacturer.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetManufacturerCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetManufacturerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetManufacturer.
     * @param {CabinetManufacturerDeleteArgs} args - Arguments to delete one CabinetManufacturer.
     * @example
     * // Delete one CabinetManufacturer
     * const CabinetManufacturer = await prisma.cabinetManufacturer.delete({
     *   where: {
     *     // ... filter to delete one CabinetManufacturer
     *   }
     * })
     * 
     */
    delete<T extends CabinetManufacturerDeleteArgs>(args: SelectSubset<T, CabinetManufacturerDeleteArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetManufacturer.
     * @param {CabinetManufacturerUpdateArgs} args - Arguments to update one CabinetManufacturer.
     * @example
     * // Update one CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetManufacturerUpdateArgs>(args: SelectSubset<T, CabinetManufacturerUpdateArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetManufacturers.
     * @param {CabinetManufacturerDeleteManyArgs} args - Arguments to filter CabinetManufacturers to delete.
     * @example
     * // Delete a few CabinetManufacturers
     * const { count } = await prisma.cabinetManufacturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetManufacturerDeleteManyArgs>(args?: SelectSubset<T, CabinetManufacturerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetManufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetManufacturers
     * const cabinetManufacturer = await prisma.cabinetManufacturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetManufacturerUpdateManyArgs>(args: SelectSubset<T, CabinetManufacturerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetManufacturers and returns the data updated in the database.
     * @param {CabinetManufacturerUpdateManyAndReturnArgs} args - Arguments to update many CabinetManufacturers.
     * @example
     * // Update many CabinetManufacturers
     * const cabinetManufacturer = await prisma.cabinetManufacturer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetManufacturers and only return the `cabinetCode`
     * const cabinetManufacturerWithCabinetCodeOnly = await prisma.cabinetManufacturer.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetManufacturerUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetManufacturerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetManufacturer.
     * @param {CabinetManufacturerUpsertArgs} args - Arguments to update or create a CabinetManufacturer.
     * @example
     * // Update or create a CabinetManufacturer
     * const cabinetManufacturer = await prisma.cabinetManufacturer.upsert({
     *   create: {
     *     // ... data to create a CabinetManufacturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetManufacturer we want to update
     *   }
     * })
     */
    upsert<T extends CabinetManufacturerUpsertArgs>(args: SelectSubset<T, CabinetManufacturerUpsertArgs<ExtArgs>>): Prisma__CabinetManufacturerClient<$Result.GetResult<Prisma.$CabinetManufacturerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetManufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerCountArgs} args - Arguments to filter CabinetManufacturers to count.
     * @example
     * // Count the number of CabinetManufacturers
     * const count = await prisma.cabinetManufacturer.count({
     *   where: {
     *     // ... the filter for the CabinetManufacturers we want to count
     *   }
     * })
    **/
    count<T extends CabinetManufacturerCountArgs>(
      args?: Subset<T, CabinetManufacturerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetManufacturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetManufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetManufacturerAggregateArgs>(args: Subset<T, CabinetManufacturerAggregateArgs>): Prisma.PrismaPromise<GetCabinetManufacturerAggregateType<T>>

    /**
     * Group by CabinetManufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetManufacturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetManufacturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetManufacturerGroupByArgs['orderBy'] }
        : { orderBy?: CabinetManufacturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetManufacturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetManufacturerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetManufacturer model
   */
  readonly fields: CabinetManufacturerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetManufacturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetManufacturerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manufacturer<T extends ManufacturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturerDefaultArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetManufacturer model
   */
  interface CabinetManufacturerFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetManufacturer", 'String'>
    readonly manufacturerCode: FieldRef<"CabinetManufacturer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetManufacturer findUnique
   */
  export type CabinetManufacturerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which CabinetManufacturer to fetch.
     */
    where: CabinetManufacturerWhereUniqueInput
  }

  /**
   * CabinetManufacturer findUniqueOrThrow
   */
  export type CabinetManufacturerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which CabinetManufacturer to fetch.
     */
    where: CabinetManufacturerWhereUniqueInput
  }

  /**
   * CabinetManufacturer findFirst
   */
  export type CabinetManufacturerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which CabinetManufacturer to fetch.
     */
    where?: CabinetManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetManufacturers to fetch.
     */
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetManufacturers.
     */
    cursor?: CabinetManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetManufacturers.
     */
    distinct?: CabinetManufacturerScalarFieldEnum | CabinetManufacturerScalarFieldEnum[]
  }

  /**
   * CabinetManufacturer findFirstOrThrow
   */
  export type CabinetManufacturerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which CabinetManufacturer to fetch.
     */
    where?: CabinetManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetManufacturers to fetch.
     */
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetManufacturers.
     */
    cursor?: CabinetManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetManufacturers.
     */
    distinct?: CabinetManufacturerScalarFieldEnum | CabinetManufacturerScalarFieldEnum[]
  }

  /**
   * CabinetManufacturer findMany
   */
  export type CabinetManufacturerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which CabinetManufacturers to fetch.
     */
    where?: CabinetManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetManufacturers to fetch.
     */
    orderBy?: CabinetManufacturerOrderByWithRelationInput | CabinetManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetManufacturers.
     */
    cursor?: CabinetManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetManufacturers.
     */
    skip?: number
    distinct?: CabinetManufacturerScalarFieldEnum | CabinetManufacturerScalarFieldEnum[]
  }

  /**
   * CabinetManufacturer create
   */
  export type CabinetManufacturerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetManufacturer.
     */
    data: XOR<CabinetManufacturerCreateInput, CabinetManufacturerUncheckedCreateInput>
  }

  /**
   * CabinetManufacturer createMany
   */
  export type CabinetManufacturerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetManufacturers.
     */
    data: CabinetManufacturerCreateManyInput | CabinetManufacturerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetManufacturer createManyAndReturn
   */
  export type CabinetManufacturerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetManufacturers.
     */
    data: CabinetManufacturerCreateManyInput | CabinetManufacturerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetManufacturer update
   */
  export type CabinetManufacturerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetManufacturer.
     */
    data: XOR<CabinetManufacturerUpdateInput, CabinetManufacturerUncheckedUpdateInput>
    /**
     * Choose, which CabinetManufacturer to update.
     */
    where: CabinetManufacturerWhereUniqueInput
  }

  /**
   * CabinetManufacturer updateMany
   */
  export type CabinetManufacturerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetManufacturers.
     */
    data: XOR<CabinetManufacturerUpdateManyMutationInput, CabinetManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which CabinetManufacturers to update
     */
    where?: CabinetManufacturerWhereInput
    /**
     * Limit how many CabinetManufacturers to update.
     */
    limit?: number
  }

  /**
   * CabinetManufacturer updateManyAndReturn
   */
  export type CabinetManufacturerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * The data used to update CabinetManufacturers.
     */
    data: XOR<CabinetManufacturerUpdateManyMutationInput, CabinetManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which CabinetManufacturers to update
     */
    where?: CabinetManufacturerWhereInput
    /**
     * Limit how many CabinetManufacturers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetManufacturer upsert
   */
  export type CabinetManufacturerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetManufacturer to update in case it exists.
     */
    where: CabinetManufacturerWhereUniqueInput
    /**
     * In case the CabinetManufacturer found by the `where` argument doesn't exist, create a new CabinetManufacturer with this data.
     */
    create: XOR<CabinetManufacturerCreateInput, CabinetManufacturerUncheckedCreateInput>
    /**
     * In case the CabinetManufacturer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetManufacturerUpdateInput, CabinetManufacturerUncheckedUpdateInput>
  }

  /**
   * CabinetManufacturer delete
   */
  export type CabinetManufacturerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
    /**
     * Filter which CabinetManufacturer to delete.
     */
    where: CabinetManufacturerWhereUniqueInput
  }

  /**
   * CabinetManufacturer deleteMany
   */
  export type CabinetManufacturerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetManufacturers to delete
     */
    where?: CabinetManufacturerWhereInput
    /**
     * Limit how many CabinetManufacturers to delete.
     */
    limit?: number
  }

  /**
   * CabinetManufacturer without action
   */
  export type CabinetManufacturerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetManufacturer
     */
    select?: CabinetManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetManufacturer
     */
    omit?: CabinetManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetManufacturerInclude<ExtArgs> | null
  }


  /**
   * Model CabinetSupplier
   */

  export type AggregateCabinetSupplier = {
    _count: CabinetSupplierCountAggregateOutputType | null
    _min: CabinetSupplierMinAggregateOutputType | null
    _max: CabinetSupplierMaxAggregateOutputType | null
  }

  export type CabinetSupplierMinAggregateOutputType = {
    cabinetCode: string | null
    supplierCode: string | null
  }

  export type CabinetSupplierMaxAggregateOutputType = {
    cabinetCode: string | null
    supplierCode: string | null
  }

  export type CabinetSupplierCountAggregateOutputType = {
    cabinetCode: number
    supplierCode: number
    _all: number
  }


  export type CabinetSupplierMinAggregateInputType = {
    cabinetCode?: true
    supplierCode?: true
  }

  export type CabinetSupplierMaxAggregateInputType = {
    cabinetCode?: true
    supplierCode?: true
  }

  export type CabinetSupplierCountAggregateInputType = {
    cabinetCode?: true
    supplierCode?: true
    _all?: true
  }

  export type CabinetSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSupplier to aggregate.
     */
    where?: CabinetSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSuppliers to fetch.
     */
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetSuppliers
    **/
    _count?: true | CabinetSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetSupplierMaxAggregateInputType
  }

  export type GetCabinetSupplierAggregateType<T extends CabinetSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetSupplier[P]>
      : GetScalarType<T[P], AggregateCabinetSupplier[P]>
  }




  export type CabinetSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSupplierWhereInput
    orderBy?: CabinetSupplierOrderByWithAggregationInput | CabinetSupplierOrderByWithAggregationInput[]
    by: CabinetSupplierScalarFieldEnum[] | CabinetSupplierScalarFieldEnum
    having?: CabinetSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetSupplierCountAggregateInputType | true
    _min?: CabinetSupplierMinAggregateInputType
    _max?: CabinetSupplierMaxAggregateInputType
  }

  export type CabinetSupplierGroupByOutputType = {
    cabinetCode: string
    supplierCode: string
    _count: CabinetSupplierCountAggregateOutputType | null
    _min: CabinetSupplierMinAggregateOutputType | null
    _max: CabinetSupplierMaxAggregateOutputType | null
  }

  type GetCabinetSupplierGroupByPayload<T extends CabinetSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetSupplierGroupByOutputType[P]>
        }
      >
    >


  export type CabinetSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    supplierCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSupplier"]>

  export type CabinetSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    supplierCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSupplier"]>

  export type CabinetSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    supplierCode?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSupplier"]>

  export type CabinetSupplierSelectScalar = {
    cabinetCode?: boolean
    supplierCode?: boolean
  }

  export type CabinetSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "supplierCode", ExtArgs["result"]["cabinetSupplier"]>
  export type CabinetSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type CabinetSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type CabinetSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $CabinetSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetSupplier"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      supplierCode: string
    }, ExtArgs["result"]["cabinetSupplier"]>
    composites: {}
  }

  type CabinetSupplierGetPayload<S extends boolean | null | undefined | CabinetSupplierDefaultArgs> = $Result.GetResult<Prisma.$CabinetSupplierPayload, S>

  type CabinetSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetSupplierCountAggregateInputType | true
    }

  export interface CabinetSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetSupplier'], meta: { name: 'CabinetSupplier' } }
    /**
     * Find zero or one CabinetSupplier that matches the filter.
     * @param {CabinetSupplierFindUniqueArgs} args - Arguments to find a CabinetSupplier
     * @example
     * // Get one CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetSupplierFindUniqueArgs>(args: SelectSubset<T, CabinetSupplierFindUniqueArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetSupplierFindUniqueOrThrowArgs} args - Arguments to find a CabinetSupplier
     * @example
     * // Get one CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierFindFirstArgs} args - Arguments to find a CabinetSupplier
     * @example
     * // Get one CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetSupplierFindFirstArgs>(args?: SelectSubset<T, CabinetSupplierFindFirstArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierFindFirstOrThrowArgs} args - Arguments to find a CabinetSupplier
     * @example
     * // Get one CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetSuppliers
     * const cabinetSuppliers = await prisma.cabinetSupplier.findMany()
     * 
     * // Get first 10 CabinetSuppliers
     * const cabinetSuppliers = await prisma.cabinetSupplier.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetSupplierWithCabinetCodeOnly = await prisma.cabinetSupplier.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetSupplierFindManyArgs>(args?: SelectSubset<T, CabinetSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetSupplier.
     * @param {CabinetSupplierCreateArgs} args - Arguments to create a CabinetSupplier.
     * @example
     * // Create one CabinetSupplier
     * const CabinetSupplier = await prisma.cabinetSupplier.create({
     *   data: {
     *     // ... data to create a CabinetSupplier
     *   }
     * })
     * 
     */
    create<T extends CabinetSupplierCreateArgs>(args: SelectSubset<T, CabinetSupplierCreateArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetSuppliers.
     * @param {CabinetSupplierCreateManyArgs} args - Arguments to create many CabinetSuppliers.
     * @example
     * // Create many CabinetSuppliers
     * const cabinetSupplier = await prisma.cabinetSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetSupplierCreateManyArgs>(args?: SelectSubset<T, CabinetSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetSuppliers and returns the data saved in the database.
     * @param {CabinetSupplierCreateManyAndReturnArgs} args - Arguments to create many CabinetSuppliers.
     * @example
     * // Create many CabinetSuppliers
     * const cabinetSupplier = await prisma.cabinetSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetSuppliers and only return the `cabinetCode`
     * const cabinetSupplierWithCabinetCodeOnly = await prisma.cabinetSupplier.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetSupplier.
     * @param {CabinetSupplierDeleteArgs} args - Arguments to delete one CabinetSupplier.
     * @example
     * // Delete one CabinetSupplier
     * const CabinetSupplier = await prisma.cabinetSupplier.delete({
     *   where: {
     *     // ... filter to delete one CabinetSupplier
     *   }
     * })
     * 
     */
    delete<T extends CabinetSupplierDeleteArgs>(args: SelectSubset<T, CabinetSupplierDeleteArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetSupplier.
     * @param {CabinetSupplierUpdateArgs} args - Arguments to update one CabinetSupplier.
     * @example
     * // Update one CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetSupplierUpdateArgs>(args: SelectSubset<T, CabinetSupplierUpdateArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetSuppliers.
     * @param {CabinetSupplierDeleteManyArgs} args - Arguments to filter CabinetSuppliers to delete.
     * @example
     * // Delete a few CabinetSuppliers
     * const { count } = await prisma.cabinetSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetSupplierDeleteManyArgs>(args?: SelectSubset<T, CabinetSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetSuppliers
     * const cabinetSupplier = await prisma.cabinetSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetSupplierUpdateManyArgs>(args: SelectSubset<T, CabinetSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSuppliers and returns the data updated in the database.
     * @param {CabinetSupplierUpdateManyAndReturnArgs} args - Arguments to update many CabinetSuppliers.
     * @example
     * // Update many CabinetSuppliers
     * const cabinetSupplier = await prisma.cabinetSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetSuppliers and only return the `cabinetCode`
     * const cabinetSupplierWithCabinetCodeOnly = await prisma.cabinetSupplier.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetSupplier.
     * @param {CabinetSupplierUpsertArgs} args - Arguments to update or create a CabinetSupplier.
     * @example
     * // Update or create a CabinetSupplier
     * const cabinetSupplier = await prisma.cabinetSupplier.upsert({
     *   create: {
     *     // ... data to create a CabinetSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetSupplier we want to update
     *   }
     * })
     */
    upsert<T extends CabinetSupplierUpsertArgs>(args: SelectSubset<T, CabinetSupplierUpsertArgs<ExtArgs>>): Prisma__CabinetSupplierClient<$Result.GetResult<Prisma.$CabinetSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierCountArgs} args - Arguments to filter CabinetSuppliers to count.
     * @example
     * // Count the number of CabinetSuppliers
     * const count = await prisma.cabinetSupplier.count({
     *   where: {
     *     // ... the filter for the CabinetSuppliers we want to count
     *   }
     * })
    **/
    count<T extends CabinetSupplierCountArgs>(
      args?: Subset<T, CabinetSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetSupplierAggregateArgs>(args: Subset<T, CabinetSupplierAggregateArgs>): Prisma.PrismaPromise<GetCabinetSupplierAggregateType<T>>

    /**
     * Group by CabinetSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetSupplierGroupByArgs['orderBy'] }
        : { orderBy?: CabinetSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetSupplier model
   */
  readonly fields: CabinetSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetSupplier model
   */
  interface CabinetSupplierFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetSupplier", 'String'>
    readonly supplierCode: FieldRef<"CabinetSupplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetSupplier findUnique
   */
  export type CabinetSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSupplier to fetch.
     */
    where: CabinetSupplierWhereUniqueInput
  }

  /**
   * CabinetSupplier findUniqueOrThrow
   */
  export type CabinetSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSupplier to fetch.
     */
    where: CabinetSupplierWhereUniqueInput
  }

  /**
   * CabinetSupplier findFirst
   */
  export type CabinetSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSupplier to fetch.
     */
    where?: CabinetSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSuppliers to fetch.
     */
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSuppliers.
     */
    cursor?: CabinetSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSuppliers.
     */
    distinct?: CabinetSupplierScalarFieldEnum | CabinetSupplierScalarFieldEnum[]
  }

  /**
   * CabinetSupplier findFirstOrThrow
   */
  export type CabinetSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSupplier to fetch.
     */
    where?: CabinetSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSuppliers to fetch.
     */
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSuppliers.
     */
    cursor?: CabinetSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSuppliers.
     */
    distinct?: CabinetSupplierScalarFieldEnum | CabinetSupplierScalarFieldEnum[]
  }

  /**
   * CabinetSupplier findMany
   */
  export type CabinetSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSuppliers to fetch.
     */
    where?: CabinetSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSuppliers to fetch.
     */
    orderBy?: CabinetSupplierOrderByWithRelationInput | CabinetSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetSuppliers.
     */
    cursor?: CabinetSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSuppliers.
     */
    skip?: number
    distinct?: CabinetSupplierScalarFieldEnum | CabinetSupplierScalarFieldEnum[]
  }

  /**
   * CabinetSupplier create
   */
  export type CabinetSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetSupplier.
     */
    data: XOR<CabinetSupplierCreateInput, CabinetSupplierUncheckedCreateInput>
  }

  /**
   * CabinetSupplier createMany
   */
  export type CabinetSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetSuppliers.
     */
    data: CabinetSupplierCreateManyInput | CabinetSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetSupplier createManyAndReturn
   */
  export type CabinetSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetSuppliers.
     */
    data: CabinetSupplierCreateManyInput | CabinetSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSupplier update
   */
  export type CabinetSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetSupplier.
     */
    data: XOR<CabinetSupplierUpdateInput, CabinetSupplierUncheckedUpdateInput>
    /**
     * Choose, which CabinetSupplier to update.
     */
    where: CabinetSupplierWhereUniqueInput
  }

  /**
   * CabinetSupplier updateMany
   */
  export type CabinetSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetSuppliers.
     */
    data: XOR<CabinetSupplierUpdateManyMutationInput, CabinetSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSuppliers to update
     */
    where?: CabinetSupplierWhereInput
    /**
     * Limit how many CabinetSuppliers to update.
     */
    limit?: number
  }

  /**
   * CabinetSupplier updateManyAndReturn
   */
  export type CabinetSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * The data used to update CabinetSuppliers.
     */
    data: XOR<CabinetSupplierUpdateManyMutationInput, CabinetSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSuppliers to update
     */
    where?: CabinetSupplierWhereInput
    /**
     * Limit how many CabinetSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSupplier upsert
   */
  export type CabinetSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetSupplier to update in case it exists.
     */
    where: CabinetSupplierWhereUniqueInput
    /**
     * In case the CabinetSupplier found by the `where` argument doesn't exist, create a new CabinetSupplier with this data.
     */
    create: XOR<CabinetSupplierCreateInput, CabinetSupplierUncheckedCreateInput>
    /**
     * In case the CabinetSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetSupplierUpdateInput, CabinetSupplierUncheckedUpdateInput>
  }

  /**
   * CabinetSupplier delete
   */
  export type CabinetSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
    /**
     * Filter which CabinetSupplier to delete.
     */
    where: CabinetSupplierWhereUniqueInput
  }

  /**
   * CabinetSupplier deleteMany
   */
  export type CabinetSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSuppliers to delete
     */
    where?: CabinetSupplierWhereInput
    /**
     * Limit how many CabinetSuppliers to delete.
     */
    limit?: number
  }

  /**
   * CabinetSupplier without action
   */
  export type CabinetSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSupplier
     */
    select?: CabinetSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSupplier
     */
    omit?: CabinetSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSupplierInclude<ExtArgs> | null
  }


  /**
   * Model CabinetItemComponent
   */

  export type AggregateCabinetItemComponent = {
    _count: CabinetItemComponentCountAggregateOutputType | null
    _avg: CabinetItemComponentAvgAggregateOutputType | null
    _sum: CabinetItemComponentSumAggregateOutputType | null
    _min: CabinetItemComponentMinAggregateOutputType | null
    _max: CabinetItemComponentMaxAggregateOutputType | null
  }

  export type CabinetItemComponentAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CabinetItemComponentSumAggregateOutputType = {
    quantity: number | null
  }

  export type CabinetItemComponentMinAggregateOutputType = {
    cabinetCode: string | null
    itemCode: string | null
    quantity: number | null
  }

  export type CabinetItemComponentMaxAggregateOutputType = {
    cabinetCode: string | null
    itemCode: string | null
    quantity: number | null
  }

  export type CabinetItemComponentCountAggregateOutputType = {
    cabinetCode: number
    itemCode: number
    quantity: number
    _all: number
  }


  export type CabinetItemComponentAvgAggregateInputType = {
    quantity?: true
  }

  export type CabinetItemComponentSumAggregateInputType = {
    quantity?: true
  }

  export type CabinetItemComponentMinAggregateInputType = {
    cabinetCode?: true
    itemCode?: true
    quantity?: true
  }

  export type CabinetItemComponentMaxAggregateInputType = {
    cabinetCode?: true
    itemCode?: true
    quantity?: true
  }

  export type CabinetItemComponentCountAggregateInputType = {
    cabinetCode?: true
    itemCode?: true
    quantity?: true
    _all?: true
  }

  export type CabinetItemComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetItemComponent to aggregate.
     */
    where?: CabinetItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetItemComponents to fetch.
     */
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetItemComponents
    **/
    _count?: true | CabinetItemComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CabinetItemComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CabinetItemComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetItemComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetItemComponentMaxAggregateInputType
  }

  export type GetCabinetItemComponentAggregateType<T extends CabinetItemComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetItemComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetItemComponent[P]>
      : GetScalarType<T[P], AggregateCabinetItemComponent[P]>
  }




  export type CabinetItemComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetItemComponentWhereInput
    orderBy?: CabinetItemComponentOrderByWithAggregationInput | CabinetItemComponentOrderByWithAggregationInput[]
    by: CabinetItemComponentScalarFieldEnum[] | CabinetItemComponentScalarFieldEnum
    having?: CabinetItemComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetItemComponentCountAggregateInputType | true
    _avg?: CabinetItemComponentAvgAggregateInputType
    _sum?: CabinetItemComponentSumAggregateInputType
    _min?: CabinetItemComponentMinAggregateInputType
    _max?: CabinetItemComponentMaxAggregateInputType
  }

  export type CabinetItemComponentGroupByOutputType = {
    cabinetCode: string
    itemCode: string
    quantity: number
    _count: CabinetItemComponentCountAggregateOutputType | null
    _avg: CabinetItemComponentAvgAggregateOutputType | null
    _sum: CabinetItemComponentSumAggregateOutputType | null
    _min: CabinetItemComponentMinAggregateOutputType | null
    _max: CabinetItemComponentMaxAggregateOutputType | null
  }

  type GetCabinetItemComponentGroupByPayload<T extends CabinetItemComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetItemComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetItemComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetItemComponentGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetItemComponentGroupByOutputType[P]>
        }
      >
    >


  export type CabinetItemComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetItemComponent"]>

  export type CabinetItemComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetItemComponent"]>

  export type CabinetItemComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetItemComponent"]>

  export type CabinetItemComponentSelectScalar = {
    cabinetCode?: boolean
    itemCode?: boolean
    quantity?: boolean
  }

  export type CabinetItemComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "itemCode" | "quantity", ExtArgs["result"]["cabinetItemComponent"]>
  export type CabinetItemComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type CabinetItemComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type CabinetItemComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $CabinetItemComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetItemComponent"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      itemCode: string
      quantity: number
    }, ExtArgs["result"]["cabinetItemComponent"]>
    composites: {}
  }

  type CabinetItemComponentGetPayload<S extends boolean | null | undefined | CabinetItemComponentDefaultArgs> = $Result.GetResult<Prisma.$CabinetItemComponentPayload, S>

  type CabinetItemComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetItemComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetItemComponentCountAggregateInputType | true
    }

  export interface CabinetItemComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetItemComponent'], meta: { name: 'CabinetItemComponent' } }
    /**
     * Find zero or one CabinetItemComponent that matches the filter.
     * @param {CabinetItemComponentFindUniqueArgs} args - Arguments to find a CabinetItemComponent
     * @example
     * // Get one CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetItemComponentFindUniqueArgs>(args: SelectSubset<T, CabinetItemComponentFindUniqueArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetItemComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetItemComponentFindUniqueOrThrowArgs} args - Arguments to find a CabinetItemComponent
     * @example
     * // Get one CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetItemComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetItemComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetItemComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentFindFirstArgs} args - Arguments to find a CabinetItemComponent
     * @example
     * // Get one CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetItemComponentFindFirstArgs>(args?: SelectSubset<T, CabinetItemComponentFindFirstArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetItemComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentFindFirstOrThrowArgs} args - Arguments to find a CabinetItemComponent
     * @example
     * // Get one CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetItemComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetItemComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetItemComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetItemComponents
     * const cabinetItemComponents = await prisma.cabinetItemComponent.findMany()
     * 
     * // Get first 10 CabinetItemComponents
     * const cabinetItemComponents = await prisma.cabinetItemComponent.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetItemComponentWithCabinetCodeOnly = await prisma.cabinetItemComponent.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetItemComponentFindManyArgs>(args?: SelectSubset<T, CabinetItemComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetItemComponent.
     * @param {CabinetItemComponentCreateArgs} args - Arguments to create a CabinetItemComponent.
     * @example
     * // Create one CabinetItemComponent
     * const CabinetItemComponent = await prisma.cabinetItemComponent.create({
     *   data: {
     *     // ... data to create a CabinetItemComponent
     *   }
     * })
     * 
     */
    create<T extends CabinetItemComponentCreateArgs>(args: SelectSubset<T, CabinetItemComponentCreateArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetItemComponents.
     * @param {CabinetItemComponentCreateManyArgs} args - Arguments to create many CabinetItemComponents.
     * @example
     * // Create many CabinetItemComponents
     * const cabinetItemComponent = await prisma.cabinetItemComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetItemComponentCreateManyArgs>(args?: SelectSubset<T, CabinetItemComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetItemComponents and returns the data saved in the database.
     * @param {CabinetItemComponentCreateManyAndReturnArgs} args - Arguments to create many CabinetItemComponents.
     * @example
     * // Create many CabinetItemComponents
     * const cabinetItemComponent = await prisma.cabinetItemComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetItemComponents and only return the `cabinetCode`
     * const cabinetItemComponentWithCabinetCodeOnly = await prisma.cabinetItemComponent.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetItemComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetItemComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetItemComponent.
     * @param {CabinetItemComponentDeleteArgs} args - Arguments to delete one CabinetItemComponent.
     * @example
     * // Delete one CabinetItemComponent
     * const CabinetItemComponent = await prisma.cabinetItemComponent.delete({
     *   where: {
     *     // ... filter to delete one CabinetItemComponent
     *   }
     * })
     * 
     */
    delete<T extends CabinetItemComponentDeleteArgs>(args: SelectSubset<T, CabinetItemComponentDeleteArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetItemComponent.
     * @param {CabinetItemComponentUpdateArgs} args - Arguments to update one CabinetItemComponent.
     * @example
     * // Update one CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetItemComponentUpdateArgs>(args: SelectSubset<T, CabinetItemComponentUpdateArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetItemComponents.
     * @param {CabinetItemComponentDeleteManyArgs} args - Arguments to filter CabinetItemComponents to delete.
     * @example
     * // Delete a few CabinetItemComponents
     * const { count } = await prisma.cabinetItemComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetItemComponentDeleteManyArgs>(args?: SelectSubset<T, CabinetItemComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetItemComponents
     * const cabinetItemComponent = await prisma.cabinetItemComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetItemComponentUpdateManyArgs>(args: SelectSubset<T, CabinetItemComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetItemComponents and returns the data updated in the database.
     * @param {CabinetItemComponentUpdateManyAndReturnArgs} args - Arguments to update many CabinetItemComponents.
     * @example
     * // Update many CabinetItemComponents
     * const cabinetItemComponent = await prisma.cabinetItemComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetItemComponents and only return the `cabinetCode`
     * const cabinetItemComponentWithCabinetCodeOnly = await prisma.cabinetItemComponent.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetItemComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetItemComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetItemComponent.
     * @param {CabinetItemComponentUpsertArgs} args - Arguments to update or create a CabinetItemComponent.
     * @example
     * // Update or create a CabinetItemComponent
     * const cabinetItemComponent = await prisma.cabinetItemComponent.upsert({
     *   create: {
     *     // ... data to create a CabinetItemComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetItemComponent we want to update
     *   }
     * })
     */
    upsert<T extends CabinetItemComponentUpsertArgs>(args: SelectSubset<T, CabinetItemComponentUpsertArgs<ExtArgs>>): Prisma__CabinetItemComponentClient<$Result.GetResult<Prisma.$CabinetItemComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentCountArgs} args - Arguments to filter CabinetItemComponents to count.
     * @example
     * // Count the number of CabinetItemComponents
     * const count = await prisma.cabinetItemComponent.count({
     *   where: {
     *     // ... the filter for the CabinetItemComponents we want to count
     *   }
     * })
    **/
    count<T extends CabinetItemComponentCountArgs>(
      args?: Subset<T, CabinetItemComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetItemComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetItemComponentAggregateArgs>(args: Subset<T, CabinetItemComponentAggregateArgs>): Prisma.PrismaPromise<GetCabinetItemComponentAggregateType<T>>

    /**
     * Group by CabinetItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetItemComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetItemComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetItemComponentGroupByArgs['orderBy'] }
        : { orderBy?: CabinetItemComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetItemComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetItemComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetItemComponent model
   */
  readonly fields: CabinetItemComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetItemComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetItemComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetItemComponent model
   */
  interface CabinetItemComponentFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetItemComponent", 'String'>
    readonly itemCode: FieldRef<"CabinetItemComponent", 'String'>
    readonly quantity: FieldRef<"CabinetItemComponent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CabinetItemComponent findUnique
   */
  export type CabinetItemComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetItemComponent to fetch.
     */
    where: CabinetItemComponentWhereUniqueInput
  }

  /**
   * CabinetItemComponent findUniqueOrThrow
   */
  export type CabinetItemComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetItemComponent to fetch.
     */
    where: CabinetItemComponentWhereUniqueInput
  }

  /**
   * CabinetItemComponent findFirst
   */
  export type CabinetItemComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetItemComponent to fetch.
     */
    where?: CabinetItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetItemComponents to fetch.
     */
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetItemComponents.
     */
    cursor?: CabinetItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetItemComponents.
     */
    distinct?: CabinetItemComponentScalarFieldEnum | CabinetItemComponentScalarFieldEnum[]
  }

  /**
   * CabinetItemComponent findFirstOrThrow
   */
  export type CabinetItemComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetItemComponent to fetch.
     */
    where?: CabinetItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetItemComponents to fetch.
     */
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetItemComponents.
     */
    cursor?: CabinetItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetItemComponents.
     */
    distinct?: CabinetItemComponentScalarFieldEnum | CabinetItemComponentScalarFieldEnum[]
  }

  /**
   * CabinetItemComponent findMany
   */
  export type CabinetItemComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetItemComponents to fetch.
     */
    where?: CabinetItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetItemComponents to fetch.
     */
    orderBy?: CabinetItemComponentOrderByWithRelationInput | CabinetItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetItemComponents.
     */
    cursor?: CabinetItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetItemComponents.
     */
    skip?: number
    distinct?: CabinetItemComponentScalarFieldEnum | CabinetItemComponentScalarFieldEnum[]
  }

  /**
   * CabinetItemComponent create
   */
  export type CabinetItemComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetItemComponent.
     */
    data: XOR<CabinetItemComponentCreateInput, CabinetItemComponentUncheckedCreateInput>
  }

  /**
   * CabinetItemComponent createMany
   */
  export type CabinetItemComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetItemComponents.
     */
    data: CabinetItemComponentCreateManyInput | CabinetItemComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetItemComponent createManyAndReturn
   */
  export type CabinetItemComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetItemComponents.
     */
    data: CabinetItemComponentCreateManyInput | CabinetItemComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetItemComponent update
   */
  export type CabinetItemComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetItemComponent.
     */
    data: XOR<CabinetItemComponentUpdateInput, CabinetItemComponentUncheckedUpdateInput>
    /**
     * Choose, which CabinetItemComponent to update.
     */
    where: CabinetItemComponentWhereUniqueInput
  }

  /**
   * CabinetItemComponent updateMany
   */
  export type CabinetItemComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetItemComponents.
     */
    data: XOR<CabinetItemComponentUpdateManyMutationInput, CabinetItemComponentUncheckedUpdateManyInput>
    /**
     * Filter which CabinetItemComponents to update
     */
    where?: CabinetItemComponentWhereInput
    /**
     * Limit how many CabinetItemComponents to update.
     */
    limit?: number
  }

  /**
   * CabinetItemComponent updateManyAndReturn
   */
  export type CabinetItemComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * The data used to update CabinetItemComponents.
     */
    data: XOR<CabinetItemComponentUpdateManyMutationInput, CabinetItemComponentUncheckedUpdateManyInput>
    /**
     * Filter which CabinetItemComponents to update
     */
    where?: CabinetItemComponentWhereInput
    /**
     * Limit how many CabinetItemComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetItemComponent upsert
   */
  export type CabinetItemComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetItemComponent to update in case it exists.
     */
    where: CabinetItemComponentWhereUniqueInput
    /**
     * In case the CabinetItemComponent found by the `where` argument doesn't exist, create a new CabinetItemComponent with this data.
     */
    create: XOR<CabinetItemComponentCreateInput, CabinetItemComponentUncheckedCreateInput>
    /**
     * In case the CabinetItemComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetItemComponentUpdateInput, CabinetItemComponentUncheckedUpdateInput>
  }

  /**
   * CabinetItemComponent delete
   */
  export type CabinetItemComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
    /**
     * Filter which CabinetItemComponent to delete.
     */
    where: CabinetItemComponentWhereUniqueInput
  }

  /**
   * CabinetItemComponent deleteMany
   */
  export type CabinetItemComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetItemComponents to delete
     */
    where?: CabinetItemComponentWhereInput
    /**
     * Limit how many CabinetItemComponents to delete.
     */
    limit?: number
  }

  /**
   * CabinetItemComponent without action
   */
  export type CabinetItemComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetItemComponent
     */
    select?: CabinetItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetItemComponent
     */
    omit?: CabinetItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetItemComponentInclude<ExtArgs> | null
  }


  /**
   * Model CabinetPrice
   */

  export type AggregateCabinetPrice = {
    _count: CabinetPriceCountAggregateOutputType | null
    _avg: CabinetPriceAvgAggregateOutputType | null
    _sum: CabinetPriceSumAggregateOutputType | null
    _min: CabinetPriceMinAggregateOutputType | null
    _max: CabinetPriceMaxAggregateOutputType | null
  }

  export type CabinetPriceAvgAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type CabinetPriceSumAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type CabinetPriceMinAggregateOutputType = {
    cabinetCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type CabinetPriceMaxAggregateOutputType = {
    cabinetCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type CabinetPriceCountAggregateOutputType = {
    cabinetCode: number
    priceUsd: number
    priceRub: number
    _all: number
  }


  export type CabinetPriceAvgAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type CabinetPriceSumAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type CabinetPriceMinAggregateInputType = {
    cabinetCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type CabinetPriceMaxAggregateInputType = {
    cabinetCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type CabinetPriceCountAggregateInputType = {
    cabinetCode?: true
    priceUsd?: true
    priceRub?: true
    _all?: true
  }

  export type CabinetPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPrice to aggregate.
     */
    where?: CabinetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPrices to fetch.
     */
    orderBy?: CabinetPriceOrderByWithRelationInput | CabinetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetPrices
    **/
    _count?: true | CabinetPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CabinetPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CabinetPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetPriceMaxAggregateInputType
  }

  export type GetCabinetPriceAggregateType<T extends CabinetPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetPrice[P]>
      : GetScalarType<T[P], AggregateCabinetPrice[P]>
  }




  export type CabinetPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetPriceWhereInput
    orderBy?: CabinetPriceOrderByWithAggregationInput | CabinetPriceOrderByWithAggregationInput[]
    by: CabinetPriceScalarFieldEnum[] | CabinetPriceScalarFieldEnum
    having?: CabinetPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetPriceCountAggregateInputType | true
    _avg?: CabinetPriceAvgAggregateInputType
    _sum?: CabinetPriceSumAggregateInputType
    _min?: CabinetPriceMinAggregateInputType
    _max?: CabinetPriceMaxAggregateInputType
  }

  export type CabinetPriceGroupByOutputType = {
    cabinetCode: string
    priceUsd: Decimal | null
    priceRub: Decimal | null
    _count: CabinetPriceCountAggregateOutputType | null
    _avg: CabinetPriceAvgAggregateOutputType | null
    _sum: CabinetPriceSumAggregateOutputType | null
    _min: CabinetPriceMinAggregateOutputType | null
    _max: CabinetPriceMaxAggregateOutputType | null
  }

  type GetCabinetPriceGroupByPayload<T extends CabinetPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetPriceGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetPriceGroupByOutputType[P]>
        }
      >
    >


  export type CabinetPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPrice"]>

  export type CabinetPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPrice"]>

  export type CabinetPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetPrice"]>

  export type CabinetPriceSelectScalar = {
    cabinetCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
  }

  export type CabinetPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetCode" | "priceUsd" | "priceRub", ExtArgs["result"]["cabinetPrice"]>
  export type CabinetPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }
  export type CabinetPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }
  export type CabinetPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinet?: boolean | CabinetDefaultArgs<ExtArgs>
  }

  export type $CabinetPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetPrice"
    objects: {
      cabinet: Prisma.$CabinetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetCode: string
      priceUsd: Prisma.Decimal | null
      priceRub: Prisma.Decimal | null
    }, ExtArgs["result"]["cabinetPrice"]>
    composites: {}
  }

  type CabinetPriceGetPayload<S extends boolean | null | undefined | CabinetPriceDefaultArgs> = $Result.GetResult<Prisma.$CabinetPricePayload, S>

  type CabinetPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetPriceCountAggregateInputType | true
    }

  export interface CabinetPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetPrice'], meta: { name: 'CabinetPrice' } }
    /**
     * Find zero or one CabinetPrice that matches the filter.
     * @param {CabinetPriceFindUniqueArgs} args - Arguments to find a CabinetPrice
     * @example
     * // Get one CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetPriceFindUniqueArgs>(args: SelectSubset<T, CabinetPriceFindUniqueArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetPriceFindUniqueOrThrowArgs} args - Arguments to find a CabinetPrice
     * @example
     * // Get one CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceFindFirstArgs} args - Arguments to find a CabinetPrice
     * @example
     * // Get one CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetPriceFindFirstArgs>(args?: SelectSubset<T, CabinetPriceFindFirstArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceFindFirstOrThrowArgs} args - Arguments to find a CabinetPrice
     * @example
     * // Get one CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetPrices
     * const cabinetPrices = await prisma.cabinetPrice.findMany()
     * 
     * // Get first 10 CabinetPrices
     * const cabinetPrices = await prisma.cabinetPrice.findMany({ take: 10 })
     * 
     * // Only select the `cabinetCode`
     * const cabinetPriceWithCabinetCodeOnly = await prisma.cabinetPrice.findMany({ select: { cabinetCode: true } })
     * 
     */
    findMany<T extends CabinetPriceFindManyArgs>(args?: SelectSubset<T, CabinetPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetPrice.
     * @param {CabinetPriceCreateArgs} args - Arguments to create a CabinetPrice.
     * @example
     * // Create one CabinetPrice
     * const CabinetPrice = await prisma.cabinetPrice.create({
     *   data: {
     *     // ... data to create a CabinetPrice
     *   }
     * })
     * 
     */
    create<T extends CabinetPriceCreateArgs>(args: SelectSubset<T, CabinetPriceCreateArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetPrices.
     * @param {CabinetPriceCreateManyArgs} args - Arguments to create many CabinetPrices.
     * @example
     * // Create many CabinetPrices
     * const cabinetPrice = await prisma.cabinetPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetPriceCreateManyArgs>(args?: SelectSubset<T, CabinetPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetPrices and returns the data saved in the database.
     * @param {CabinetPriceCreateManyAndReturnArgs} args - Arguments to create many CabinetPrices.
     * @example
     * // Create many CabinetPrices
     * const cabinetPrice = await prisma.cabinetPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetPrices and only return the `cabinetCode`
     * const cabinetPriceWithCabinetCodeOnly = await prisma.cabinetPrice.createManyAndReturn({
     *   select: { cabinetCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetPrice.
     * @param {CabinetPriceDeleteArgs} args - Arguments to delete one CabinetPrice.
     * @example
     * // Delete one CabinetPrice
     * const CabinetPrice = await prisma.cabinetPrice.delete({
     *   where: {
     *     // ... filter to delete one CabinetPrice
     *   }
     * })
     * 
     */
    delete<T extends CabinetPriceDeleteArgs>(args: SelectSubset<T, CabinetPriceDeleteArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetPrice.
     * @param {CabinetPriceUpdateArgs} args - Arguments to update one CabinetPrice.
     * @example
     * // Update one CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetPriceUpdateArgs>(args: SelectSubset<T, CabinetPriceUpdateArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetPrices.
     * @param {CabinetPriceDeleteManyArgs} args - Arguments to filter CabinetPrices to delete.
     * @example
     * // Delete a few CabinetPrices
     * const { count } = await prisma.cabinetPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetPriceDeleteManyArgs>(args?: SelectSubset<T, CabinetPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetPrices
     * const cabinetPrice = await prisma.cabinetPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetPriceUpdateManyArgs>(args: SelectSubset<T, CabinetPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetPrices and returns the data updated in the database.
     * @param {CabinetPriceUpdateManyAndReturnArgs} args - Arguments to update many CabinetPrices.
     * @example
     * // Update many CabinetPrices
     * const cabinetPrice = await prisma.cabinetPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetPrices and only return the `cabinetCode`
     * const cabinetPriceWithCabinetCodeOnly = await prisma.cabinetPrice.updateManyAndReturn({
     *   select: { cabinetCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetPrice.
     * @param {CabinetPriceUpsertArgs} args - Arguments to update or create a CabinetPrice.
     * @example
     * // Update or create a CabinetPrice
     * const cabinetPrice = await prisma.cabinetPrice.upsert({
     *   create: {
     *     // ... data to create a CabinetPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetPrice we want to update
     *   }
     * })
     */
    upsert<T extends CabinetPriceUpsertArgs>(args: SelectSubset<T, CabinetPriceUpsertArgs<ExtArgs>>): Prisma__CabinetPriceClient<$Result.GetResult<Prisma.$CabinetPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceCountArgs} args - Arguments to filter CabinetPrices to count.
     * @example
     * // Count the number of CabinetPrices
     * const count = await prisma.cabinetPrice.count({
     *   where: {
     *     // ... the filter for the CabinetPrices we want to count
     *   }
     * })
    **/
    count<T extends CabinetPriceCountArgs>(
      args?: Subset<T, CabinetPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetPriceAggregateArgs>(args: Subset<T, CabinetPriceAggregateArgs>): Prisma.PrismaPromise<GetCabinetPriceAggregateType<T>>

    /**
     * Group by CabinetPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetPriceGroupByArgs['orderBy'] }
        : { orderBy?: CabinetPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetPrice model
   */
  readonly fields: CabinetPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinet<T extends CabinetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetDefaultArgs<ExtArgs>>): Prisma__CabinetClient<$Result.GetResult<Prisma.$CabinetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetPrice model
   */
  interface CabinetPriceFieldRefs {
    readonly cabinetCode: FieldRef<"CabinetPrice", 'String'>
    readonly priceUsd: FieldRef<"CabinetPrice", 'Decimal'>
    readonly priceRub: FieldRef<"CabinetPrice", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CabinetPrice findUnique
   */
  export type CabinetPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPrice to fetch.
     */
    where: CabinetPriceWhereUniqueInput
  }

  /**
   * CabinetPrice findUniqueOrThrow
   */
  export type CabinetPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPrice to fetch.
     */
    where: CabinetPriceWhereUniqueInput
  }

  /**
   * CabinetPrice findFirst
   */
  export type CabinetPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPrice to fetch.
     */
    where?: CabinetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPrices to fetch.
     */
    orderBy?: CabinetPriceOrderByWithRelationInput | CabinetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPrices.
     */
    cursor?: CabinetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPrices.
     */
    distinct?: CabinetPriceScalarFieldEnum | CabinetPriceScalarFieldEnum[]
  }

  /**
   * CabinetPrice findFirstOrThrow
   */
  export type CabinetPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPrice to fetch.
     */
    where?: CabinetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPrices to fetch.
     */
    orderBy?: CabinetPriceOrderByWithRelationInput | CabinetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetPrices.
     */
    cursor?: CabinetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetPrices.
     */
    distinct?: CabinetPriceScalarFieldEnum | CabinetPriceScalarFieldEnum[]
  }

  /**
   * CabinetPrice findMany
   */
  export type CabinetPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetPrices to fetch.
     */
    where?: CabinetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetPrices to fetch.
     */
    orderBy?: CabinetPriceOrderByWithRelationInput | CabinetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetPrices.
     */
    cursor?: CabinetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetPrices.
     */
    skip?: number
    distinct?: CabinetPriceScalarFieldEnum | CabinetPriceScalarFieldEnum[]
  }

  /**
   * CabinetPrice create
   */
  export type CabinetPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetPrice.
     */
    data: XOR<CabinetPriceCreateInput, CabinetPriceUncheckedCreateInput>
  }

  /**
   * CabinetPrice createMany
   */
  export type CabinetPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetPrices.
     */
    data: CabinetPriceCreateManyInput | CabinetPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetPrice createManyAndReturn
   */
  export type CabinetPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetPrices.
     */
    data: CabinetPriceCreateManyInput | CabinetPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPrice update
   */
  export type CabinetPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetPrice.
     */
    data: XOR<CabinetPriceUpdateInput, CabinetPriceUncheckedUpdateInput>
    /**
     * Choose, which CabinetPrice to update.
     */
    where: CabinetPriceWhereUniqueInput
  }

  /**
   * CabinetPrice updateMany
   */
  export type CabinetPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetPrices.
     */
    data: XOR<CabinetPriceUpdateManyMutationInput, CabinetPriceUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPrices to update
     */
    where?: CabinetPriceWhereInput
    /**
     * Limit how many CabinetPrices to update.
     */
    limit?: number
  }

  /**
   * CabinetPrice updateManyAndReturn
   */
  export type CabinetPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * The data used to update CabinetPrices.
     */
    data: XOR<CabinetPriceUpdateManyMutationInput, CabinetPriceUncheckedUpdateManyInput>
    /**
     * Filter which CabinetPrices to update
     */
    where?: CabinetPriceWhereInput
    /**
     * Limit how many CabinetPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetPrice upsert
   */
  export type CabinetPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetPrice to update in case it exists.
     */
    where: CabinetPriceWhereUniqueInput
    /**
     * In case the CabinetPrice found by the `where` argument doesn't exist, create a new CabinetPrice with this data.
     */
    create: XOR<CabinetPriceCreateInput, CabinetPriceUncheckedCreateInput>
    /**
     * In case the CabinetPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetPriceUpdateInput, CabinetPriceUncheckedUpdateInput>
  }

  /**
   * CabinetPrice delete
   */
  export type CabinetPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
    /**
     * Filter which CabinetPrice to delete.
     */
    where: CabinetPriceWhereUniqueInput
  }

  /**
   * CabinetPrice deleteMany
   */
  export type CabinetPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetPrices to delete
     */
    where?: CabinetPriceWhereInput
    /**
     * Limit how many CabinetPrices to delete.
     */
    limit?: number
  }

  /**
   * CabinetPrice without action
   */
  export type CabinetPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetPrice
     */
    select?: CabinetPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetPrice
     */
    omit?: CabinetPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetPriceInclude<ExtArgs> | null
  }


  /**
   * Model ModuleCategory
   */

  export type AggregateModuleCategory = {
    _count: ModuleCategoryCountAggregateOutputType | null
    _min: ModuleCategoryMinAggregateOutputType | null
    _max: ModuleCategoryMaxAggregateOutputType | null
  }

  export type ModuleCategoryMinAggregateOutputType = {
    moduleCode: string | null
    categoryCode: string | null
  }

  export type ModuleCategoryMaxAggregateOutputType = {
    moduleCode: string | null
    categoryCode: string | null
  }

  export type ModuleCategoryCountAggregateOutputType = {
    moduleCode: number
    categoryCode: number
    _all: number
  }


  export type ModuleCategoryMinAggregateInputType = {
    moduleCode?: true
    categoryCode?: true
  }

  export type ModuleCategoryMaxAggregateInputType = {
    moduleCode?: true
    categoryCode?: true
  }

  export type ModuleCategoryCountAggregateInputType = {
    moduleCode?: true
    categoryCode?: true
    _all?: true
  }

  export type ModuleCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleCategory to aggregate.
     */
    where?: ModuleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleCategories to fetch.
     */
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleCategories
    **/
    _count?: true | ModuleCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleCategoryMaxAggregateInputType
  }

  export type GetModuleCategoryAggregateType<T extends ModuleCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleCategory[P]>
      : GetScalarType<T[P], AggregateModuleCategory[P]>
  }




  export type ModuleCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleCategoryWhereInput
    orderBy?: ModuleCategoryOrderByWithAggregationInput | ModuleCategoryOrderByWithAggregationInput[]
    by: ModuleCategoryScalarFieldEnum[] | ModuleCategoryScalarFieldEnum
    having?: ModuleCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCategoryCountAggregateInputType | true
    _min?: ModuleCategoryMinAggregateInputType
    _max?: ModuleCategoryMaxAggregateInputType
  }

  export type ModuleCategoryGroupByOutputType = {
    moduleCode: string
    categoryCode: string
    _count: ModuleCategoryCountAggregateOutputType | null
    _min: ModuleCategoryMinAggregateOutputType | null
    _max: ModuleCategoryMaxAggregateOutputType | null
  }

  type GetModuleCategoryGroupByPayload<T extends ModuleCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ModuleCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    categoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleCategory"]>

  export type ModuleCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    categoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleCategory"]>

  export type ModuleCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    categoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleCategory"]>

  export type ModuleCategorySelectScalar = {
    moduleCode?: boolean
    categoryCode?: boolean
  }

  export type ModuleCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "categoryCode", ExtArgs["result"]["moduleCategory"]>
  export type ModuleCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type ModuleCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type ModuleCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    category?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $ModuleCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleCategory"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      category: Prisma.$ItemCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      categoryCode: string
    }, ExtArgs["result"]["moduleCategory"]>
    composites: {}
  }

  type ModuleCategoryGetPayload<S extends boolean | null | undefined | ModuleCategoryDefaultArgs> = $Result.GetResult<Prisma.$ModuleCategoryPayload, S>

  type ModuleCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCategoryCountAggregateInputType | true
    }

  export interface ModuleCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleCategory'], meta: { name: 'ModuleCategory' } }
    /**
     * Find zero or one ModuleCategory that matches the filter.
     * @param {ModuleCategoryFindUniqueArgs} args - Arguments to find a ModuleCategory
     * @example
     * // Get one ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleCategoryFindUniqueArgs>(args: SelectSubset<T, ModuleCategoryFindUniqueArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleCategoryFindUniqueOrThrowArgs} args - Arguments to find a ModuleCategory
     * @example
     * // Get one ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryFindFirstArgs} args - Arguments to find a ModuleCategory
     * @example
     * // Get one ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleCategoryFindFirstArgs>(args?: SelectSubset<T, ModuleCategoryFindFirstArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryFindFirstOrThrowArgs} args - Arguments to find a ModuleCategory
     * @example
     * // Get one ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleCategories
     * const moduleCategories = await prisma.moduleCategory.findMany()
     * 
     * // Get first 10 ModuleCategories
     * const moduleCategories = await prisma.moduleCategory.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleCategoryWithModuleCodeOnly = await prisma.moduleCategory.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleCategoryFindManyArgs>(args?: SelectSubset<T, ModuleCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleCategory.
     * @param {ModuleCategoryCreateArgs} args - Arguments to create a ModuleCategory.
     * @example
     * // Create one ModuleCategory
     * const ModuleCategory = await prisma.moduleCategory.create({
     *   data: {
     *     // ... data to create a ModuleCategory
     *   }
     * })
     * 
     */
    create<T extends ModuleCategoryCreateArgs>(args: SelectSubset<T, ModuleCategoryCreateArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleCategories.
     * @param {ModuleCategoryCreateManyArgs} args - Arguments to create many ModuleCategories.
     * @example
     * // Create many ModuleCategories
     * const moduleCategory = await prisma.moduleCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCategoryCreateManyArgs>(args?: SelectSubset<T, ModuleCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleCategories and returns the data saved in the database.
     * @param {ModuleCategoryCreateManyAndReturnArgs} args - Arguments to create many ModuleCategories.
     * @example
     * // Create many ModuleCategories
     * const moduleCategory = await prisma.moduleCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleCategories and only return the `moduleCode`
     * const moduleCategoryWithModuleCodeOnly = await prisma.moduleCategory.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleCategory.
     * @param {ModuleCategoryDeleteArgs} args - Arguments to delete one ModuleCategory.
     * @example
     * // Delete one ModuleCategory
     * const ModuleCategory = await prisma.moduleCategory.delete({
     *   where: {
     *     // ... filter to delete one ModuleCategory
     *   }
     * })
     * 
     */
    delete<T extends ModuleCategoryDeleteArgs>(args: SelectSubset<T, ModuleCategoryDeleteArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleCategory.
     * @param {ModuleCategoryUpdateArgs} args - Arguments to update one ModuleCategory.
     * @example
     * // Update one ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleCategoryUpdateArgs>(args: SelectSubset<T, ModuleCategoryUpdateArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleCategories.
     * @param {ModuleCategoryDeleteManyArgs} args - Arguments to filter ModuleCategories to delete.
     * @example
     * // Delete a few ModuleCategories
     * const { count } = await prisma.moduleCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleCategoryDeleteManyArgs>(args?: SelectSubset<T, ModuleCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleCategories
     * const moduleCategory = await prisma.moduleCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleCategoryUpdateManyArgs>(args: SelectSubset<T, ModuleCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleCategories and returns the data updated in the database.
     * @param {ModuleCategoryUpdateManyAndReturnArgs} args - Arguments to update many ModuleCategories.
     * @example
     * // Update many ModuleCategories
     * const moduleCategory = await prisma.moduleCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleCategories and only return the `moduleCode`
     * const moduleCategoryWithModuleCodeOnly = await prisma.moduleCategory.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleCategory.
     * @param {ModuleCategoryUpsertArgs} args - Arguments to update or create a ModuleCategory.
     * @example
     * // Update or create a ModuleCategory
     * const moduleCategory = await prisma.moduleCategory.upsert({
     *   create: {
     *     // ... data to create a ModuleCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleCategory we want to update
     *   }
     * })
     */
    upsert<T extends ModuleCategoryUpsertArgs>(args: SelectSubset<T, ModuleCategoryUpsertArgs<ExtArgs>>): Prisma__ModuleCategoryClient<$Result.GetResult<Prisma.$ModuleCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryCountArgs} args - Arguments to filter ModuleCategories to count.
     * @example
     * // Count the number of ModuleCategories
     * const count = await prisma.moduleCategory.count({
     *   where: {
     *     // ... the filter for the ModuleCategories we want to count
     *   }
     * })
    **/
    count<T extends ModuleCategoryCountArgs>(
      args?: Subset<T, ModuleCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleCategoryAggregateArgs>(args: Subset<T, ModuleCategoryAggregateArgs>): Prisma.PrismaPromise<GetModuleCategoryAggregateType<T>>

    /**
     * Group by ModuleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ModuleCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleCategory model
   */
  readonly fields: ModuleCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleCategory model
   */
  interface ModuleCategoryFieldRefs {
    readonly moduleCode: FieldRef<"ModuleCategory", 'String'>
    readonly categoryCode: FieldRef<"ModuleCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleCategory findUnique
   */
  export type ModuleCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleCategory to fetch.
     */
    where: ModuleCategoryWhereUniqueInput
  }

  /**
   * ModuleCategory findUniqueOrThrow
   */
  export type ModuleCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleCategory to fetch.
     */
    where: ModuleCategoryWhereUniqueInput
  }

  /**
   * ModuleCategory findFirst
   */
  export type ModuleCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleCategory to fetch.
     */
    where?: ModuleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleCategories to fetch.
     */
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleCategories.
     */
    cursor?: ModuleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleCategories.
     */
    distinct?: ModuleCategoryScalarFieldEnum | ModuleCategoryScalarFieldEnum[]
  }

  /**
   * ModuleCategory findFirstOrThrow
   */
  export type ModuleCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleCategory to fetch.
     */
    where?: ModuleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleCategories to fetch.
     */
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleCategories.
     */
    cursor?: ModuleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleCategories.
     */
    distinct?: ModuleCategoryScalarFieldEnum | ModuleCategoryScalarFieldEnum[]
  }

  /**
   * ModuleCategory findMany
   */
  export type ModuleCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleCategories to fetch.
     */
    where?: ModuleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleCategories to fetch.
     */
    orderBy?: ModuleCategoryOrderByWithRelationInput | ModuleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleCategories.
     */
    cursor?: ModuleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleCategories.
     */
    skip?: number
    distinct?: ModuleCategoryScalarFieldEnum | ModuleCategoryScalarFieldEnum[]
  }

  /**
   * ModuleCategory create
   */
  export type ModuleCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleCategory.
     */
    data: XOR<ModuleCategoryCreateInput, ModuleCategoryUncheckedCreateInput>
  }

  /**
   * ModuleCategory createMany
   */
  export type ModuleCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleCategories.
     */
    data: ModuleCategoryCreateManyInput | ModuleCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleCategory createManyAndReturn
   */
  export type ModuleCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleCategories.
     */
    data: ModuleCategoryCreateManyInput | ModuleCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleCategory update
   */
  export type ModuleCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleCategory.
     */
    data: XOR<ModuleCategoryUpdateInput, ModuleCategoryUncheckedUpdateInput>
    /**
     * Choose, which ModuleCategory to update.
     */
    where: ModuleCategoryWhereUniqueInput
  }

  /**
   * ModuleCategory updateMany
   */
  export type ModuleCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleCategories.
     */
    data: XOR<ModuleCategoryUpdateManyMutationInput, ModuleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ModuleCategories to update
     */
    where?: ModuleCategoryWhereInput
    /**
     * Limit how many ModuleCategories to update.
     */
    limit?: number
  }

  /**
   * ModuleCategory updateManyAndReturn
   */
  export type ModuleCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ModuleCategories.
     */
    data: XOR<ModuleCategoryUpdateManyMutationInput, ModuleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ModuleCategories to update
     */
    where?: ModuleCategoryWhereInput
    /**
     * Limit how many ModuleCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleCategory upsert
   */
  export type ModuleCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleCategory to update in case it exists.
     */
    where: ModuleCategoryWhereUniqueInput
    /**
     * In case the ModuleCategory found by the `where` argument doesn't exist, create a new ModuleCategory with this data.
     */
    create: XOR<ModuleCategoryCreateInput, ModuleCategoryUncheckedCreateInput>
    /**
     * In case the ModuleCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleCategoryUpdateInput, ModuleCategoryUncheckedUpdateInput>
  }

  /**
   * ModuleCategory delete
   */
  export type ModuleCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
    /**
     * Filter which ModuleCategory to delete.
     */
    where: ModuleCategoryWhereUniqueInput
  }

  /**
   * ModuleCategory deleteMany
   */
  export type ModuleCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleCategories to delete
     */
    where?: ModuleCategoryWhereInput
    /**
     * Limit how many ModuleCategories to delete.
     */
    limit?: number
  }

  /**
   * ModuleCategory without action
   */
  export type ModuleCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCategory
     */
    select?: ModuleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleCategory
     */
    omit?: ModuleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ModuleSubcategory
   */

  export type AggregateModuleSubcategory = {
    _count: ModuleSubcategoryCountAggregateOutputType | null
    _min: ModuleSubcategoryMinAggregateOutputType | null
    _max: ModuleSubcategoryMaxAggregateOutputType | null
  }

  export type ModuleSubcategoryMinAggregateOutputType = {
    moduleCode: string | null
    subcategoryCode: string | null
  }

  export type ModuleSubcategoryMaxAggregateOutputType = {
    moduleCode: string | null
    subcategoryCode: string | null
  }

  export type ModuleSubcategoryCountAggregateOutputType = {
    moduleCode: number
    subcategoryCode: number
    _all: number
  }


  export type ModuleSubcategoryMinAggregateInputType = {
    moduleCode?: true
    subcategoryCode?: true
  }

  export type ModuleSubcategoryMaxAggregateInputType = {
    moduleCode?: true
    subcategoryCode?: true
  }

  export type ModuleSubcategoryCountAggregateInputType = {
    moduleCode?: true
    subcategoryCode?: true
    _all?: true
  }

  export type ModuleSubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleSubcategory to aggregate.
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSubcategories to fetch.
     */
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleSubcategories
    **/
    _count?: true | ModuleSubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleSubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleSubcategoryMaxAggregateInputType
  }

  export type GetModuleSubcategoryAggregateType<T extends ModuleSubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleSubcategory[P]>
      : GetScalarType<T[P], AggregateModuleSubcategory[P]>
  }




  export type ModuleSubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleSubcategoryWhereInput
    orderBy?: ModuleSubcategoryOrderByWithAggregationInput | ModuleSubcategoryOrderByWithAggregationInput[]
    by: ModuleSubcategoryScalarFieldEnum[] | ModuleSubcategoryScalarFieldEnum
    having?: ModuleSubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleSubcategoryCountAggregateInputType | true
    _min?: ModuleSubcategoryMinAggregateInputType
    _max?: ModuleSubcategoryMaxAggregateInputType
  }

  export type ModuleSubcategoryGroupByOutputType = {
    moduleCode: string
    subcategoryCode: string
    _count: ModuleSubcategoryCountAggregateOutputType | null
    _min: ModuleSubcategoryMinAggregateOutputType | null
    _max: ModuleSubcategoryMaxAggregateOutputType | null
  }

  type GetModuleSubcategoryGroupByPayload<T extends ModuleSubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleSubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleSubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleSubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleSubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    subcategoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleSubcategory"]>

  export type ModuleSubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    subcategoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleSubcategory"]>

  export type ModuleSubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    subcategoryCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleSubcategory"]>

  export type ModuleSubcategorySelectScalar = {
    moduleCode?: boolean
    subcategoryCode?: boolean
  }

  export type ModuleSubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "subcategoryCode", ExtArgs["result"]["moduleSubcategory"]>
  export type ModuleSubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ModuleSubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }
  export type ModuleSubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    subcategory?: boolean | ItemSubcategoryDefaultArgs<ExtArgs>
  }

  export type $ModuleSubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleSubcategory"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      subcategory: Prisma.$ItemSubcategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      subcategoryCode: string
    }, ExtArgs["result"]["moduleSubcategory"]>
    composites: {}
  }

  type ModuleSubcategoryGetPayload<S extends boolean | null | undefined | ModuleSubcategoryDefaultArgs> = $Result.GetResult<Prisma.$ModuleSubcategoryPayload, S>

  type ModuleSubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleSubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleSubcategoryCountAggregateInputType | true
    }

  export interface ModuleSubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleSubcategory'], meta: { name: 'ModuleSubcategory' } }
    /**
     * Find zero or one ModuleSubcategory that matches the filter.
     * @param {ModuleSubcategoryFindUniqueArgs} args - Arguments to find a ModuleSubcategory
     * @example
     * // Get one ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleSubcategoryFindUniqueArgs>(args: SelectSubset<T, ModuleSubcategoryFindUniqueArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleSubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleSubcategoryFindUniqueOrThrowArgs} args - Arguments to find a ModuleSubcategory
     * @example
     * // Get one ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleSubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleSubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleSubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryFindFirstArgs} args - Arguments to find a ModuleSubcategory
     * @example
     * // Get one ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleSubcategoryFindFirstArgs>(args?: SelectSubset<T, ModuleSubcategoryFindFirstArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleSubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryFindFirstOrThrowArgs} args - Arguments to find a ModuleSubcategory
     * @example
     * // Get one ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleSubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleSubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleSubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleSubcategories
     * const moduleSubcategories = await prisma.moduleSubcategory.findMany()
     * 
     * // Get first 10 ModuleSubcategories
     * const moduleSubcategories = await prisma.moduleSubcategory.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleSubcategoryWithModuleCodeOnly = await prisma.moduleSubcategory.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleSubcategoryFindManyArgs>(args?: SelectSubset<T, ModuleSubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleSubcategory.
     * @param {ModuleSubcategoryCreateArgs} args - Arguments to create a ModuleSubcategory.
     * @example
     * // Create one ModuleSubcategory
     * const ModuleSubcategory = await prisma.moduleSubcategory.create({
     *   data: {
     *     // ... data to create a ModuleSubcategory
     *   }
     * })
     * 
     */
    create<T extends ModuleSubcategoryCreateArgs>(args: SelectSubset<T, ModuleSubcategoryCreateArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleSubcategories.
     * @param {ModuleSubcategoryCreateManyArgs} args - Arguments to create many ModuleSubcategories.
     * @example
     * // Create many ModuleSubcategories
     * const moduleSubcategory = await prisma.moduleSubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleSubcategoryCreateManyArgs>(args?: SelectSubset<T, ModuleSubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleSubcategories and returns the data saved in the database.
     * @param {ModuleSubcategoryCreateManyAndReturnArgs} args - Arguments to create many ModuleSubcategories.
     * @example
     * // Create many ModuleSubcategories
     * const moduleSubcategory = await prisma.moduleSubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleSubcategories and only return the `moduleCode`
     * const moduleSubcategoryWithModuleCodeOnly = await prisma.moduleSubcategory.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleSubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleSubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleSubcategory.
     * @param {ModuleSubcategoryDeleteArgs} args - Arguments to delete one ModuleSubcategory.
     * @example
     * // Delete one ModuleSubcategory
     * const ModuleSubcategory = await prisma.moduleSubcategory.delete({
     *   where: {
     *     // ... filter to delete one ModuleSubcategory
     *   }
     * })
     * 
     */
    delete<T extends ModuleSubcategoryDeleteArgs>(args: SelectSubset<T, ModuleSubcategoryDeleteArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleSubcategory.
     * @param {ModuleSubcategoryUpdateArgs} args - Arguments to update one ModuleSubcategory.
     * @example
     * // Update one ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleSubcategoryUpdateArgs>(args: SelectSubset<T, ModuleSubcategoryUpdateArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleSubcategories.
     * @param {ModuleSubcategoryDeleteManyArgs} args - Arguments to filter ModuleSubcategories to delete.
     * @example
     * // Delete a few ModuleSubcategories
     * const { count } = await prisma.moduleSubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleSubcategoryDeleteManyArgs>(args?: SelectSubset<T, ModuleSubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleSubcategories
     * const moduleSubcategory = await prisma.moduleSubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleSubcategoryUpdateManyArgs>(args: SelectSubset<T, ModuleSubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleSubcategories and returns the data updated in the database.
     * @param {ModuleSubcategoryUpdateManyAndReturnArgs} args - Arguments to update many ModuleSubcategories.
     * @example
     * // Update many ModuleSubcategories
     * const moduleSubcategory = await prisma.moduleSubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleSubcategories and only return the `moduleCode`
     * const moduleSubcategoryWithModuleCodeOnly = await prisma.moduleSubcategory.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleSubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleSubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleSubcategory.
     * @param {ModuleSubcategoryUpsertArgs} args - Arguments to update or create a ModuleSubcategory.
     * @example
     * // Update or create a ModuleSubcategory
     * const moduleSubcategory = await prisma.moduleSubcategory.upsert({
     *   create: {
     *     // ... data to create a ModuleSubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleSubcategory we want to update
     *   }
     * })
     */
    upsert<T extends ModuleSubcategoryUpsertArgs>(args: SelectSubset<T, ModuleSubcategoryUpsertArgs<ExtArgs>>): Prisma__ModuleSubcategoryClient<$Result.GetResult<Prisma.$ModuleSubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryCountArgs} args - Arguments to filter ModuleSubcategories to count.
     * @example
     * // Count the number of ModuleSubcategories
     * const count = await prisma.moduleSubcategory.count({
     *   where: {
     *     // ... the filter for the ModuleSubcategories we want to count
     *   }
     * })
    **/
    count<T extends ModuleSubcategoryCountArgs>(
      args?: Subset<T, ModuleSubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleSubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleSubcategoryAggregateArgs>(args: Subset<T, ModuleSubcategoryAggregateArgs>): Prisma.PrismaPromise<GetModuleSubcategoryAggregateType<T>>

    /**
     * Group by ModuleSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleSubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleSubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleSubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: ModuleSubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleSubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleSubcategory model
   */
  readonly fields: ModuleSubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleSubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleSubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ItemSubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemSubcategoryDefaultArgs<ExtArgs>>): Prisma__ItemSubcategoryClient<$Result.GetResult<Prisma.$ItemSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleSubcategory model
   */
  interface ModuleSubcategoryFieldRefs {
    readonly moduleCode: FieldRef<"ModuleSubcategory", 'String'>
    readonly subcategoryCode: FieldRef<"ModuleSubcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleSubcategory findUnique
   */
  export type ModuleSubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSubcategory to fetch.
     */
    where: ModuleSubcategoryWhereUniqueInput
  }

  /**
   * ModuleSubcategory findUniqueOrThrow
   */
  export type ModuleSubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSubcategory to fetch.
     */
    where: ModuleSubcategoryWhereUniqueInput
  }

  /**
   * ModuleSubcategory findFirst
   */
  export type ModuleSubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSubcategory to fetch.
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSubcategories to fetch.
     */
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleSubcategories.
     */
    cursor?: ModuleSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleSubcategories.
     */
    distinct?: ModuleSubcategoryScalarFieldEnum | ModuleSubcategoryScalarFieldEnum[]
  }

  /**
   * ModuleSubcategory findFirstOrThrow
   */
  export type ModuleSubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSubcategory to fetch.
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSubcategories to fetch.
     */
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleSubcategories.
     */
    cursor?: ModuleSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleSubcategories.
     */
    distinct?: ModuleSubcategoryScalarFieldEnum | ModuleSubcategoryScalarFieldEnum[]
  }

  /**
   * ModuleSubcategory findMany
   */
  export type ModuleSubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ModuleSubcategories to fetch.
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleSubcategories to fetch.
     */
    orderBy?: ModuleSubcategoryOrderByWithRelationInput | ModuleSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleSubcategories.
     */
    cursor?: ModuleSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleSubcategories.
     */
    skip?: number
    distinct?: ModuleSubcategoryScalarFieldEnum | ModuleSubcategoryScalarFieldEnum[]
  }

  /**
   * ModuleSubcategory create
   */
  export type ModuleSubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleSubcategory.
     */
    data: XOR<ModuleSubcategoryCreateInput, ModuleSubcategoryUncheckedCreateInput>
  }

  /**
   * ModuleSubcategory createMany
   */
  export type ModuleSubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleSubcategories.
     */
    data: ModuleSubcategoryCreateManyInput | ModuleSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleSubcategory createManyAndReturn
   */
  export type ModuleSubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleSubcategories.
     */
    data: ModuleSubcategoryCreateManyInput | ModuleSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleSubcategory update
   */
  export type ModuleSubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleSubcategory.
     */
    data: XOR<ModuleSubcategoryUpdateInput, ModuleSubcategoryUncheckedUpdateInput>
    /**
     * Choose, which ModuleSubcategory to update.
     */
    where: ModuleSubcategoryWhereUniqueInput
  }

  /**
   * ModuleSubcategory updateMany
   */
  export type ModuleSubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleSubcategories.
     */
    data: XOR<ModuleSubcategoryUpdateManyMutationInput, ModuleSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ModuleSubcategories to update
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * Limit how many ModuleSubcategories to update.
     */
    limit?: number
  }

  /**
   * ModuleSubcategory updateManyAndReturn
   */
  export type ModuleSubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update ModuleSubcategories.
     */
    data: XOR<ModuleSubcategoryUpdateManyMutationInput, ModuleSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ModuleSubcategories to update
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * Limit how many ModuleSubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleSubcategory upsert
   */
  export type ModuleSubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleSubcategory to update in case it exists.
     */
    where: ModuleSubcategoryWhereUniqueInput
    /**
     * In case the ModuleSubcategory found by the `where` argument doesn't exist, create a new ModuleSubcategory with this data.
     */
    create: XOR<ModuleSubcategoryCreateInput, ModuleSubcategoryUncheckedCreateInput>
    /**
     * In case the ModuleSubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleSubcategoryUpdateInput, ModuleSubcategoryUncheckedUpdateInput>
  }

  /**
   * ModuleSubcategory delete
   */
  export type ModuleSubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
    /**
     * Filter which ModuleSubcategory to delete.
     */
    where: ModuleSubcategoryWhereUniqueInput
  }

  /**
   * ModuleSubcategory deleteMany
   */
  export type ModuleSubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleSubcategories to delete
     */
    where?: ModuleSubcategoryWhereInput
    /**
     * Limit how many ModuleSubcategories to delete.
     */
    limit?: number
  }

  /**
   * ModuleSubcategory without action
   */
  export type ModuleSubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleSubcategory
     */
    select?: ModuleSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleSubcategory
     */
    omit?: ModuleSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleSubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model ModuleLocation
   */

  export type AggregateModuleLocation = {
    _count: ModuleLocationCountAggregateOutputType | null
    _min: ModuleLocationMinAggregateOutputType | null
    _max: ModuleLocationMaxAggregateOutputType | null
  }

  export type ModuleLocationMinAggregateOutputType = {
    moduleCode: string | null
    locationCode: string | null
  }

  export type ModuleLocationMaxAggregateOutputType = {
    moduleCode: string | null
    locationCode: string | null
  }

  export type ModuleLocationCountAggregateOutputType = {
    moduleCode: number
    locationCode: number
    _all: number
  }


  export type ModuleLocationMinAggregateInputType = {
    moduleCode?: true
    locationCode?: true
  }

  export type ModuleLocationMaxAggregateInputType = {
    moduleCode?: true
    locationCode?: true
  }

  export type ModuleLocationCountAggregateInputType = {
    moduleCode?: true
    locationCode?: true
    _all?: true
  }

  export type ModuleLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleLocation to aggregate.
     */
    where?: ModuleLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleLocations to fetch.
     */
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleLocations
    **/
    _count?: true | ModuleLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleLocationMaxAggregateInputType
  }

  export type GetModuleLocationAggregateType<T extends ModuleLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleLocation[P]>
      : GetScalarType<T[P], AggregateModuleLocation[P]>
  }




  export type ModuleLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleLocationWhereInput
    orderBy?: ModuleLocationOrderByWithAggregationInput | ModuleLocationOrderByWithAggregationInput[]
    by: ModuleLocationScalarFieldEnum[] | ModuleLocationScalarFieldEnum
    having?: ModuleLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleLocationCountAggregateInputType | true
    _min?: ModuleLocationMinAggregateInputType
    _max?: ModuleLocationMaxAggregateInputType
  }

  export type ModuleLocationGroupByOutputType = {
    moduleCode: string
    locationCode: string
    _count: ModuleLocationCountAggregateOutputType | null
    _min: ModuleLocationMinAggregateOutputType | null
    _max: ModuleLocationMaxAggregateOutputType | null
  }

  type GetModuleLocationGroupByPayload<T extends ModuleLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleLocationGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleLocationGroupByOutputType[P]>
        }
      >
    >


  export type ModuleLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    locationCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleLocation"]>

  export type ModuleLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    locationCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleLocation"]>

  export type ModuleLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    locationCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleLocation"]>

  export type ModuleLocationSelectScalar = {
    moduleCode?: boolean
    locationCode?: boolean
  }

  export type ModuleLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "locationCode", ExtArgs["result"]["moduleLocation"]>
  export type ModuleLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ModuleLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ModuleLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ModuleLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleLocation"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      locationCode: string
    }, ExtArgs["result"]["moduleLocation"]>
    composites: {}
  }

  type ModuleLocationGetPayload<S extends boolean | null | undefined | ModuleLocationDefaultArgs> = $Result.GetResult<Prisma.$ModuleLocationPayload, S>

  type ModuleLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleLocationCountAggregateInputType | true
    }

  export interface ModuleLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleLocation'], meta: { name: 'ModuleLocation' } }
    /**
     * Find zero or one ModuleLocation that matches the filter.
     * @param {ModuleLocationFindUniqueArgs} args - Arguments to find a ModuleLocation
     * @example
     * // Get one ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleLocationFindUniqueArgs>(args: SelectSubset<T, ModuleLocationFindUniqueArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleLocationFindUniqueOrThrowArgs} args - Arguments to find a ModuleLocation
     * @example
     * // Get one ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationFindFirstArgs} args - Arguments to find a ModuleLocation
     * @example
     * // Get one ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleLocationFindFirstArgs>(args?: SelectSubset<T, ModuleLocationFindFirstArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationFindFirstOrThrowArgs} args - Arguments to find a ModuleLocation
     * @example
     * // Get one ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleLocations
     * const moduleLocations = await prisma.moduleLocation.findMany()
     * 
     * // Get first 10 ModuleLocations
     * const moduleLocations = await prisma.moduleLocation.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleLocationWithModuleCodeOnly = await prisma.moduleLocation.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleLocationFindManyArgs>(args?: SelectSubset<T, ModuleLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleLocation.
     * @param {ModuleLocationCreateArgs} args - Arguments to create a ModuleLocation.
     * @example
     * // Create one ModuleLocation
     * const ModuleLocation = await prisma.moduleLocation.create({
     *   data: {
     *     // ... data to create a ModuleLocation
     *   }
     * })
     * 
     */
    create<T extends ModuleLocationCreateArgs>(args: SelectSubset<T, ModuleLocationCreateArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleLocations.
     * @param {ModuleLocationCreateManyArgs} args - Arguments to create many ModuleLocations.
     * @example
     * // Create many ModuleLocations
     * const moduleLocation = await prisma.moduleLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleLocationCreateManyArgs>(args?: SelectSubset<T, ModuleLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleLocations and returns the data saved in the database.
     * @param {ModuleLocationCreateManyAndReturnArgs} args - Arguments to create many ModuleLocations.
     * @example
     * // Create many ModuleLocations
     * const moduleLocation = await prisma.moduleLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleLocations and only return the `moduleCode`
     * const moduleLocationWithModuleCodeOnly = await prisma.moduleLocation.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleLocation.
     * @param {ModuleLocationDeleteArgs} args - Arguments to delete one ModuleLocation.
     * @example
     * // Delete one ModuleLocation
     * const ModuleLocation = await prisma.moduleLocation.delete({
     *   where: {
     *     // ... filter to delete one ModuleLocation
     *   }
     * })
     * 
     */
    delete<T extends ModuleLocationDeleteArgs>(args: SelectSubset<T, ModuleLocationDeleteArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleLocation.
     * @param {ModuleLocationUpdateArgs} args - Arguments to update one ModuleLocation.
     * @example
     * // Update one ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleLocationUpdateArgs>(args: SelectSubset<T, ModuleLocationUpdateArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleLocations.
     * @param {ModuleLocationDeleteManyArgs} args - Arguments to filter ModuleLocations to delete.
     * @example
     * // Delete a few ModuleLocations
     * const { count } = await prisma.moduleLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleLocationDeleteManyArgs>(args?: SelectSubset<T, ModuleLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleLocations
     * const moduleLocation = await prisma.moduleLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleLocationUpdateManyArgs>(args: SelectSubset<T, ModuleLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleLocations and returns the data updated in the database.
     * @param {ModuleLocationUpdateManyAndReturnArgs} args - Arguments to update many ModuleLocations.
     * @example
     * // Update many ModuleLocations
     * const moduleLocation = await prisma.moduleLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleLocations and only return the `moduleCode`
     * const moduleLocationWithModuleCodeOnly = await prisma.moduleLocation.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleLocation.
     * @param {ModuleLocationUpsertArgs} args - Arguments to update or create a ModuleLocation.
     * @example
     * // Update or create a ModuleLocation
     * const moduleLocation = await prisma.moduleLocation.upsert({
     *   create: {
     *     // ... data to create a ModuleLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleLocation we want to update
     *   }
     * })
     */
    upsert<T extends ModuleLocationUpsertArgs>(args: SelectSubset<T, ModuleLocationUpsertArgs<ExtArgs>>): Prisma__ModuleLocationClient<$Result.GetResult<Prisma.$ModuleLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationCountArgs} args - Arguments to filter ModuleLocations to count.
     * @example
     * // Count the number of ModuleLocations
     * const count = await prisma.moduleLocation.count({
     *   where: {
     *     // ... the filter for the ModuleLocations we want to count
     *   }
     * })
    **/
    count<T extends ModuleLocationCountArgs>(
      args?: Subset<T, ModuleLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleLocationAggregateArgs>(args: Subset<T, ModuleLocationAggregateArgs>): Prisma.PrismaPromise<GetModuleLocationAggregateType<T>>

    /**
     * Group by ModuleLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleLocationGroupByArgs['orderBy'] }
        : { orderBy?: ModuleLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleLocation model
   */
  readonly fields: ModuleLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleLocation model
   */
  interface ModuleLocationFieldRefs {
    readonly moduleCode: FieldRef<"ModuleLocation", 'String'>
    readonly locationCode: FieldRef<"ModuleLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleLocation findUnique
   */
  export type ModuleLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter, which ModuleLocation to fetch.
     */
    where: ModuleLocationWhereUniqueInput
  }

  /**
   * ModuleLocation findUniqueOrThrow
   */
  export type ModuleLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter, which ModuleLocation to fetch.
     */
    where: ModuleLocationWhereUniqueInput
  }

  /**
   * ModuleLocation findFirst
   */
  export type ModuleLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter, which ModuleLocation to fetch.
     */
    where?: ModuleLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleLocations to fetch.
     */
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleLocations.
     */
    cursor?: ModuleLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleLocations.
     */
    distinct?: ModuleLocationScalarFieldEnum | ModuleLocationScalarFieldEnum[]
  }

  /**
   * ModuleLocation findFirstOrThrow
   */
  export type ModuleLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter, which ModuleLocation to fetch.
     */
    where?: ModuleLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleLocations to fetch.
     */
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleLocations.
     */
    cursor?: ModuleLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleLocations.
     */
    distinct?: ModuleLocationScalarFieldEnum | ModuleLocationScalarFieldEnum[]
  }

  /**
   * ModuleLocation findMany
   */
  export type ModuleLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter, which ModuleLocations to fetch.
     */
    where?: ModuleLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleLocations to fetch.
     */
    orderBy?: ModuleLocationOrderByWithRelationInput | ModuleLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleLocations.
     */
    cursor?: ModuleLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleLocations.
     */
    skip?: number
    distinct?: ModuleLocationScalarFieldEnum | ModuleLocationScalarFieldEnum[]
  }

  /**
   * ModuleLocation create
   */
  export type ModuleLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleLocation.
     */
    data: XOR<ModuleLocationCreateInput, ModuleLocationUncheckedCreateInput>
  }

  /**
   * ModuleLocation createMany
   */
  export type ModuleLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleLocations.
     */
    data: ModuleLocationCreateManyInput | ModuleLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleLocation createManyAndReturn
   */
  export type ModuleLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleLocations.
     */
    data: ModuleLocationCreateManyInput | ModuleLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleLocation update
   */
  export type ModuleLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleLocation.
     */
    data: XOR<ModuleLocationUpdateInput, ModuleLocationUncheckedUpdateInput>
    /**
     * Choose, which ModuleLocation to update.
     */
    where: ModuleLocationWhereUniqueInput
  }

  /**
   * ModuleLocation updateMany
   */
  export type ModuleLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleLocations.
     */
    data: XOR<ModuleLocationUpdateManyMutationInput, ModuleLocationUncheckedUpdateManyInput>
    /**
     * Filter which ModuleLocations to update
     */
    where?: ModuleLocationWhereInput
    /**
     * Limit how many ModuleLocations to update.
     */
    limit?: number
  }

  /**
   * ModuleLocation updateManyAndReturn
   */
  export type ModuleLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * The data used to update ModuleLocations.
     */
    data: XOR<ModuleLocationUpdateManyMutationInput, ModuleLocationUncheckedUpdateManyInput>
    /**
     * Filter which ModuleLocations to update
     */
    where?: ModuleLocationWhereInput
    /**
     * Limit how many ModuleLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleLocation upsert
   */
  export type ModuleLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleLocation to update in case it exists.
     */
    where: ModuleLocationWhereUniqueInput
    /**
     * In case the ModuleLocation found by the `where` argument doesn't exist, create a new ModuleLocation with this data.
     */
    create: XOR<ModuleLocationCreateInput, ModuleLocationUncheckedCreateInput>
    /**
     * In case the ModuleLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleLocationUpdateInput, ModuleLocationUncheckedUpdateInput>
  }

  /**
   * ModuleLocation delete
   */
  export type ModuleLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
    /**
     * Filter which ModuleLocation to delete.
     */
    where: ModuleLocationWhereUniqueInput
  }

  /**
   * ModuleLocation deleteMany
   */
  export type ModuleLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleLocations to delete
     */
    where?: ModuleLocationWhereInput
    /**
     * Limit how many ModuleLocations to delete.
     */
    limit?: number
  }

  /**
   * ModuleLocation without action
   */
  export type ModuleLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleLocation
     */
    select?: ModuleLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleLocation
     */
    omit?: ModuleLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleLocationInclude<ExtArgs> | null
  }


  /**
   * Model ModuleRefreshRate
   */

  export type AggregateModuleRefreshRate = {
    _count: ModuleRefreshRateCountAggregateOutputType | null
    _min: ModuleRefreshRateMinAggregateOutputType | null
    _max: ModuleRefreshRateMaxAggregateOutputType | null
  }

  export type ModuleRefreshRateMinAggregateOutputType = {
    moduleCode: string | null
    refreshRateCode: string | null
  }

  export type ModuleRefreshRateMaxAggregateOutputType = {
    moduleCode: string | null
    refreshRateCode: string | null
  }

  export type ModuleRefreshRateCountAggregateOutputType = {
    moduleCode: number
    refreshRateCode: number
    _all: number
  }


  export type ModuleRefreshRateMinAggregateInputType = {
    moduleCode?: true
    refreshRateCode?: true
  }

  export type ModuleRefreshRateMaxAggregateInputType = {
    moduleCode?: true
    refreshRateCode?: true
  }

  export type ModuleRefreshRateCountAggregateInputType = {
    moduleCode?: true
    refreshRateCode?: true
    _all?: true
  }

  export type ModuleRefreshRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleRefreshRate to aggregate.
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleRefreshRates to fetch.
     */
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleRefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleRefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleRefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleRefreshRates
    **/
    _count?: true | ModuleRefreshRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleRefreshRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleRefreshRateMaxAggregateInputType
  }

  export type GetModuleRefreshRateAggregateType<T extends ModuleRefreshRateAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleRefreshRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleRefreshRate[P]>
      : GetScalarType<T[P], AggregateModuleRefreshRate[P]>
  }




  export type ModuleRefreshRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleRefreshRateWhereInput
    orderBy?: ModuleRefreshRateOrderByWithAggregationInput | ModuleRefreshRateOrderByWithAggregationInput[]
    by: ModuleRefreshRateScalarFieldEnum[] | ModuleRefreshRateScalarFieldEnum
    having?: ModuleRefreshRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleRefreshRateCountAggregateInputType | true
    _min?: ModuleRefreshRateMinAggregateInputType
    _max?: ModuleRefreshRateMaxAggregateInputType
  }

  export type ModuleRefreshRateGroupByOutputType = {
    moduleCode: string
    refreshRateCode: string
    _count: ModuleRefreshRateCountAggregateOutputType | null
    _min: ModuleRefreshRateMinAggregateOutputType | null
    _max: ModuleRefreshRateMaxAggregateOutputType | null
  }

  type GetModuleRefreshRateGroupByPayload<T extends ModuleRefreshRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleRefreshRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleRefreshRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleRefreshRateGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleRefreshRateGroupByOutputType[P]>
        }
      >
    >


  export type ModuleRefreshRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    refreshRateCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleRefreshRate"]>

  export type ModuleRefreshRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    refreshRateCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleRefreshRate"]>

  export type ModuleRefreshRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    refreshRateCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleRefreshRate"]>

  export type ModuleRefreshRateSelectScalar = {
    moduleCode?: boolean
    refreshRateCode?: boolean
  }

  export type ModuleRefreshRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "refreshRateCode", ExtArgs["result"]["moduleRefreshRate"]>
  export type ModuleRefreshRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }
  export type ModuleRefreshRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }
  export type ModuleRefreshRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    refreshRate?: boolean | RefreshRateDefaultArgs<ExtArgs>
  }

  export type $ModuleRefreshRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleRefreshRate"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      refreshRate: Prisma.$RefreshRatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      refreshRateCode: string
    }, ExtArgs["result"]["moduleRefreshRate"]>
    composites: {}
  }

  type ModuleRefreshRateGetPayload<S extends boolean | null | undefined | ModuleRefreshRateDefaultArgs> = $Result.GetResult<Prisma.$ModuleRefreshRatePayload, S>

  type ModuleRefreshRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleRefreshRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleRefreshRateCountAggregateInputType | true
    }

  export interface ModuleRefreshRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleRefreshRate'], meta: { name: 'ModuleRefreshRate' } }
    /**
     * Find zero or one ModuleRefreshRate that matches the filter.
     * @param {ModuleRefreshRateFindUniqueArgs} args - Arguments to find a ModuleRefreshRate
     * @example
     * // Get one ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleRefreshRateFindUniqueArgs>(args: SelectSubset<T, ModuleRefreshRateFindUniqueArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleRefreshRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleRefreshRateFindUniqueOrThrowArgs} args - Arguments to find a ModuleRefreshRate
     * @example
     * // Get one ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleRefreshRateFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleRefreshRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleRefreshRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateFindFirstArgs} args - Arguments to find a ModuleRefreshRate
     * @example
     * // Get one ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleRefreshRateFindFirstArgs>(args?: SelectSubset<T, ModuleRefreshRateFindFirstArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleRefreshRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateFindFirstOrThrowArgs} args - Arguments to find a ModuleRefreshRate
     * @example
     * // Get one ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleRefreshRateFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleRefreshRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleRefreshRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleRefreshRates
     * const moduleRefreshRates = await prisma.moduleRefreshRate.findMany()
     * 
     * // Get first 10 ModuleRefreshRates
     * const moduleRefreshRates = await prisma.moduleRefreshRate.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleRefreshRateWithModuleCodeOnly = await prisma.moduleRefreshRate.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleRefreshRateFindManyArgs>(args?: SelectSubset<T, ModuleRefreshRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleRefreshRate.
     * @param {ModuleRefreshRateCreateArgs} args - Arguments to create a ModuleRefreshRate.
     * @example
     * // Create one ModuleRefreshRate
     * const ModuleRefreshRate = await prisma.moduleRefreshRate.create({
     *   data: {
     *     // ... data to create a ModuleRefreshRate
     *   }
     * })
     * 
     */
    create<T extends ModuleRefreshRateCreateArgs>(args: SelectSubset<T, ModuleRefreshRateCreateArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleRefreshRates.
     * @param {ModuleRefreshRateCreateManyArgs} args - Arguments to create many ModuleRefreshRates.
     * @example
     * // Create many ModuleRefreshRates
     * const moduleRefreshRate = await prisma.moduleRefreshRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleRefreshRateCreateManyArgs>(args?: SelectSubset<T, ModuleRefreshRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleRefreshRates and returns the data saved in the database.
     * @param {ModuleRefreshRateCreateManyAndReturnArgs} args - Arguments to create many ModuleRefreshRates.
     * @example
     * // Create many ModuleRefreshRates
     * const moduleRefreshRate = await prisma.moduleRefreshRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleRefreshRates and only return the `moduleCode`
     * const moduleRefreshRateWithModuleCodeOnly = await prisma.moduleRefreshRate.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleRefreshRateCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleRefreshRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleRefreshRate.
     * @param {ModuleRefreshRateDeleteArgs} args - Arguments to delete one ModuleRefreshRate.
     * @example
     * // Delete one ModuleRefreshRate
     * const ModuleRefreshRate = await prisma.moduleRefreshRate.delete({
     *   where: {
     *     // ... filter to delete one ModuleRefreshRate
     *   }
     * })
     * 
     */
    delete<T extends ModuleRefreshRateDeleteArgs>(args: SelectSubset<T, ModuleRefreshRateDeleteArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleRefreshRate.
     * @param {ModuleRefreshRateUpdateArgs} args - Arguments to update one ModuleRefreshRate.
     * @example
     * // Update one ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleRefreshRateUpdateArgs>(args: SelectSubset<T, ModuleRefreshRateUpdateArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleRefreshRates.
     * @param {ModuleRefreshRateDeleteManyArgs} args - Arguments to filter ModuleRefreshRates to delete.
     * @example
     * // Delete a few ModuleRefreshRates
     * const { count } = await prisma.moduleRefreshRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleRefreshRateDeleteManyArgs>(args?: SelectSubset<T, ModuleRefreshRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleRefreshRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleRefreshRates
     * const moduleRefreshRate = await prisma.moduleRefreshRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleRefreshRateUpdateManyArgs>(args: SelectSubset<T, ModuleRefreshRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleRefreshRates and returns the data updated in the database.
     * @param {ModuleRefreshRateUpdateManyAndReturnArgs} args - Arguments to update many ModuleRefreshRates.
     * @example
     * // Update many ModuleRefreshRates
     * const moduleRefreshRate = await prisma.moduleRefreshRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleRefreshRates and only return the `moduleCode`
     * const moduleRefreshRateWithModuleCodeOnly = await prisma.moduleRefreshRate.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleRefreshRateUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleRefreshRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleRefreshRate.
     * @param {ModuleRefreshRateUpsertArgs} args - Arguments to update or create a ModuleRefreshRate.
     * @example
     * // Update or create a ModuleRefreshRate
     * const moduleRefreshRate = await prisma.moduleRefreshRate.upsert({
     *   create: {
     *     // ... data to create a ModuleRefreshRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleRefreshRate we want to update
     *   }
     * })
     */
    upsert<T extends ModuleRefreshRateUpsertArgs>(args: SelectSubset<T, ModuleRefreshRateUpsertArgs<ExtArgs>>): Prisma__ModuleRefreshRateClient<$Result.GetResult<Prisma.$ModuleRefreshRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleRefreshRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateCountArgs} args - Arguments to filter ModuleRefreshRates to count.
     * @example
     * // Count the number of ModuleRefreshRates
     * const count = await prisma.moduleRefreshRate.count({
     *   where: {
     *     // ... the filter for the ModuleRefreshRates we want to count
     *   }
     * })
    **/
    count<T extends ModuleRefreshRateCountArgs>(
      args?: Subset<T, ModuleRefreshRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleRefreshRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleRefreshRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleRefreshRateAggregateArgs>(args: Subset<T, ModuleRefreshRateAggregateArgs>): Prisma.PrismaPromise<GetModuleRefreshRateAggregateType<T>>

    /**
     * Group by ModuleRefreshRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleRefreshRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleRefreshRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleRefreshRateGroupByArgs['orderBy'] }
        : { orderBy?: ModuleRefreshRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleRefreshRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleRefreshRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleRefreshRate model
   */
  readonly fields: ModuleRefreshRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleRefreshRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleRefreshRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    refreshRate<T extends RefreshRateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RefreshRateDefaultArgs<ExtArgs>>): Prisma__RefreshRateClient<$Result.GetResult<Prisma.$RefreshRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleRefreshRate model
   */
  interface ModuleRefreshRateFieldRefs {
    readonly moduleCode: FieldRef<"ModuleRefreshRate", 'String'>
    readonly refreshRateCode: FieldRef<"ModuleRefreshRate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleRefreshRate findUnique
   */
  export type ModuleRefreshRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which ModuleRefreshRate to fetch.
     */
    where: ModuleRefreshRateWhereUniqueInput
  }

  /**
   * ModuleRefreshRate findUniqueOrThrow
   */
  export type ModuleRefreshRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which ModuleRefreshRate to fetch.
     */
    where: ModuleRefreshRateWhereUniqueInput
  }

  /**
   * ModuleRefreshRate findFirst
   */
  export type ModuleRefreshRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which ModuleRefreshRate to fetch.
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleRefreshRates to fetch.
     */
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleRefreshRates.
     */
    cursor?: ModuleRefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleRefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleRefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleRefreshRates.
     */
    distinct?: ModuleRefreshRateScalarFieldEnum | ModuleRefreshRateScalarFieldEnum[]
  }

  /**
   * ModuleRefreshRate findFirstOrThrow
   */
  export type ModuleRefreshRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which ModuleRefreshRate to fetch.
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleRefreshRates to fetch.
     */
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleRefreshRates.
     */
    cursor?: ModuleRefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleRefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleRefreshRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleRefreshRates.
     */
    distinct?: ModuleRefreshRateScalarFieldEnum | ModuleRefreshRateScalarFieldEnum[]
  }

  /**
   * ModuleRefreshRate findMany
   */
  export type ModuleRefreshRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter, which ModuleRefreshRates to fetch.
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleRefreshRates to fetch.
     */
    orderBy?: ModuleRefreshRateOrderByWithRelationInput | ModuleRefreshRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleRefreshRates.
     */
    cursor?: ModuleRefreshRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleRefreshRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleRefreshRates.
     */
    skip?: number
    distinct?: ModuleRefreshRateScalarFieldEnum | ModuleRefreshRateScalarFieldEnum[]
  }

  /**
   * ModuleRefreshRate create
   */
  export type ModuleRefreshRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleRefreshRate.
     */
    data: XOR<ModuleRefreshRateCreateInput, ModuleRefreshRateUncheckedCreateInput>
  }

  /**
   * ModuleRefreshRate createMany
   */
  export type ModuleRefreshRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleRefreshRates.
     */
    data: ModuleRefreshRateCreateManyInput | ModuleRefreshRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleRefreshRate createManyAndReturn
   */
  export type ModuleRefreshRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleRefreshRates.
     */
    data: ModuleRefreshRateCreateManyInput | ModuleRefreshRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleRefreshRate update
   */
  export type ModuleRefreshRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleRefreshRate.
     */
    data: XOR<ModuleRefreshRateUpdateInput, ModuleRefreshRateUncheckedUpdateInput>
    /**
     * Choose, which ModuleRefreshRate to update.
     */
    where: ModuleRefreshRateWhereUniqueInput
  }

  /**
   * ModuleRefreshRate updateMany
   */
  export type ModuleRefreshRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleRefreshRates.
     */
    data: XOR<ModuleRefreshRateUpdateManyMutationInput, ModuleRefreshRateUncheckedUpdateManyInput>
    /**
     * Filter which ModuleRefreshRates to update
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * Limit how many ModuleRefreshRates to update.
     */
    limit?: number
  }

  /**
   * ModuleRefreshRate updateManyAndReturn
   */
  export type ModuleRefreshRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * The data used to update ModuleRefreshRates.
     */
    data: XOR<ModuleRefreshRateUpdateManyMutationInput, ModuleRefreshRateUncheckedUpdateManyInput>
    /**
     * Filter which ModuleRefreshRates to update
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * Limit how many ModuleRefreshRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleRefreshRate upsert
   */
  export type ModuleRefreshRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleRefreshRate to update in case it exists.
     */
    where: ModuleRefreshRateWhereUniqueInput
    /**
     * In case the ModuleRefreshRate found by the `where` argument doesn't exist, create a new ModuleRefreshRate with this data.
     */
    create: XOR<ModuleRefreshRateCreateInput, ModuleRefreshRateUncheckedCreateInput>
    /**
     * In case the ModuleRefreshRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleRefreshRateUpdateInput, ModuleRefreshRateUncheckedUpdateInput>
  }

  /**
   * ModuleRefreshRate delete
   */
  export type ModuleRefreshRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
    /**
     * Filter which ModuleRefreshRate to delete.
     */
    where: ModuleRefreshRateWhereUniqueInput
  }

  /**
   * ModuleRefreshRate deleteMany
   */
  export type ModuleRefreshRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleRefreshRates to delete
     */
    where?: ModuleRefreshRateWhereInput
    /**
     * Limit how many ModuleRefreshRates to delete.
     */
    limit?: number
  }

  /**
   * ModuleRefreshRate without action
   */
  export type ModuleRefreshRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleRefreshRate
     */
    select?: ModuleRefreshRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleRefreshRate
     */
    omit?: ModuleRefreshRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleRefreshRateInclude<ExtArgs> | null
  }


  /**
   * Model ModuleBrightness
   */

  export type AggregateModuleBrightness = {
    _count: ModuleBrightnessCountAggregateOutputType | null
    _min: ModuleBrightnessMinAggregateOutputType | null
    _max: ModuleBrightnessMaxAggregateOutputType | null
  }

  export type ModuleBrightnessMinAggregateOutputType = {
    moduleCode: string | null
    brightnessCode: string | null
  }

  export type ModuleBrightnessMaxAggregateOutputType = {
    moduleCode: string | null
    brightnessCode: string | null
  }

  export type ModuleBrightnessCountAggregateOutputType = {
    moduleCode: number
    brightnessCode: number
    _all: number
  }


  export type ModuleBrightnessMinAggregateInputType = {
    moduleCode?: true
    brightnessCode?: true
  }

  export type ModuleBrightnessMaxAggregateInputType = {
    moduleCode?: true
    brightnessCode?: true
  }

  export type ModuleBrightnessCountAggregateInputType = {
    moduleCode?: true
    brightnessCode?: true
    _all?: true
  }

  export type ModuleBrightnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleBrightness to aggregate.
     */
    where?: ModuleBrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleBrightnesses to fetch.
     */
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleBrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleBrightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleBrightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleBrightnesses
    **/
    _count?: true | ModuleBrightnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleBrightnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleBrightnessMaxAggregateInputType
  }

  export type GetModuleBrightnessAggregateType<T extends ModuleBrightnessAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleBrightness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleBrightness[P]>
      : GetScalarType<T[P], AggregateModuleBrightness[P]>
  }




  export type ModuleBrightnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleBrightnessWhereInput
    orderBy?: ModuleBrightnessOrderByWithAggregationInput | ModuleBrightnessOrderByWithAggregationInput[]
    by: ModuleBrightnessScalarFieldEnum[] | ModuleBrightnessScalarFieldEnum
    having?: ModuleBrightnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleBrightnessCountAggregateInputType | true
    _min?: ModuleBrightnessMinAggregateInputType
    _max?: ModuleBrightnessMaxAggregateInputType
  }

  export type ModuleBrightnessGroupByOutputType = {
    moduleCode: string
    brightnessCode: string
    _count: ModuleBrightnessCountAggregateOutputType | null
    _min: ModuleBrightnessMinAggregateOutputType | null
    _max: ModuleBrightnessMaxAggregateOutputType | null
  }

  type GetModuleBrightnessGroupByPayload<T extends ModuleBrightnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleBrightnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleBrightnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleBrightnessGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleBrightnessGroupByOutputType[P]>
        }
      >
    >


  export type ModuleBrightnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    brightnessCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleBrightness"]>

  export type ModuleBrightnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    brightnessCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleBrightness"]>

  export type ModuleBrightnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    brightnessCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleBrightness"]>

  export type ModuleBrightnessSelectScalar = {
    moduleCode?: boolean
    brightnessCode?: boolean
  }

  export type ModuleBrightnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "brightnessCode", ExtArgs["result"]["moduleBrightness"]>
  export type ModuleBrightnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }
  export type ModuleBrightnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }
  export type ModuleBrightnessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    brightness?: boolean | BrightnessDefaultArgs<ExtArgs>
  }

  export type $ModuleBrightnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleBrightness"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      brightness: Prisma.$BrightnessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      brightnessCode: string
    }, ExtArgs["result"]["moduleBrightness"]>
    composites: {}
  }

  type ModuleBrightnessGetPayload<S extends boolean | null | undefined | ModuleBrightnessDefaultArgs> = $Result.GetResult<Prisma.$ModuleBrightnessPayload, S>

  type ModuleBrightnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleBrightnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleBrightnessCountAggregateInputType | true
    }

  export interface ModuleBrightnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleBrightness'], meta: { name: 'ModuleBrightness' } }
    /**
     * Find zero or one ModuleBrightness that matches the filter.
     * @param {ModuleBrightnessFindUniqueArgs} args - Arguments to find a ModuleBrightness
     * @example
     * // Get one ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleBrightnessFindUniqueArgs>(args: SelectSubset<T, ModuleBrightnessFindUniqueArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleBrightness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleBrightnessFindUniqueOrThrowArgs} args - Arguments to find a ModuleBrightness
     * @example
     * // Get one ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleBrightnessFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleBrightnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleBrightness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessFindFirstArgs} args - Arguments to find a ModuleBrightness
     * @example
     * // Get one ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleBrightnessFindFirstArgs>(args?: SelectSubset<T, ModuleBrightnessFindFirstArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleBrightness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessFindFirstOrThrowArgs} args - Arguments to find a ModuleBrightness
     * @example
     * // Get one ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleBrightnessFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleBrightnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleBrightnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleBrightnesses
     * const moduleBrightnesses = await prisma.moduleBrightness.findMany()
     * 
     * // Get first 10 ModuleBrightnesses
     * const moduleBrightnesses = await prisma.moduleBrightness.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleBrightnessWithModuleCodeOnly = await prisma.moduleBrightness.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleBrightnessFindManyArgs>(args?: SelectSubset<T, ModuleBrightnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleBrightness.
     * @param {ModuleBrightnessCreateArgs} args - Arguments to create a ModuleBrightness.
     * @example
     * // Create one ModuleBrightness
     * const ModuleBrightness = await prisma.moduleBrightness.create({
     *   data: {
     *     // ... data to create a ModuleBrightness
     *   }
     * })
     * 
     */
    create<T extends ModuleBrightnessCreateArgs>(args: SelectSubset<T, ModuleBrightnessCreateArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleBrightnesses.
     * @param {ModuleBrightnessCreateManyArgs} args - Arguments to create many ModuleBrightnesses.
     * @example
     * // Create many ModuleBrightnesses
     * const moduleBrightness = await prisma.moduleBrightness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleBrightnessCreateManyArgs>(args?: SelectSubset<T, ModuleBrightnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleBrightnesses and returns the data saved in the database.
     * @param {ModuleBrightnessCreateManyAndReturnArgs} args - Arguments to create many ModuleBrightnesses.
     * @example
     * // Create many ModuleBrightnesses
     * const moduleBrightness = await prisma.moduleBrightness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleBrightnesses and only return the `moduleCode`
     * const moduleBrightnessWithModuleCodeOnly = await prisma.moduleBrightness.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleBrightnessCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleBrightnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleBrightness.
     * @param {ModuleBrightnessDeleteArgs} args - Arguments to delete one ModuleBrightness.
     * @example
     * // Delete one ModuleBrightness
     * const ModuleBrightness = await prisma.moduleBrightness.delete({
     *   where: {
     *     // ... filter to delete one ModuleBrightness
     *   }
     * })
     * 
     */
    delete<T extends ModuleBrightnessDeleteArgs>(args: SelectSubset<T, ModuleBrightnessDeleteArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleBrightness.
     * @param {ModuleBrightnessUpdateArgs} args - Arguments to update one ModuleBrightness.
     * @example
     * // Update one ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleBrightnessUpdateArgs>(args: SelectSubset<T, ModuleBrightnessUpdateArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleBrightnesses.
     * @param {ModuleBrightnessDeleteManyArgs} args - Arguments to filter ModuleBrightnesses to delete.
     * @example
     * // Delete a few ModuleBrightnesses
     * const { count } = await prisma.moduleBrightness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleBrightnessDeleteManyArgs>(args?: SelectSubset<T, ModuleBrightnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleBrightnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleBrightnesses
     * const moduleBrightness = await prisma.moduleBrightness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleBrightnessUpdateManyArgs>(args: SelectSubset<T, ModuleBrightnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleBrightnesses and returns the data updated in the database.
     * @param {ModuleBrightnessUpdateManyAndReturnArgs} args - Arguments to update many ModuleBrightnesses.
     * @example
     * // Update many ModuleBrightnesses
     * const moduleBrightness = await prisma.moduleBrightness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleBrightnesses and only return the `moduleCode`
     * const moduleBrightnessWithModuleCodeOnly = await prisma.moduleBrightness.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleBrightnessUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleBrightnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleBrightness.
     * @param {ModuleBrightnessUpsertArgs} args - Arguments to update or create a ModuleBrightness.
     * @example
     * // Update or create a ModuleBrightness
     * const moduleBrightness = await prisma.moduleBrightness.upsert({
     *   create: {
     *     // ... data to create a ModuleBrightness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleBrightness we want to update
     *   }
     * })
     */
    upsert<T extends ModuleBrightnessUpsertArgs>(args: SelectSubset<T, ModuleBrightnessUpsertArgs<ExtArgs>>): Prisma__ModuleBrightnessClient<$Result.GetResult<Prisma.$ModuleBrightnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleBrightnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessCountArgs} args - Arguments to filter ModuleBrightnesses to count.
     * @example
     * // Count the number of ModuleBrightnesses
     * const count = await prisma.moduleBrightness.count({
     *   where: {
     *     // ... the filter for the ModuleBrightnesses we want to count
     *   }
     * })
    **/
    count<T extends ModuleBrightnessCountArgs>(
      args?: Subset<T, ModuleBrightnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleBrightnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleBrightness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleBrightnessAggregateArgs>(args: Subset<T, ModuleBrightnessAggregateArgs>): Prisma.PrismaPromise<GetModuleBrightnessAggregateType<T>>

    /**
     * Group by ModuleBrightness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleBrightnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleBrightnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleBrightnessGroupByArgs['orderBy'] }
        : { orderBy?: ModuleBrightnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleBrightnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleBrightnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleBrightness model
   */
  readonly fields: ModuleBrightnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleBrightness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleBrightnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brightness<T extends BrightnessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrightnessDefaultArgs<ExtArgs>>): Prisma__BrightnessClient<$Result.GetResult<Prisma.$BrightnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleBrightness model
   */
  interface ModuleBrightnessFieldRefs {
    readonly moduleCode: FieldRef<"ModuleBrightness", 'String'>
    readonly brightnessCode: FieldRef<"ModuleBrightness", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleBrightness findUnique
   */
  export type ModuleBrightnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter, which ModuleBrightness to fetch.
     */
    where: ModuleBrightnessWhereUniqueInput
  }

  /**
   * ModuleBrightness findUniqueOrThrow
   */
  export type ModuleBrightnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter, which ModuleBrightness to fetch.
     */
    where: ModuleBrightnessWhereUniqueInput
  }

  /**
   * ModuleBrightness findFirst
   */
  export type ModuleBrightnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter, which ModuleBrightness to fetch.
     */
    where?: ModuleBrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleBrightnesses to fetch.
     */
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleBrightnesses.
     */
    cursor?: ModuleBrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleBrightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleBrightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleBrightnesses.
     */
    distinct?: ModuleBrightnessScalarFieldEnum | ModuleBrightnessScalarFieldEnum[]
  }

  /**
   * ModuleBrightness findFirstOrThrow
   */
  export type ModuleBrightnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter, which ModuleBrightness to fetch.
     */
    where?: ModuleBrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleBrightnesses to fetch.
     */
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleBrightnesses.
     */
    cursor?: ModuleBrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleBrightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleBrightnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleBrightnesses.
     */
    distinct?: ModuleBrightnessScalarFieldEnum | ModuleBrightnessScalarFieldEnum[]
  }

  /**
   * ModuleBrightness findMany
   */
  export type ModuleBrightnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter, which ModuleBrightnesses to fetch.
     */
    where?: ModuleBrightnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleBrightnesses to fetch.
     */
    orderBy?: ModuleBrightnessOrderByWithRelationInput | ModuleBrightnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleBrightnesses.
     */
    cursor?: ModuleBrightnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleBrightnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleBrightnesses.
     */
    skip?: number
    distinct?: ModuleBrightnessScalarFieldEnum | ModuleBrightnessScalarFieldEnum[]
  }

  /**
   * ModuleBrightness create
   */
  export type ModuleBrightnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleBrightness.
     */
    data: XOR<ModuleBrightnessCreateInput, ModuleBrightnessUncheckedCreateInput>
  }

  /**
   * ModuleBrightness createMany
   */
  export type ModuleBrightnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleBrightnesses.
     */
    data: ModuleBrightnessCreateManyInput | ModuleBrightnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleBrightness createManyAndReturn
   */
  export type ModuleBrightnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleBrightnesses.
     */
    data: ModuleBrightnessCreateManyInput | ModuleBrightnessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleBrightness update
   */
  export type ModuleBrightnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleBrightness.
     */
    data: XOR<ModuleBrightnessUpdateInput, ModuleBrightnessUncheckedUpdateInput>
    /**
     * Choose, which ModuleBrightness to update.
     */
    where: ModuleBrightnessWhereUniqueInput
  }

  /**
   * ModuleBrightness updateMany
   */
  export type ModuleBrightnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleBrightnesses.
     */
    data: XOR<ModuleBrightnessUpdateManyMutationInput, ModuleBrightnessUncheckedUpdateManyInput>
    /**
     * Filter which ModuleBrightnesses to update
     */
    where?: ModuleBrightnessWhereInput
    /**
     * Limit how many ModuleBrightnesses to update.
     */
    limit?: number
  }

  /**
   * ModuleBrightness updateManyAndReturn
   */
  export type ModuleBrightnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * The data used to update ModuleBrightnesses.
     */
    data: XOR<ModuleBrightnessUpdateManyMutationInput, ModuleBrightnessUncheckedUpdateManyInput>
    /**
     * Filter which ModuleBrightnesses to update
     */
    where?: ModuleBrightnessWhereInput
    /**
     * Limit how many ModuleBrightnesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleBrightness upsert
   */
  export type ModuleBrightnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleBrightness to update in case it exists.
     */
    where: ModuleBrightnessWhereUniqueInput
    /**
     * In case the ModuleBrightness found by the `where` argument doesn't exist, create a new ModuleBrightness with this data.
     */
    create: XOR<ModuleBrightnessCreateInput, ModuleBrightnessUncheckedCreateInput>
    /**
     * In case the ModuleBrightness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleBrightnessUpdateInput, ModuleBrightnessUncheckedUpdateInput>
  }

  /**
   * ModuleBrightness delete
   */
  export type ModuleBrightnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
    /**
     * Filter which ModuleBrightness to delete.
     */
    where: ModuleBrightnessWhereUniqueInput
  }

  /**
   * ModuleBrightness deleteMany
   */
  export type ModuleBrightnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleBrightnesses to delete
     */
    where?: ModuleBrightnessWhereInput
    /**
     * Limit how many ModuleBrightnesses to delete.
     */
    limit?: number
  }

  /**
   * ModuleBrightness without action
   */
  export type ModuleBrightnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleBrightness
     */
    select?: ModuleBrightnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleBrightness
     */
    omit?: ModuleBrightnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleBrightnessInclude<ExtArgs> | null
  }


  /**
   * Model ModuleModuleSize
   */

  export type AggregateModuleModuleSize = {
    _count: ModuleModuleSizeCountAggregateOutputType | null
    _min: ModuleModuleSizeMinAggregateOutputType | null
    _max: ModuleModuleSizeMaxAggregateOutputType | null
  }

  export type ModuleModuleSizeMinAggregateOutputType = {
    moduleCode: string | null
    moduleSizeCode: string | null
  }

  export type ModuleModuleSizeMaxAggregateOutputType = {
    moduleCode: string | null
    moduleSizeCode: string | null
  }

  export type ModuleModuleSizeCountAggregateOutputType = {
    moduleCode: number
    moduleSizeCode: number
    _all: number
  }


  export type ModuleModuleSizeMinAggregateInputType = {
    moduleCode?: true
    moduleSizeCode?: true
  }

  export type ModuleModuleSizeMaxAggregateInputType = {
    moduleCode?: true
    moduleSizeCode?: true
  }

  export type ModuleModuleSizeCountAggregateInputType = {
    moduleCode?: true
    moduleSizeCode?: true
    _all?: true
  }

  export type ModuleModuleSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleModuleSize to aggregate.
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleModuleSizes to fetch.
     */
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleModuleSizes
    **/
    _count?: true | ModuleModuleSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleModuleSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleModuleSizeMaxAggregateInputType
  }

  export type GetModuleModuleSizeAggregateType<T extends ModuleModuleSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleModuleSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleModuleSize[P]>
      : GetScalarType<T[P], AggregateModuleModuleSize[P]>
  }




  export type ModuleModuleSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleModuleSizeWhereInput
    orderBy?: ModuleModuleSizeOrderByWithAggregationInput | ModuleModuleSizeOrderByWithAggregationInput[]
    by: ModuleModuleSizeScalarFieldEnum[] | ModuleModuleSizeScalarFieldEnum
    having?: ModuleModuleSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleModuleSizeCountAggregateInputType | true
    _min?: ModuleModuleSizeMinAggregateInputType
    _max?: ModuleModuleSizeMaxAggregateInputType
  }

  export type ModuleModuleSizeGroupByOutputType = {
    moduleCode: string
    moduleSizeCode: string
    _count: ModuleModuleSizeCountAggregateOutputType | null
    _min: ModuleModuleSizeMinAggregateOutputType | null
    _max: ModuleModuleSizeMaxAggregateOutputType | null
  }

  type GetModuleModuleSizeGroupByPayload<T extends ModuleModuleSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleModuleSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleModuleSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleModuleSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleModuleSizeGroupByOutputType[P]>
        }
      >
    >


  export type ModuleModuleSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    moduleSizeCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleModuleSize"]>

  export type ModuleModuleSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    moduleSizeCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleModuleSize"]>

  export type ModuleModuleSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    moduleSizeCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleModuleSize"]>

  export type ModuleModuleSizeSelectScalar = {
    moduleCode?: boolean
    moduleSizeCode?: boolean
  }

  export type ModuleModuleSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "moduleSizeCode", ExtArgs["result"]["moduleModuleSize"]>
  export type ModuleModuleSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }
  export type ModuleModuleSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }
  export type ModuleModuleSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    size?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }

  export type $ModuleModuleSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleModuleSize"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      size: Prisma.$ModuleSizePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      moduleSizeCode: string
    }, ExtArgs["result"]["moduleModuleSize"]>
    composites: {}
  }

  type ModuleModuleSizeGetPayload<S extends boolean | null | undefined | ModuleModuleSizeDefaultArgs> = $Result.GetResult<Prisma.$ModuleModuleSizePayload, S>

  type ModuleModuleSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleModuleSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleModuleSizeCountAggregateInputType | true
    }

  export interface ModuleModuleSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleModuleSize'], meta: { name: 'ModuleModuleSize' } }
    /**
     * Find zero or one ModuleModuleSize that matches the filter.
     * @param {ModuleModuleSizeFindUniqueArgs} args - Arguments to find a ModuleModuleSize
     * @example
     * // Get one ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleModuleSizeFindUniqueArgs>(args: SelectSubset<T, ModuleModuleSizeFindUniqueArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleModuleSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleModuleSizeFindUniqueOrThrowArgs} args - Arguments to find a ModuleModuleSize
     * @example
     * // Get one ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleModuleSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleModuleSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleModuleSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeFindFirstArgs} args - Arguments to find a ModuleModuleSize
     * @example
     * // Get one ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleModuleSizeFindFirstArgs>(args?: SelectSubset<T, ModuleModuleSizeFindFirstArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleModuleSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeFindFirstOrThrowArgs} args - Arguments to find a ModuleModuleSize
     * @example
     * // Get one ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleModuleSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleModuleSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleModuleSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleModuleSizes
     * const moduleModuleSizes = await prisma.moduleModuleSize.findMany()
     * 
     * // Get first 10 ModuleModuleSizes
     * const moduleModuleSizes = await prisma.moduleModuleSize.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleModuleSizeWithModuleCodeOnly = await prisma.moduleModuleSize.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleModuleSizeFindManyArgs>(args?: SelectSubset<T, ModuleModuleSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleModuleSize.
     * @param {ModuleModuleSizeCreateArgs} args - Arguments to create a ModuleModuleSize.
     * @example
     * // Create one ModuleModuleSize
     * const ModuleModuleSize = await prisma.moduleModuleSize.create({
     *   data: {
     *     // ... data to create a ModuleModuleSize
     *   }
     * })
     * 
     */
    create<T extends ModuleModuleSizeCreateArgs>(args: SelectSubset<T, ModuleModuleSizeCreateArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleModuleSizes.
     * @param {ModuleModuleSizeCreateManyArgs} args - Arguments to create many ModuleModuleSizes.
     * @example
     * // Create many ModuleModuleSizes
     * const moduleModuleSize = await prisma.moduleModuleSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleModuleSizeCreateManyArgs>(args?: SelectSubset<T, ModuleModuleSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleModuleSizes and returns the data saved in the database.
     * @param {ModuleModuleSizeCreateManyAndReturnArgs} args - Arguments to create many ModuleModuleSizes.
     * @example
     * // Create many ModuleModuleSizes
     * const moduleModuleSize = await prisma.moduleModuleSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleModuleSizes and only return the `moduleCode`
     * const moduleModuleSizeWithModuleCodeOnly = await prisma.moduleModuleSize.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleModuleSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleModuleSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleModuleSize.
     * @param {ModuleModuleSizeDeleteArgs} args - Arguments to delete one ModuleModuleSize.
     * @example
     * // Delete one ModuleModuleSize
     * const ModuleModuleSize = await prisma.moduleModuleSize.delete({
     *   where: {
     *     // ... filter to delete one ModuleModuleSize
     *   }
     * })
     * 
     */
    delete<T extends ModuleModuleSizeDeleteArgs>(args: SelectSubset<T, ModuleModuleSizeDeleteArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleModuleSize.
     * @param {ModuleModuleSizeUpdateArgs} args - Arguments to update one ModuleModuleSize.
     * @example
     * // Update one ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleModuleSizeUpdateArgs>(args: SelectSubset<T, ModuleModuleSizeUpdateArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleModuleSizes.
     * @param {ModuleModuleSizeDeleteManyArgs} args - Arguments to filter ModuleModuleSizes to delete.
     * @example
     * // Delete a few ModuleModuleSizes
     * const { count } = await prisma.moduleModuleSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleModuleSizeDeleteManyArgs>(args?: SelectSubset<T, ModuleModuleSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleModuleSizes
     * const moduleModuleSize = await prisma.moduleModuleSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleModuleSizeUpdateManyArgs>(args: SelectSubset<T, ModuleModuleSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleModuleSizes and returns the data updated in the database.
     * @param {ModuleModuleSizeUpdateManyAndReturnArgs} args - Arguments to update many ModuleModuleSizes.
     * @example
     * // Update many ModuleModuleSizes
     * const moduleModuleSize = await prisma.moduleModuleSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleModuleSizes and only return the `moduleCode`
     * const moduleModuleSizeWithModuleCodeOnly = await prisma.moduleModuleSize.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleModuleSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleModuleSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleModuleSize.
     * @param {ModuleModuleSizeUpsertArgs} args - Arguments to update or create a ModuleModuleSize.
     * @example
     * // Update or create a ModuleModuleSize
     * const moduleModuleSize = await prisma.moduleModuleSize.upsert({
     *   create: {
     *     // ... data to create a ModuleModuleSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleModuleSize we want to update
     *   }
     * })
     */
    upsert<T extends ModuleModuleSizeUpsertArgs>(args: SelectSubset<T, ModuleModuleSizeUpsertArgs<ExtArgs>>): Prisma__ModuleModuleSizeClient<$Result.GetResult<Prisma.$ModuleModuleSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeCountArgs} args - Arguments to filter ModuleModuleSizes to count.
     * @example
     * // Count the number of ModuleModuleSizes
     * const count = await prisma.moduleModuleSize.count({
     *   where: {
     *     // ... the filter for the ModuleModuleSizes we want to count
     *   }
     * })
    **/
    count<T extends ModuleModuleSizeCountArgs>(
      args?: Subset<T, ModuleModuleSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleModuleSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleModuleSizeAggregateArgs>(args: Subset<T, ModuleModuleSizeAggregateArgs>): Prisma.PrismaPromise<GetModuleModuleSizeAggregateType<T>>

    /**
     * Group by ModuleModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleModuleSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleModuleSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleModuleSizeGroupByArgs['orderBy'] }
        : { orderBy?: ModuleModuleSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleModuleSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleModuleSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleModuleSize model
   */
  readonly fields: ModuleModuleSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleModuleSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleModuleSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    size<T extends ModuleSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleSizeDefaultArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleModuleSize model
   */
  interface ModuleModuleSizeFieldRefs {
    readonly moduleCode: FieldRef<"ModuleModuleSize", 'String'>
    readonly moduleSizeCode: FieldRef<"ModuleModuleSize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleModuleSize findUnique
   */
  export type ModuleModuleSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleModuleSize to fetch.
     */
    where: ModuleModuleSizeWhereUniqueInput
  }

  /**
   * ModuleModuleSize findUniqueOrThrow
   */
  export type ModuleModuleSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleModuleSize to fetch.
     */
    where: ModuleModuleSizeWhereUniqueInput
  }

  /**
   * ModuleModuleSize findFirst
   */
  export type ModuleModuleSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleModuleSize to fetch.
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleModuleSizes to fetch.
     */
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleModuleSizes.
     */
    cursor?: ModuleModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleModuleSizes.
     */
    distinct?: ModuleModuleSizeScalarFieldEnum | ModuleModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleModuleSize findFirstOrThrow
   */
  export type ModuleModuleSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleModuleSize to fetch.
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleModuleSizes to fetch.
     */
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleModuleSizes.
     */
    cursor?: ModuleModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleModuleSizes.
     */
    distinct?: ModuleModuleSizeScalarFieldEnum | ModuleModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleModuleSize findMany
   */
  export type ModuleModuleSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which ModuleModuleSizes to fetch.
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleModuleSizes to fetch.
     */
    orderBy?: ModuleModuleSizeOrderByWithRelationInput | ModuleModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleModuleSizes.
     */
    cursor?: ModuleModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleModuleSizes.
     */
    skip?: number
    distinct?: ModuleModuleSizeScalarFieldEnum | ModuleModuleSizeScalarFieldEnum[]
  }

  /**
   * ModuleModuleSize create
   */
  export type ModuleModuleSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleModuleSize.
     */
    data: XOR<ModuleModuleSizeCreateInput, ModuleModuleSizeUncheckedCreateInput>
  }

  /**
   * ModuleModuleSize createMany
   */
  export type ModuleModuleSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleModuleSizes.
     */
    data: ModuleModuleSizeCreateManyInput | ModuleModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleModuleSize createManyAndReturn
   */
  export type ModuleModuleSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleModuleSizes.
     */
    data: ModuleModuleSizeCreateManyInput | ModuleModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleModuleSize update
   */
  export type ModuleModuleSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleModuleSize.
     */
    data: XOR<ModuleModuleSizeUpdateInput, ModuleModuleSizeUncheckedUpdateInput>
    /**
     * Choose, which ModuleModuleSize to update.
     */
    where: ModuleModuleSizeWhereUniqueInput
  }

  /**
   * ModuleModuleSize updateMany
   */
  export type ModuleModuleSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleModuleSizes.
     */
    data: XOR<ModuleModuleSizeUpdateManyMutationInput, ModuleModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which ModuleModuleSizes to update
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * Limit how many ModuleModuleSizes to update.
     */
    limit?: number
  }

  /**
   * ModuleModuleSize updateManyAndReturn
   */
  export type ModuleModuleSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to update ModuleModuleSizes.
     */
    data: XOR<ModuleModuleSizeUpdateManyMutationInput, ModuleModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which ModuleModuleSizes to update
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * Limit how many ModuleModuleSizes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleModuleSize upsert
   */
  export type ModuleModuleSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleModuleSize to update in case it exists.
     */
    where: ModuleModuleSizeWhereUniqueInput
    /**
     * In case the ModuleModuleSize found by the `where` argument doesn't exist, create a new ModuleModuleSize with this data.
     */
    create: XOR<ModuleModuleSizeCreateInput, ModuleModuleSizeUncheckedCreateInput>
    /**
     * In case the ModuleModuleSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleModuleSizeUpdateInput, ModuleModuleSizeUncheckedUpdateInput>
  }

  /**
   * ModuleModuleSize delete
   */
  export type ModuleModuleSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
    /**
     * Filter which ModuleModuleSize to delete.
     */
    where: ModuleModuleSizeWhereUniqueInput
  }

  /**
   * ModuleModuleSize deleteMany
   */
  export type ModuleModuleSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleModuleSizes to delete
     */
    where?: ModuleModuleSizeWhereInput
    /**
     * Limit how many ModuleModuleSizes to delete.
     */
    limit?: number
  }

  /**
   * ModuleModuleSize without action
   */
  export type ModuleModuleSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleModuleSize
     */
    select?: ModuleModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleModuleSize
     */
    omit?: ModuleModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleModuleSizeInclude<ExtArgs> | null
  }


  /**
   * Model ModulePitch
   */

  export type AggregateModulePitch = {
    _count: ModulePitchCountAggregateOutputType | null
    _min: ModulePitchMinAggregateOutputType | null
    _max: ModulePitchMaxAggregateOutputType | null
  }

  export type ModulePitchMinAggregateOutputType = {
    moduleCode: string | null
    pitchCode: string | null
  }

  export type ModulePitchMaxAggregateOutputType = {
    moduleCode: string | null
    pitchCode: string | null
  }

  export type ModulePitchCountAggregateOutputType = {
    moduleCode: number
    pitchCode: number
    _all: number
  }


  export type ModulePitchMinAggregateInputType = {
    moduleCode?: true
    pitchCode?: true
  }

  export type ModulePitchMaxAggregateInputType = {
    moduleCode?: true
    pitchCode?: true
  }

  export type ModulePitchCountAggregateInputType = {
    moduleCode?: true
    pitchCode?: true
    _all?: true
  }

  export type ModulePitchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePitch to aggregate.
     */
    where?: ModulePitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePitches to fetch.
     */
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModulePitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModulePitches
    **/
    _count?: true | ModulePitchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulePitchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulePitchMaxAggregateInputType
  }

  export type GetModulePitchAggregateType<T extends ModulePitchAggregateArgs> = {
        [P in keyof T & keyof AggregateModulePitch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulePitch[P]>
      : GetScalarType<T[P], AggregateModulePitch[P]>
  }




  export type ModulePitchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePitchWhereInput
    orderBy?: ModulePitchOrderByWithAggregationInput | ModulePitchOrderByWithAggregationInput[]
    by: ModulePitchScalarFieldEnum[] | ModulePitchScalarFieldEnum
    having?: ModulePitchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulePitchCountAggregateInputType | true
    _min?: ModulePitchMinAggregateInputType
    _max?: ModulePitchMaxAggregateInputType
  }

  export type ModulePitchGroupByOutputType = {
    moduleCode: string
    pitchCode: string
    _count: ModulePitchCountAggregateOutputType | null
    _min: ModulePitchMinAggregateOutputType | null
    _max: ModulePitchMaxAggregateOutputType | null
  }

  type GetModulePitchGroupByPayload<T extends ModulePitchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulePitchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulePitchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulePitchGroupByOutputType[P]>
            : GetScalarType<T[P], ModulePitchGroupByOutputType[P]>
        }
      >
    >


  export type ModulePitchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    pitchCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePitch"]>

  export type ModulePitchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    pitchCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePitch"]>

  export type ModulePitchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    pitchCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePitch"]>

  export type ModulePitchSelectScalar = {
    moduleCode?: boolean
    pitchCode?: boolean
  }

  export type ModulePitchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "pitchCode", ExtArgs["result"]["modulePitch"]>
  export type ModulePitchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }
  export type ModulePitchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }
  export type ModulePitchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    pitch?: boolean | PitchDefaultArgs<ExtArgs>
  }

  export type $ModulePitchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModulePitch"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      pitch: Prisma.$PitchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      pitchCode: string
    }, ExtArgs["result"]["modulePitch"]>
    composites: {}
  }

  type ModulePitchGetPayload<S extends boolean | null | undefined | ModulePitchDefaultArgs> = $Result.GetResult<Prisma.$ModulePitchPayload, S>

  type ModulePitchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModulePitchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModulePitchCountAggregateInputType | true
    }

  export interface ModulePitchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModulePitch'], meta: { name: 'ModulePitch' } }
    /**
     * Find zero or one ModulePitch that matches the filter.
     * @param {ModulePitchFindUniqueArgs} args - Arguments to find a ModulePitch
     * @example
     * // Get one ModulePitch
     * const modulePitch = await prisma.modulePitch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModulePitchFindUniqueArgs>(args: SelectSubset<T, ModulePitchFindUniqueArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModulePitch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModulePitchFindUniqueOrThrowArgs} args - Arguments to find a ModulePitch
     * @example
     * // Get one ModulePitch
     * const modulePitch = await prisma.modulePitch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModulePitchFindUniqueOrThrowArgs>(args: SelectSubset<T, ModulePitchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePitch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchFindFirstArgs} args - Arguments to find a ModulePitch
     * @example
     * // Get one ModulePitch
     * const modulePitch = await prisma.modulePitch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModulePitchFindFirstArgs>(args?: SelectSubset<T, ModulePitchFindFirstArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePitch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchFindFirstOrThrowArgs} args - Arguments to find a ModulePitch
     * @example
     * // Get one ModulePitch
     * const modulePitch = await prisma.modulePitch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModulePitchFindFirstOrThrowArgs>(args?: SelectSubset<T, ModulePitchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModulePitches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModulePitches
     * const modulePitches = await prisma.modulePitch.findMany()
     * 
     * // Get first 10 ModulePitches
     * const modulePitches = await prisma.modulePitch.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const modulePitchWithModuleCodeOnly = await prisma.modulePitch.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModulePitchFindManyArgs>(args?: SelectSubset<T, ModulePitchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModulePitch.
     * @param {ModulePitchCreateArgs} args - Arguments to create a ModulePitch.
     * @example
     * // Create one ModulePitch
     * const ModulePitch = await prisma.modulePitch.create({
     *   data: {
     *     // ... data to create a ModulePitch
     *   }
     * })
     * 
     */
    create<T extends ModulePitchCreateArgs>(args: SelectSubset<T, ModulePitchCreateArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModulePitches.
     * @param {ModulePitchCreateManyArgs} args - Arguments to create many ModulePitches.
     * @example
     * // Create many ModulePitches
     * const modulePitch = await prisma.modulePitch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModulePitchCreateManyArgs>(args?: SelectSubset<T, ModulePitchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModulePitches and returns the data saved in the database.
     * @param {ModulePitchCreateManyAndReturnArgs} args - Arguments to create many ModulePitches.
     * @example
     * // Create many ModulePitches
     * const modulePitch = await prisma.modulePitch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModulePitches and only return the `moduleCode`
     * const modulePitchWithModuleCodeOnly = await prisma.modulePitch.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModulePitchCreateManyAndReturnArgs>(args?: SelectSubset<T, ModulePitchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModulePitch.
     * @param {ModulePitchDeleteArgs} args - Arguments to delete one ModulePitch.
     * @example
     * // Delete one ModulePitch
     * const ModulePitch = await prisma.modulePitch.delete({
     *   where: {
     *     // ... filter to delete one ModulePitch
     *   }
     * })
     * 
     */
    delete<T extends ModulePitchDeleteArgs>(args: SelectSubset<T, ModulePitchDeleteArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModulePitch.
     * @param {ModulePitchUpdateArgs} args - Arguments to update one ModulePitch.
     * @example
     * // Update one ModulePitch
     * const modulePitch = await prisma.modulePitch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModulePitchUpdateArgs>(args: SelectSubset<T, ModulePitchUpdateArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModulePitches.
     * @param {ModulePitchDeleteManyArgs} args - Arguments to filter ModulePitches to delete.
     * @example
     * // Delete a few ModulePitches
     * const { count } = await prisma.modulePitch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModulePitchDeleteManyArgs>(args?: SelectSubset<T, ModulePitchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModulePitches
     * const modulePitch = await prisma.modulePitch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModulePitchUpdateManyArgs>(args: SelectSubset<T, ModulePitchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePitches and returns the data updated in the database.
     * @param {ModulePitchUpdateManyAndReturnArgs} args - Arguments to update many ModulePitches.
     * @example
     * // Update many ModulePitches
     * const modulePitch = await prisma.modulePitch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModulePitches and only return the `moduleCode`
     * const modulePitchWithModuleCodeOnly = await prisma.modulePitch.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModulePitchUpdateManyAndReturnArgs>(args: SelectSubset<T, ModulePitchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModulePitch.
     * @param {ModulePitchUpsertArgs} args - Arguments to update or create a ModulePitch.
     * @example
     * // Update or create a ModulePitch
     * const modulePitch = await prisma.modulePitch.upsert({
     *   create: {
     *     // ... data to create a ModulePitch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModulePitch we want to update
     *   }
     * })
     */
    upsert<T extends ModulePitchUpsertArgs>(args: SelectSubset<T, ModulePitchUpsertArgs<ExtArgs>>): Prisma__ModulePitchClient<$Result.GetResult<Prisma.$ModulePitchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModulePitches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchCountArgs} args - Arguments to filter ModulePitches to count.
     * @example
     * // Count the number of ModulePitches
     * const count = await prisma.modulePitch.count({
     *   where: {
     *     // ... the filter for the ModulePitches we want to count
     *   }
     * })
    **/
    count<T extends ModulePitchCountArgs>(
      args?: Subset<T, ModulePitchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulePitchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModulePitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulePitchAggregateArgs>(args: Subset<T, ModulePitchAggregateArgs>): Prisma.PrismaPromise<GetModulePitchAggregateType<T>>

    /**
     * Group by ModulePitch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePitchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModulePitchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModulePitchGroupByArgs['orderBy'] }
        : { orderBy?: ModulePitchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModulePitchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulePitchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModulePitch model
   */
  readonly fields: ModulePitchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModulePitch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModulePitchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pitch<T extends PitchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PitchDefaultArgs<ExtArgs>>): Prisma__PitchClient<$Result.GetResult<Prisma.$PitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModulePitch model
   */
  interface ModulePitchFieldRefs {
    readonly moduleCode: FieldRef<"ModulePitch", 'String'>
    readonly pitchCode: FieldRef<"ModulePitch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModulePitch findUnique
   */
  export type ModulePitchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter, which ModulePitch to fetch.
     */
    where: ModulePitchWhereUniqueInput
  }

  /**
   * ModulePitch findUniqueOrThrow
   */
  export type ModulePitchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter, which ModulePitch to fetch.
     */
    where: ModulePitchWhereUniqueInput
  }

  /**
   * ModulePitch findFirst
   */
  export type ModulePitchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter, which ModulePitch to fetch.
     */
    where?: ModulePitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePitches to fetch.
     */
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePitches.
     */
    cursor?: ModulePitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePitches.
     */
    distinct?: ModulePitchScalarFieldEnum | ModulePitchScalarFieldEnum[]
  }

  /**
   * ModulePitch findFirstOrThrow
   */
  export type ModulePitchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter, which ModulePitch to fetch.
     */
    where?: ModulePitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePitches to fetch.
     */
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePitches.
     */
    cursor?: ModulePitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePitches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePitches.
     */
    distinct?: ModulePitchScalarFieldEnum | ModulePitchScalarFieldEnum[]
  }

  /**
   * ModulePitch findMany
   */
  export type ModulePitchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter, which ModulePitches to fetch.
     */
    where?: ModulePitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePitches to fetch.
     */
    orderBy?: ModulePitchOrderByWithRelationInput | ModulePitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModulePitches.
     */
    cursor?: ModulePitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePitches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePitches.
     */
    skip?: number
    distinct?: ModulePitchScalarFieldEnum | ModulePitchScalarFieldEnum[]
  }

  /**
   * ModulePitch create
   */
  export type ModulePitchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * The data needed to create a ModulePitch.
     */
    data: XOR<ModulePitchCreateInput, ModulePitchUncheckedCreateInput>
  }

  /**
   * ModulePitch createMany
   */
  export type ModulePitchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModulePitches.
     */
    data: ModulePitchCreateManyInput | ModulePitchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModulePitch createManyAndReturn
   */
  export type ModulePitchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * The data used to create many ModulePitches.
     */
    data: ModulePitchCreateManyInput | ModulePitchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePitch update
   */
  export type ModulePitchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * The data needed to update a ModulePitch.
     */
    data: XOR<ModulePitchUpdateInput, ModulePitchUncheckedUpdateInput>
    /**
     * Choose, which ModulePitch to update.
     */
    where: ModulePitchWhereUniqueInput
  }

  /**
   * ModulePitch updateMany
   */
  export type ModulePitchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModulePitches.
     */
    data: XOR<ModulePitchUpdateManyMutationInput, ModulePitchUncheckedUpdateManyInput>
    /**
     * Filter which ModulePitches to update
     */
    where?: ModulePitchWhereInput
    /**
     * Limit how many ModulePitches to update.
     */
    limit?: number
  }

  /**
   * ModulePitch updateManyAndReturn
   */
  export type ModulePitchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * The data used to update ModulePitches.
     */
    data: XOR<ModulePitchUpdateManyMutationInput, ModulePitchUncheckedUpdateManyInput>
    /**
     * Filter which ModulePitches to update
     */
    where?: ModulePitchWhereInput
    /**
     * Limit how many ModulePitches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePitch upsert
   */
  export type ModulePitchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * The filter to search for the ModulePitch to update in case it exists.
     */
    where: ModulePitchWhereUniqueInput
    /**
     * In case the ModulePitch found by the `where` argument doesn't exist, create a new ModulePitch with this data.
     */
    create: XOR<ModulePitchCreateInput, ModulePitchUncheckedCreateInput>
    /**
     * In case the ModulePitch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModulePitchUpdateInput, ModulePitchUncheckedUpdateInput>
  }

  /**
   * ModulePitch delete
   */
  export type ModulePitchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
    /**
     * Filter which ModulePitch to delete.
     */
    where: ModulePitchWhereUniqueInput
  }

  /**
   * ModulePitch deleteMany
   */
  export type ModulePitchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePitches to delete
     */
    where?: ModulePitchWhereInput
    /**
     * Limit how many ModulePitches to delete.
     */
    limit?: number
  }

  /**
   * ModulePitch without action
   */
  export type ModulePitchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePitch
     */
    select?: ModulePitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePitch
     */
    omit?: ModulePitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePitchInclude<ExtArgs> | null
  }


  /**
   * Model ModuleManufacturer
   */

  export type AggregateModuleManufacturer = {
    _count: ModuleManufacturerCountAggregateOutputType | null
    _min: ModuleManufacturerMinAggregateOutputType | null
    _max: ModuleManufacturerMaxAggregateOutputType | null
  }

  export type ModuleManufacturerMinAggregateOutputType = {
    moduleCode: string | null
    manufacturerCode: string | null
  }

  export type ModuleManufacturerMaxAggregateOutputType = {
    moduleCode: string | null
    manufacturerCode: string | null
  }

  export type ModuleManufacturerCountAggregateOutputType = {
    moduleCode: number
    manufacturerCode: number
    _all: number
  }


  export type ModuleManufacturerMinAggregateInputType = {
    moduleCode?: true
    manufacturerCode?: true
  }

  export type ModuleManufacturerMaxAggregateInputType = {
    moduleCode?: true
    manufacturerCode?: true
  }

  export type ModuleManufacturerCountAggregateInputType = {
    moduleCode?: true
    manufacturerCode?: true
    _all?: true
  }

  export type ModuleManufacturerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleManufacturer to aggregate.
     */
    where?: ModuleManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleManufacturers to fetch.
     */
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleManufacturers
    **/
    _count?: true | ModuleManufacturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleManufacturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleManufacturerMaxAggregateInputType
  }

  export type GetModuleManufacturerAggregateType<T extends ModuleManufacturerAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleManufacturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleManufacturer[P]>
      : GetScalarType<T[P], AggregateModuleManufacturer[P]>
  }




  export type ModuleManufacturerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleManufacturerWhereInput
    orderBy?: ModuleManufacturerOrderByWithAggregationInput | ModuleManufacturerOrderByWithAggregationInput[]
    by: ModuleManufacturerScalarFieldEnum[] | ModuleManufacturerScalarFieldEnum
    having?: ModuleManufacturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleManufacturerCountAggregateInputType | true
    _min?: ModuleManufacturerMinAggregateInputType
    _max?: ModuleManufacturerMaxAggregateInputType
  }

  export type ModuleManufacturerGroupByOutputType = {
    moduleCode: string
    manufacturerCode: string
    _count: ModuleManufacturerCountAggregateOutputType | null
    _min: ModuleManufacturerMinAggregateOutputType | null
    _max: ModuleManufacturerMaxAggregateOutputType | null
  }

  type GetModuleManufacturerGroupByPayload<T extends ModuleManufacturerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleManufacturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleManufacturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleManufacturerGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleManufacturerGroupByOutputType[P]>
        }
      >
    >


  export type ModuleManufacturerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    manufacturerCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleManufacturer"]>

  export type ModuleManufacturerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    manufacturerCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleManufacturer"]>

  export type ModuleManufacturerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    manufacturerCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleManufacturer"]>

  export type ModuleManufacturerSelectScalar = {
    moduleCode?: boolean
    manufacturerCode?: boolean
  }

  export type ModuleManufacturerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "manufacturerCode", ExtArgs["result"]["moduleManufacturer"]>
  export type ModuleManufacturerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }
  export type ModuleManufacturerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }
  export type ModuleManufacturerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerDefaultArgs<ExtArgs>
  }

  export type $ModuleManufacturerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleManufacturer"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      manufacturer: Prisma.$ManufacturerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      manufacturerCode: string
    }, ExtArgs["result"]["moduleManufacturer"]>
    composites: {}
  }

  type ModuleManufacturerGetPayload<S extends boolean | null | undefined | ModuleManufacturerDefaultArgs> = $Result.GetResult<Prisma.$ModuleManufacturerPayload, S>

  type ModuleManufacturerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleManufacturerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleManufacturerCountAggregateInputType | true
    }

  export interface ModuleManufacturerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleManufacturer'], meta: { name: 'ModuleManufacturer' } }
    /**
     * Find zero or one ModuleManufacturer that matches the filter.
     * @param {ModuleManufacturerFindUniqueArgs} args - Arguments to find a ModuleManufacturer
     * @example
     * // Get one ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleManufacturerFindUniqueArgs>(args: SelectSubset<T, ModuleManufacturerFindUniqueArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleManufacturer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleManufacturerFindUniqueOrThrowArgs} args - Arguments to find a ModuleManufacturer
     * @example
     * // Get one ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleManufacturerFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleManufacturerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleManufacturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerFindFirstArgs} args - Arguments to find a ModuleManufacturer
     * @example
     * // Get one ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleManufacturerFindFirstArgs>(args?: SelectSubset<T, ModuleManufacturerFindFirstArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleManufacturer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerFindFirstOrThrowArgs} args - Arguments to find a ModuleManufacturer
     * @example
     * // Get one ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleManufacturerFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleManufacturerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleManufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleManufacturers
     * const moduleManufacturers = await prisma.moduleManufacturer.findMany()
     * 
     * // Get first 10 ModuleManufacturers
     * const moduleManufacturers = await prisma.moduleManufacturer.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleManufacturerWithModuleCodeOnly = await prisma.moduleManufacturer.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleManufacturerFindManyArgs>(args?: SelectSubset<T, ModuleManufacturerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleManufacturer.
     * @param {ModuleManufacturerCreateArgs} args - Arguments to create a ModuleManufacturer.
     * @example
     * // Create one ModuleManufacturer
     * const ModuleManufacturer = await prisma.moduleManufacturer.create({
     *   data: {
     *     // ... data to create a ModuleManufacturer
     *   }
     * })
     * 
     */
    create<T extends ModuleManufacturerCreateArgs>(args: SelectSubset<T, ModuleManufacturerCreateArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleManufacturers.
     * @param {ModuleManufacturerCreateManyArgs} args - Arguments to create many ModuleManufacturers.
     * @example
     * // Create many ModuleManufacturers
     * const moduleManufacturer = await prisma.moduleManufacturer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleManufacturerCreateManyArgs>(args?: SelectSubset<T, ModuleManufacturerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleManufacturers and returns the data saved in the database.
     * @param {ModuleManufacturerCreateManyAndReturnArgs} args - Arguments to create many ModuleManufacturers.
     * @example
     * // Create many ModuleManufacturers
     * const moduleManufacturer = await prisma.moduleManufacturer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleManufacturers and only return the `moduleCode`
     * const moduleManufacturerWithModuleCodeOnly = await prisma.moduleManufacturer.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleManufacturerCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleManufacturerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleManufacturer.
     * @param {ModuleManufacturerDeleteArgs} args - Arguments to delete one ModuleManufacturer.
     * @example
     * // Delete one ModuleManufacturer
     * const ModuleManufacturer = await prisma.moduleManufacturer.delete({
     *   where: {
     *     // ... filter to delete one ModuleManufacturer
     *   }
     * })
     * 
     */
    delete<T extends ModuleManufacturerDeleteArgs>(args: SelectSubset<T, ModuleManufacturerDeleteArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleManufacturer.
     * @param {ModuleManufacturerUpdateArgs} args - Arguments to update one ModuleManufacturer.
     * @example
     * // Update one ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleManufacturerUpdateArgs>(args: SelectSubset<T, ModuleManufacturerUpdateArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleManufacturers.
     * @param {ModuleManufacturerDeleteManyArgs} args - Arguments to filter ModuleManufacturers to delete.
     * @example
     * // Delete a few ModuleManufacturers
     * const { count } = await prisma.moduleManufacturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleManufacturerDeleteManyArgs>(args?: SelectSubset<T, ModuleManufacturerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleManufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleManufacturers
     * const moduleManufacturer = await prisma.moduleManufacturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleManufacturerUpdateManyArgs>(args: SelectSubset<T, ModuleManufacturerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleManufacturers and returns the data updated in the database.
     * @param {ModuleManufacturerUpdateManyAndReturnArgs} args - Arguments to update many ModuleManufacturers.
     * @example
     * // Update many ModuleManufacturers
     * const moduleManufacturer = await prisma.moduleManufacturer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleManufacturers and only return the `moduleCode`
     * const moduleManufacturerWithModuleCodeOnly = await prisma.moduleManufacturer.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleManufacturerUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleManufacturerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleManufacturer.
     * @param {ModuleManufacturerUpsertArgs} args - Arguments to update or create a ModuleManufacturer.
     * @example
     * // Update or create a ModuleManufacturer
     * const moduleManufacturer = await prisma.moduleManufacturer.upsert({
     *   create: {
     *     // ... data to create a ModuleManufacturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleManufacturer we want to update
     *   }
     * })
     */
    upsert<T extends ModuleManufacturerUpsertArgs>(args: SelectSubset<T, ModuleManufacturerUpsertArgs<ExtArgs>>): Prisma__ModuleManufacturerClient<$Result.GetResult<Prisma.$ModuleManufacturerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleManufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerCountArgs} args - Arguments to filter ModuleManufacturers to count.
     * @example
     * // Count the number of ModuleManufacturers
     * const count = await prisma.moduleManufacturer.count({
     *   where: {
     *     // ... the filter for the ModuleManufacturers we want to count
     *   }
     * })
    **/
    count<T extends ModuleManufacturerCountArgs>(
      args?: Subset<T, ModuleManufacturerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleManufacturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleManufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleManufacturerAggregateArgs>(args: Subset<T, ModuleManufacturerAggregateArgs>): Prisma.PrismaPromise<GetModuleManufacturerAggregateType<T>>

    /**
     * Group by ModuleManufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleManufacturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleManufacturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleManufacturerGroupByArgs['orderBy'] }
        : { orderBy?: ModuleManufacturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleManufacturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleManufacturerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleManufacturer model
   */
  readonly fields: ModuleManufacturerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleManufacturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleManufacturerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manufacturer<T extends ManufacturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturerDefaultArgs<ExtArgs>>): Prisma__ManufacturerClient<$Result.GetResult<Prisma.$ManufacturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleManufacturer model
   */
  interface ModuleManufacturerFieldRefs {
    readonly moduleCode: FieldRef<"ModuleManufacturer", 'String'>
    readonly manufacturerCode: FieldRef<"ModuleManufacturer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleManufacturer findUnique
   */
  export type ModuleManufacturerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which ModuleManufacturer to fetch.
     */
    where: ModuleManufacturerWhereUniqueInput
  }

  /**
   * ModuleManufacturer findUniqueOrThrow
   */
  export type ModuleManufacturerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which ModuleManufacturer to fetch.
     */
    where: ModuleManufacturerWhereUniqueInput
  }

  /**
   * ModuleManufacturer findFirst
   */
  export type ModuleManufacturerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which ModuleManufacturer to fetch.
     */
    where?: ModuleManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleManufacturers to fetch.
     */
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleManufacturers.
     */
    cursor?: ModuleManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleManufacturers.
     */
    distinct?: ModuleManufacturerScalarFieldEnum | ModuleManufacturerScalarFieldEnum[]
  }

  /**
   * ModuleManufacturer findFirstOrThrow
   */
  export type ModuleManufacturerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which ModuleManufacturer to fetch.
     */
    where?: ModuleManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleManufacturers to fetch.
     */
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleManufacturers.
     */
    cursor?: ModuleManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleManufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleManufacturers.
     */
    distinct?: ModuleManufacturerScalarFieldEnum | ModuleManufacturerScalarFieldEnum[]
  }

  /**
   * ModuleManufacturer findMany
   */
  export type ModuleManufacturerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which ModuleManufacturers to fetch.
     */
    where?: ModuleManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleManufacturers to fetch.
     */
    orderBy?: ModuleManufacturerOrderByWithRelationInput | ModuleManufacturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleManufacturers.
     */
    cursor?: ModuleManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleManufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleManufacturers.
     */
    skip?: number
    distinct?: ModuleManufacturerScalarFieldEnum | ModuleManufacturerScalarFieldEnum[]
  }

  /**
   * ModuleManufacturer create
   */
  export type ModuleManufacturerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleManufacturer.
     */
    data: XOR<ModuleManufacturerCreateInput, ModuleManufacturerUncheckedCreateInput>
  }

  /**
   * ModuleManufacturer createMany
   */
  export type ModuleManufacturerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleManufacturers.
     */
    data: ModuleManufacturerCreateManyInput | ModuleManufacturerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleManufacturer createManyAndReturn
   */
  export type ModuleManufacturerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleManufacturers.
     */
    data: ModuleManufacturerCreateManyInput | ModuleManufacturerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleManufacturer update
   */
  export type ModuleManufacturerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleManufacturer.
     */
    data: XOR<ModuleManufacturerUpdateInput, ModuleManufacturerUncheckedUpdateInput>
    /**
     * Choose, which ModuleManufacturer to update.
     */
    where: ModuleManufacturerWhereUniqueInput
  }

  /**
   * ModuleManufacturer updateMany
   */
  export type ModuleManufacturerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleManufacturers.
     */
    data: XOR<ModuleManufacturerUpdateManyMutationInput, ModuleManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which ModuleManufacturers to update
     */
    where?: ModuleManufacturerWhereInput
    /**
     * Limit how many ModuleManufacturers to update.
     */
    limit?: number
  }

  /**
   * ModuleManufacturer updateManyAndReturn
   */
  export type ModuleManufacturerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * The data used to update ModuleManufacturers.
     */
    data: XOR<ModuleManufacturerUpdateManyMutationInput, ModuleManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which ModuleManufacturers to update
     */
    where?: ModuleManufacturerWhereInput
    /**
     * Limit how many ModuleManufacturers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleManufacturer upsert
   */
  export type ModuleManufacturerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleManufacturer to update in case it exists.
     */
    where: ModuleManufacturerWhereUniqueInput
    /**
     * In case the ModuleManufacturer found by the `where` argument doesn't exist, create a new ModuleManufacturer with this data.
     */
    create: XOR<ModuleManufacturerCreateInput, ModuleManufacturerUncheckedCreateInput>
    /**
     * In case the ModuleManufacturer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleManufacturerUpdateInput, ModuleManufacturerUncheckedUpdateInput>
  }

  /**
   * ModuleManufacturer delete
   */
  export type ModuleManufacturerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
    /**
     * Filter which ModuleManufacturer to delete.
     */
    where: ModuleManufacturerWhereUniqueInput
  }

  /**
   * ModuleManufacturer deleteMany
   */
  export type ModuleManufacturerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleManufacturers to delete
     */
    where?: ModuleManufacturerWhereInput
    /**
     * Limit how many ModuleManufacturers to delete.
     */
    limit?: number
  }

  /**
   * ModuleManufacturer without action
   */
  export type ModuleManufacturerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleManufacturer
     */
    select?: ModuleManufacturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleManufacturer
     */
    omit?: ModuleManufacturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleManufacturerInclude<ExtArgs> | null
  }


  /**
   * Model ModuleItemComponent
   */

  export type AggregateModuleItemComponent = {
    _count: ModuleItemComponentCountAggregateOutputType | null
    _avg: ModuleItemComponentAvgAggregateOutputType | null
    _sum: ModuleItemComponentSumAggregateOutputType | null
    _min: ModuleItemComponentMinAggregateOutputType | null
    _max: ModuleItemComponentMaxAggregateOutputType | null
  }

  export type ModuleItemComponentAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ModuleItemComponentSumAggregateOutputType = {
    quantity: number | null
  }

  export type ModuleItemComponentMinAggregateOutputType = {
    moduleCode: string | null
    itemCode: string | null
    quantity: number | null
  }

  export type ModuleItemComponentMaxAggregateOutputType = {
    moduleCode: string | null
    itemCode: string | null
    quantity: number | null
  }

  export type ModuleItemComponentCountAggregateOutputType = {
    moduleCode: number
    itemCode: number
    quantity: number
    _all: number
  }


  export type ModuleItemComponentAvgAggregateInputType = {
    quantity?: true
  }

  export type ModuleItemComponentSumAggregateInputType = {
    quantity?: true
  }

  export type ModuleItemComponentMinAggregateInputType = {
    moduleCode?: true
    itemCode?: true
    quantity?: true
  }

  export type ModuleItemComponentMaxAggregateInputType = {
    moduleCode?: true
    itemCode?: true
    quantity?: true
  }

  export type ModuleItemComponentCountAggregateInputType = {
    moduleCode?: true
    itemCode?: true
    quantity?: true
    _all?: true
  }

  export type ModuleItemComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleItemComponent to aggregate.
     */
    where?: ModuleItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleItemComponents to fetch.
     */
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleItemComponents
    **/
    _count?: true | ModuleItemComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleItemComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleItemComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleItemComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleItemComponentMaxAggregateInputType
  }

  export type GetModuleItemComponentAggregateType<T extends ModuleItemComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleItemComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleItemComponent[P]>
      : GetScalarType<T[P], AggregateModuleItemComponent[P]>
  }




  export type ModuleItemComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleItemComponentWhereInput
    orderBy?: ModuleItemComponentOrderByWithAggregationInput | ModuleItemComponentOrderByWithAggregationInput[]
    by: ModuleItemComponentScalarFieldEnum[] | ModuleItemComponentScalarFieldEnum
    having?: ModuleItemComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleItemComponentCountAggregateInputType | true
    _avg?: ModuleItemComponentAvgAggregateInputType
    _sum?: ModuleItemComponentSumAggregateInputType
    _min?: ModuleItemComponentMinAggregateInputType
    _max?: ModuleItemComponentMaxAggregateInputType
  }

  export type ModuleItemComponentGroupByOutputType = {
    moduleCode: string
    itemCode: string
    quantity: number
    _count: ModuleItemComponentCountAggregateOutputType | null
    _avg: ModuleItemComponentAvgAggregateOutputType | null
    _sum: ModuleItemComponentSumAggregateOutputType | null
    _min: ModuleItemComponentMinAggregateOutputType | null
    _max: ModuleItemComponentMaxAggregateOutputType | null
  }

  type GetModuleItemComponentGroupByPayload<T extends ModuleItemComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleItemComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleItemComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleItemComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleItemComponentGroupByOutputType[P]>
        }
      >
    >


  export type ModuleItemComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleItemComponent"]>

  export type ModuleItemComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleItemComponent"]>

  export type ModuleItemComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    itemCode?: boolean
    quantity?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleItemComponent"]>

  export type ModuleItemComponentSelectScalar = {
    moduleCode?: boolean
    itemCode?: boolean
    quantity?: boolean
  }

  export type ModuleItemComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "itemCode" | "quantity", ExtArgs["result"]["moduleItemComponent"]>
  export type ModuleItemComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ModuleItemComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ModuleItemComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ModuleItemComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleItemComponent"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      itemCode: string
      quantity: number
    }, ExtArgs["result"]["moduleItemComponent"]>
    composites: {}
  }

  type ModuleItemComponentGetPayload<S extends boolean | null | undefined | ModuleItemComponentDefaultArgs> = $Result.GetResult<Prisma.$ModuleItemComponentPayload, S>

  type ModuleItemComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleItemComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleItemComponentCountAggregateInputType | true
    }

  export interface ModuleItemComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleItemComponent'], meta: { name: 'ModuleItemComponent' } }
    /**
     * Find zero or one ModuleItemComponent that matches the filter.
     * @param {ModuleItemComponentFindUniqueArgs} args - Arguments to find a ModuleItemComponent
     * @example
     * // Get one ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleItemComponentFindUniqueArgs>(args: SelectSubset<T, ModuleItemComponentFindUniqueArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleItemComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleItemComponentFindUniqueOrThrowArgs} args - Arguments to find a ModuleItemComponent
     * @example
     * // Get one ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleItemComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleItemComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleItemComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentFindFirstArgs} args - Arguments to find a ModuleItemComponent
     * @example
     * // Get one ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleItemComponentFindFirstArgs>(args?: SelectSubset<T, ModuleItemComponentFindFirstArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleItemComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentFindFirstOrThrowArgs} args - Arguments to find a ModuleItemComponent
     * @example
     * // Get one ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleItemComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleItemComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleItemComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleItemComponents
     * const moduleItemComponents = await prisma.moduleItemComponent.findMany()
     * 
     * // Get first 10 ModuleItemComponents
     * const moduleItemComponents = await prisma.moduleItemComponent.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleItemComponentWithModuleCodeOnly = await prisma.moduleItemComponent.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleItemComponentFindManyArgs>(args?: SelectSubset<T, ModuleItemComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleItemComponent.
     * @param {ModuleItemComponentCreateArgs} args - Arguments to create a ModuleItemComponent.
     * @example
     * // Create one ModuleItemComponent
     * const ModuleItemComponent = await prisma.moduleItemComponent.create({
     *   data: {
     *     // ... data to create a ModuleItemComponent
     *   }
     * })
     * 
     */
    create<T extends ModuleItemComponentCreateArgs>(args: SelectSubset<T, ModuleItemComponentCreateArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleItemComponents.
     * @param {ModuleItemComponentCreateManyArgs} args - Arguments to create many ModuleItemComponents.
     * @example
     * // Create many ModuleItemComponents
     * const moduleItemComponent = await prisma.moduleItemComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleItemComponentCreateManyArgs>(args?: SelectSubset<T, ModuleItemComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleItemComponents and returns the data saved in the database.
     * @param {ModuleItemComponentCreateManyAndReturnArgs} args - Arguments to create many ModuleItemComponents.
     * @example
     * // Create many ModuleItemComponents
     * const moduleItemComponent = await prisma.moduleItemComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleItemComponents and only return the `moduleCode`
     * const moduleItemComponentWithModuleCodeOnly = await prisma.moduleItemComponent.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleItemComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleItemComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleItemComponent.
     * @param {ModuleItemComponentDeleteArgs} args - Arguments to delete one ModuleItemComponent.
     * @example
     * // Delete one ModuleItemComponent
     * const ModuleItemComponent = await prisma.moduleItemComponent.delete({
     *   where: {
     *     // ... filter to delete one ModuleItemComponent
     *   }
     * })
     * 
     */
    delete<T extends ModuleItemComponentDeleteArgs>(args: SelectSubset<T, ModuleItemComponentDeleteArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleItemComponent.
     * @param {ModuleItemComponentUpdateArgs} args - Arguments to update one ModuleItemComponent.
     * @example
     * // Update one ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleItemComponentUpdateArgs>(args: SelectSubset<T, ModuleItemComponentUpdateArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleItemComponents.
     * @param {ModuleItemComponentDeleteManyArgs} args - Arguments to filter ModuleItemComponents to delete.
     * @example
     * // Delete a few ModuleItemComponents
     * const { count } = await prisma.moduleItemComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleItemComponentDeleteManyArgs>(args?: SelectSubset<T, ModuleItemComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleItemComponents
     * const moduleItemComponent = await prisma.moduleItemComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleItemComponentUpdateManyArgs>(args: SelectSubset<T, ModuleItemComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleItemComponents and returns the data updated in the database.
     * @param {ModuleItemComponentUpdateManyAndReturnArgs} args - Arguments to update many ModuleItemComponents.
     * @example
     * // Update many ModuleItemComponents
     * const moduleItemComponent = await prisma.moduleItemComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleItemComponents and only return the `moduleCode`
     * const moduleItemComponentWithModuleCodeOnly = await prisma.moduleItemComponent.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleItemComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleItemComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleItemComponent.
     * @param {ModuleItemComponentUpsertArgs} args - Arguments to update or create a ModuleItemComponent.
     * @example
     * // Update or create a ModuleItemComponent
     * const moduleItemComponent = await prisma.moduleItemComponent.upsert({
     *   create: {
     *     // ... data to create a ModuleItemComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleItemComponent we want to update
     *   }
     * })
     */
    upsert<T extends ModuleItemComponentUpsertArgs>(args: SelectSubset<T, ModuleItemComponentUpsertArgs<ExtArgs>>): Prisma__ModuleItemComponentClient<$Result.GetResult<Prisma.$ModuleItemComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleItemComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentCountArgs} args - Arguments to filter ModuleItemComponents to count.
     * @example
     * // Count the number of ModuleItemComponents
     * const count = await prisma.moduleItemComponent.count({
     *   where: {
     *     // ... the filter for the ModuleItemComponents we want to count
     *   }
     * })
    **/
    count<T extends ModuleItemComponentCountArgs>(
      args?: Subset<T, ModuleItemComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleItemComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleItemComponentAggregateArgs>(args: Subset<T, ModuleItemComponentAggregateArgs>): Prisma.PrismaPromise<GetModuleItemComponentAggregateType<T>>

    /**
     * Group by ModuleItemComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleItemComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleItemComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleItemComponentGroupByArgs['orderBy'] }
        : { orderBy?: ModuleItemComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleItemComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleItemComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleItemComponent model
   */
  readonly fields: ModuleItemComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleItemComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleItemComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleItemComponent model
   */
  interface ModuleItemComponentFieldRefs {
    readonly moduleCode: FieldRef<"ModuleItemComponent", 'String'>
    readonly itemCode: FieldRef<"ModuleItemComponent", 'String'>
    readonly quantity: FieldRef<"ModuleItemComponent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ModuleItemComponent findUnique
   */
  export type ModuleItemComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleItemComponent to fetch.
     */
    where: ModuleItemComponentWhereUniqueInput
  }

  /**
   * ModuleItemComponent findUniqueOrThrow
   */
  export type ModuleItemComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleItemComponent to fetch.
     */
    where: ModuleItemComponentWhereUniqueInput
  }

  /**
   * ModuleItemComponent findFirst
   */
  export type ModuleItemComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleItemComponent to fetch.
     */
    where?: ModuleItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleItemComponents to fetch.
     */
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleItemComponents.
     */
    cursor?: ModuleItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleItemComponents.
     */
    distinct?: ModuleItemComponentScalarFieldEnum | ModuleItemComponentScalarFieldEnum[]
  }

  /**
   * ModuleItemComponent findFirstOrThrow
   */
  export type ModuleItemComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleItemComponent to fetch.
     */
    where?: ModuleItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleItemComponents to fetch.
     */
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleItemComponents.
     */
    cursor?: ModuleItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleItemComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleItemComponents.
     */
    distinct?: ModuleItemComponentScalarFieldEnum | ModuleItemComponentScalarFieldEnum[]
  }

  /**
   * ModuleItemComponent findMany
   */
  export type ModuleItemComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleItemComponents to fetch.
     */
    where?: ModuleItemComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleItemComponents to fetch.
     */
    orderBy?: ModuleItemComponentOrderByWithRelationInput | ModuleItemComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleItemComponents.
     */
    cursor?: ModuleItemComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleItemComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleItemComponents.
     */
    skip?: number
    distinct?: ModuleItemComponentScalarFieldEnum | ModuleItemComponentScalarFieldEnum[]
  }

  /**
   * ModuleItemComponent create
   */
  export type ModuleItemComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleItemComponent.
     */
    data: XOR<ModuleItemComponentCreateInput, ModuleItemComponentUncheckedCreateInput>
  }

  /**
   * ModuleItemComponent createMany
   */
  export type ModuleItemComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleItemComponents.
     */
    data: ModuleItemComponentCreateManyInput | ModuleItemComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleItemComponent createManyAndReturn
   */
  export type ModuleItemComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleItemComponents.
     */
    data: ModuleItemComponentCreateManyInput | ModuleItemComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleItemComponent update
   */
  export type ModuleItemComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleItemComponent.
     */
    data: XOR<ModuleItemComponentUpdateInput, ModuleItemComponentUncheckedUpdateInput>
    /**
     * Choose, which ModuleItemComponent to update.
     */
    where: ModuleItemComponentWhereUniqueInput
  }

  /**
   * ModuleItemComponent updateMany
   */
  export type ModuleItemComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleItemComponents.
     */
    data: XOR<ModuleItemComponentUpdateManyMutationInput, ModuleItemComponentUncheckedUpdateManyInput>
    /**
     * Filter which ModuleItemComponents to update
     */
    where?: ModuleItemComponentWhereInput
    /**
     * Limit how many ModuleItemComponents to update.
     */
    limit?: number
  }

  /**
   * ModuleItemComponent updateManyAndReturn
   */
  export type ModuleItemComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * The data used to update ModuleItemComponents.
     */
    data: XOR<ModuleItemComponentUpdateManyMutationInput, ModuleItemComponentUncheckedUpdateManyInput>
    /**
     * Filter which ModuleItemComponents to update
     */
    where?: ModuleItemComponentWhereInput
    /**
     * Limit how many ModuleItemComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleItemComponent upsert
   */
  export type ModuleItemComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleItemComponent to update in case it exists.
     */
    where: ModuleItemComponentWhereUniqueInput
    /**
     * In case the ModuleItemComponent found by the `where` argument doesn't exist, create a new ModuleItemComponent with this data.
     */
    create: XOR<ModuleItemComponentCreateInput, ModuleItemComponentUncheckedCreateInput>
    /**
     * In case the ModuleItemComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleItemComponentUpdateInput, ModuleItemComponentUncheckedUpdateInput>
  }

  /**
   * ModuleItemComponent delete
   */
  export type ModuleItemComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
    /**
     * Filter which ModuleItemComponent to delete.
     */
    where: ModuleItemComponentWhereUniqueInput
  }

  /**
   * ModuleItemComponent deleteMany
   */
  export type ModuleItemComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleItemComponents to delete
     */
    where?: ModuleItemComponentWhereInput
    /**
     * Limit how many ModuleItemComponents to delete.
     */
    limit?: number
  }

  /**
   * ModuleItemComponent without action
   */
  export type ModuleItemComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleItemComponent
     */
    select?: ModuleItemComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleItemComponent
     */
    omit?: ModuleItemComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleItemComponentInclude<ExtArgs> | null
  }


  /**
   * Model ModuleOption
   */

  export type AggregateModuleOption = {
    _count: ModuleOptionCountAggregateOutputType | null
    _min: ModuleOptionMinAggregateOutputType | null
    _max: ModuleOptionMaxAggregateOutputType | null
  }

  export type ModuleOptionMinAggregateOutputType = {
    moduleCode: string | null
    optionCode: string | null
  }

  export type ModuleOptionMaxAggregateOutputType = {
    moduleCode: string | null
    optionCode: string | null
  }

  export type ModuleOptionCountAggregateOutputType = {
    moduleCode: number
    optionCode: number
    _all: number
  }


  export type ModuleOptionMinAggregateInputType = {
    moduleCode?: true
    optionCode?: true
  }

  export type ModuleOptionMaxAggregateInputType = {
    moduleCode?: true
    optionCode?: true
  }

  export type ModuleOptionCountAggregateInputType = {
    moduleCode?: true
    optionCode?: true
    _all?: true
  }

  export type ModuleOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleOption to aggregate.
     */
    where?: ModuleOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOptions to fetch.
     */
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleOptions
    **/
    _count?: true | ModuleOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleOptionMaxAggregateInputType
  }

  export type GetModuleOptionAggregateType<T extends ModuleOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleOption[P]>
      : GetScalarType<T[P], AggregateModuleOption[P]>
  }




  export type ModuleOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleOptionWhereInput
    orderBy?: ModuleOptionOrderByWithAggregationInput | ModuleOptionOrderByWithAggregationInput[]
    by: ModuleOptionScalarFieldEnum[] | ModuleOptionScalarFieldEnum
    having?: ModuleOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleOptionCountAggregateInputType | true
    _min?: ModuleOptionMinAggregateInputType
    _max?: ModuleOptionMaxAggregateInputType
  }

  export type ModuleOptionGroupByOutputType = {
    moduleCode: string
    optionCode: string
    _count: ModuleOptionCountAggregateOutputType | null
    _min: ModuleOptionMinAggregateOutputType | null
    _max: ModuleOptionMaxAggregateOutputType | null
  }

  type GetModuleOptionGroupByPayload<T extends ModuleOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleOptionGroupByOutputType[P]>
        }
      >
    >


  export type ModuleOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    optionCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleOption"]>

  export type ModuleOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    optionCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleOption"]>

  export type ModuleOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    optionCode?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleOption"]>

  export type ModuleOptionSelectScalar = {
    moduleCode?: boolean
    optionCode?: boolean
  }

  export type ModuleOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "optionCode", ExtArgs["result"]["moduleOption"]>
  export type ModuleOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type ModuleOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type ModuleOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }

  export type $ModuleOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleOption"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      option: Prisma.$OptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      optionCode: string
    }, ExtArgs["result"]["moduleOption"]>
    composites: {}
  }

  type ModuleOptionGetPayload<S extends boolean | null | undefined | ModuleOptionDefaultArgs> = $Result.GetResult<Prisma.$ModuleOptionPayload, S>

  type ModuleOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleOptionCountAggregateInputType | true
    }

  export interface ModuleOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleOption'], meta: { name: 'ModuleOption' } }
    /**
     * Find zero or one ModuleOption that matches the filter.
     * @param {ModuleOptionFindUniqueArgs} args - Arguments to find a ModuleOption
     * @example
     * // Get one ModuleOption
     * const moduleOption = await prisma.moduleOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleOptionFindUniqueArgs>(args: SelectSubset<T, ModuleOptionFindUniqueArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleOptionFindUniqueOrThrowArgs} args - Arguments to find a ModuleOption
     * @example
     * // Get one ModuleOption
     * const moduleOption = await prisma.moduleOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionFindFirstArgs} args - Arguments to find a ModuleOption
     * @example
     * // Get one ModuleOption
     * const moduleOption = await prisma.moduleOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleOptionFindFirstArgs>(args?: SelectSubset<T, ModuleOptionFindFirstArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionFindFirstOrThrowArgs} args - Arguments to find a ModuleOption
     * @example
     * // Get one ModuleOption
     * const moduleOption = await prisma.moduleOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleOptions
     * const moduleOptions = await prisma.moduleOption.findMany()
     * 
     * // Get first 10 ModuleOptions
     * const moduleOptions = await prisma.moduleOption.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const moduleOptionWithModuleCodeOnly = await prisma.moduleOption.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModuleOptionFindManyArgs>(args?: SelectSubset<T, ModuleOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleOption.
     * @param {ModuleOptionCreateArgs} args - Arguments to create a ModuleOption.
     * @example
     * // Create one ModuleOption
     * const ModuleOption = await prisma.moduleOption.create({
     *   data: {
     *     // ... data to create a ModuleOption
     *   }
     * })
     * 
     */
    create<T extends ModuleOptionCreateArgs>(args: SelectSubset<T, ModuleOptionCreateArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleOptions.
     * @param {ModuleOptionCreateManyArgs} args - Arguments to create many ModuleOptions.
     * @example
     * // Create many ModuleOptions
     * const moduleOption = await prisma.moduleOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleOptionCreateManyArgs>(args?: SelectSubset<T, ModuleOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleOptions and returns the data saved in the database.
     * @param {ModuleOptionCreateManyAndReturnArgs} args - Arguments to create many ModuleOptions.
     * @example
     * // Create many ModuleOptions
     * const moduleOption = await prisma.moduleOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleOptions and only return the `moduleCode`
     * const moduleOptionWithModuleCodeOnly = await prisma.moduleOption.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleOption.
     * @param {ModuleOptionDeleteArgs} args - Arguments to delete one ModuleOption.
     * @example
     * // Delete one ModuleOption
     * const ModuleOption = await prisma.moduleOption.delete({
     *   where: {
     *     // ... filter to delete one ModuleOption
     *   }
     * })
     * 
     */
    delete<T extends ModuleOptionDeleteArgs>(args: SelectSubset<T, ModuleOptionDeleteArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleOption.
     * @param {ModuleOptionUpdateArgs} args - Arguments to update one ModuleOption.
     * @example
     * // Update one ModuleOption
     * const moduleOption = await prisma.moduleOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleOptionUpdateArgs>(args: SelectSubset<T, ModuleOptionUpdateArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleOptions.
     * @param {ModuleOptionDeleteManyArgs} args - Arguments to filter ModuleOptions to delete.
     * @example
     * // Delete a few ModuleOptions
     * const { count } = await prisma.moduleOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleOptionDeleteManyArgs>(args?: SelectSubset<T, ModuleOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleOptions
     * const moduleOption = await prisma.moduleOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleOptionUpdateManyArgs>(args: SelectSubset<T, ModuleOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleOptions and returns the data updated in the database.
     * @param {ModuleOptionUpdateManyAndReturnArgs} args - Arguments to update many ModuleOptions.
     * @example
     * // Update many ModuleOptions
     * const moduleOption = await prisma.moduleOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleOptions and only return the `moduleCode`
     * const moduleOptionWithModuleCodeOnly = await prisma.moduleOption.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleOption.
     * @param {ModuleOptionUpsertArgs} args - Arguments to update or create a ModuleOption.
     * @example
     * // Update or create a ModuleOption
     * const moduleOption = await prisma.moduleOption.upsert({
     *   create: {
     *     // ... data to create a ModuleOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleOption we want to update
     *   }
     * })
     */
    upsert<T extends ModuleOptionUpsertArgs>(args: SelectSubset<T, ModuleOptionUpsertArgs<ExtArgs>>): Prisma__ModuleOptionClient<$Result.GetResult<Prisma.$ModuleOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionCountArgs} args - Arguments to filter ModuleOptions to count.
     * @example
     * // Count the number of ModuleOptions
     * const count = await prisma.moduleOption.count({
     *   where: {
     *     // ... the filter for the ModuleOptions we want to count
     *   }
     * })
    **/
    count<T extends ModuleOptionCountArgs>(
      args?: Subset<T, ModuleOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleOptionAggregateArgs>(args: Subset<T, ModuleOptionAggregateArgs>): Prisma.PrismaPromise<GetModuleOptionAggregateType<T>>

    /**
     * Group by ModuleOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleOptionGroupByArgs['orderBy'] }
        : { orderBy?: ModuleOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleOption model
   */
  readonly fields: ModuleOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends OptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OptionDefaultArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleOption model
   */
  interface ModuleOptionFieldRefs {
    readonly moduleCode: FieldRef<"ModuleOption", 'String'>
    readonly optionCode: FieldRef<"ModuleOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModuleOption findUnique
   */
  export type ModuleOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOption to fetch.
     */
    where: ModuleOptionWhereUniqueInput
  }

  /**
   * ModuleOption findUniqueOrThrow
   */
  export type ModuleOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOption to fetch.
     */
    where: ModuleOptionWhereUniqueInput
  }

  /**
   * ModuleOption findFirst
   */
  export type ModuleOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOption to fetch.
     */
    where?: ModuleOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOptions to fetch.
     */
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleOptions.
     */
    cursor?: ModuleOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleOptions.
     */
    distinct?: ModuleOptionScalarFieldEnum | ModuleOptionScalarFieldEnum[]
  }

  /**
   * ModuleOption findFirstOrThrow
   */
  export type ModuleOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOption to fetch.
     */
    where?: ModuleOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOptions to fetch.
     */
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleOptions.
     */
    cursor?: ModuleOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleOptions.
     */
    distinct?: ModuleOptionScalarFieldEnum | ModuleOptionScalarFieldEnum[]
  }

  /**
   * ModuleOption findMany
   */
  export type ModuleOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOptions to fetch.
     */
    where?: ModuleOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOptions to fetch.
     */
    orderBy?: ModuleOptionOrderByWithRelationInput | ModuleOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleOptions.
     */
    cursor?: ModuleOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOptions.
     */
    skip?: number
    distinct?: ModuleOptionScalarFieldEnum | ModuleOptionScalarFieldEnum[]
  }

  /**
   * ModuleOption create
   */
  export type ModuleOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleOption.
     */
    data: XOR<ModuleOptionCreateInput, ModuleOptionUncheckedCreateInput>
  }

  /**
   * ModuleOption createMany
   */
  export type ModuleOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleOptions.
     */
    data: ModuleOptionCreateManyInput | ModuleOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleOption createManyAndReturn
   */
  export type ModuleOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleOptions.
     */
    data: ModuleOptionCreateManyInput | ModuleOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleOption update
   */
  export type ModuleOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleOption.
     */
    data: XOR<ModuleOptionUpdateInput, ModuleOptionUncheckedUpdateInput>
    /**
     * Choose, which ModuleOption to update.
     */
    where: ModuleOptionWhereUniqueInput
  }

  /**
   * ModuleOption updateMany
   */
  export type ModuleOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleOptions.
     */
    data: XOR<ModuleOptionUpdateManyMutationInput, ModuleOptionUncheckedUpdateManyInput>
    /**
     * Filter which ModuleOptions to update
     */
    where?: ModuleOptionWhereInput
    /**
     * Limit how many ModuleOptions to update.
     */
    limit?: number
  }

  /**
   * ModuleOption updateManyAndReturn
   */
  export type ModuleOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * The data used to update ModuleOptions.
     */
    data: XOR<ModuleOptionUpdateManyMutationInput, ModuleOptionUncheckedUpdateManyInput>
    /**
     * Filter which ModuleOptions to update
     */
    where?: ModuleOptionWhereInput
    /**
     * Limit how many ModuleOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleOption upsert
   */
  export type ModuleOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleOption to update in case it exists.
     */
    where: ModuleOptionWhereUniqueInput
    /**
     * In case the ModuleOption found by the `where` argument doesn't exist, create a new ModuleOption with this data.
     */
    create: XOR<ModuleOptionCreateInput, ModuleOptionUncheckedCreateInput>
    /**
     * In case the ModuleOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleOptionUpdateInput, ModuleOptionUncheckedUpdateInput>
  }

  /**
   * ModuleOption delete
   */
  export type ModuleOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
    /**
     * Filter which ModuleOption to delete.
     */
    where: ModuleOptionWhereUniqueInput
  }

  /**
   * ModuleOption deleteMany
   */
  export type ModuleOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleOptions to delete
     */
    where?: ModuleOptionWhereInput
    /**
     * Limit how many ModuleOptions to delete.
     */
    limit?: number
  }

  /**
   * ModuleOption without action
   */
  export type ModuleOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOption
     */
    select?: ModuleOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleOption
     */
    omit?: ModuleOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleOptionInclude<ExtArgs> | null
  }


  /**
   * Model ModulePrice
   */

  export type AggregateModulePrice = {
    _count: ModulePriceCountAggregateOutputType | null
    _avg: ModulePriceAvgAggregateOutputType | null
    _sum: ModulePriceSumAggregateOutputType | null
    _min: ModulePriceMinAggregateOutputType | null
    _max: ModulePriceMaxAggregateOutputType | null
  }

  export type ModulePriceAvgAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ModulePriceSumAggregateOutputType = {
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ModulePriceMinAggregateOutputType = {
    moduleCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ModulePriceMaxAggregateOutputType = {
    moduleCode: string | null
    priceUsd: Decimal | null
    priceRub: Decimal | null
  }

  export type ModulePriceCountAggregateOutputType = {
    moduleCode: number
    priceUsd: number
    priceRub: number
    _all: number
  }


  export type ModulePriceAvgAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type ModulePriceSumAggregateInputType = {
    priceUsd?: true
    priceRub?: true
  }

  export type ModulePriceMinAggregateInputType = {
    moduleCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type ModulePriceMaxAggregateInputType = {
    moduleCode?: true
    priceUsd?: true
    priceRub?: true
  }

  export type ModulePriceCountAggregateInputType = {
    moduleCode?: true
    priceUsd?: true
    priceRub?: true
    _all?: true
  }

  export type ModulePriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePrice to aggregate.
     */
    where?: ModulePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrices to fetch.
     */
    orderBy?: ModulePriceOrderByWithRelationInput | ModulePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModulePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModulePrices
    **/
    _count?: true | ModulePriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModulePriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModulePriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulePriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulePriceMaxAggregateInputType
  }

  export type GetModulePriceAggregateType<T extends ModulePriceAggregateArgs> = {
        [P in keyof T & keyof AggregateModulePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulePrice[P]>
      : GetScalarType<T[P], AggregateModulePrice[P]>
  }




  export type ModulePriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePriceWhereInput
    orderBy?: ModulePriceOrderByWithAggregationInput | ModulePriceOrderByWithAggregationInput[]
    by: ModulePriceScalarFieldEnum[] | ModulePriceScalarFieldEnum
    having?: ModulePriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulePriceCountAggregateInputType | true
    _avg?: ModulePriceAvgAggregateInputType
    _sum?: ModulePriceSumAggregateInputType
    _min?: ModulePriceMinAggregateInputType
    _max?: ModulePriceMaxAggregateInputType
  }

  export type ModulePriceGroupByOutputType = {
    moduleCode: string
    priceUsd: Decimal | null
    priceRub: Decimal | null
    _count: ModulePriceCountAggregateOutputType | null
    _avg: ModulePriceAvgAggregateOutputType | null
    _sum: ModulePriceSumAggregateOutputType | null
    _min: ModulePriceMinAggregateOutputType | null
    _max: ModulePriceMaxAggregateOutputType | null
  }

  type GetModulePriceGroupByPayload<T extends ModulePriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulePriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulePriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulePriceGroupByOutputType[P]>
            : GetScalarType<T[P], ModulePriceGroupByOutputType[P]>
        }
      >
    >


  export type ModulePriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePrice"]>

  export type ModulePriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePrice"]>

  export type ModulePriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePrice"]>

  export type ModulePriceSelectScalar = {
    moduleCode?: boolean
    priceUsd?: boolean
    priceRub?: boolean
  }

  export type ModulePriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleCode" | "priceUsd" | "priceRub", ExtArgs["result"]["modulePrice"]>
  export type ModulePriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ModulePriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ModulePriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ModulePricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModulePrice"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleCode: string
      priceUsd: Prisma.Decimal | null
      priceRub: Prisma.Decimal | null
    }, ExtArgs["result"]["modulePrice"]>
    composites: {}
  }

  type ModulePriceGetPayload<S extends boolean | null | undefined | ModulePriceDefaultArgs> = $Result.GetResult<Prisma.$ModulePricePayload, S>

  type ModulePriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModulePriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModulePriceCountAggregateInputType | true
    }

  export interface ModulePriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModulePrice'], meta: { name: 'ModulePrice' } }
    /**
     * Find zero or one ModulePrice that matches the filter.
     * @param {ModulePriceFindUniqueArgs} args - Arguments to find a ModulePrice
     * @example
     * // Get one ModulePrice
     * const modulePrice = await prisma.modulePrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModulePriceFindUniqueArgs>(args: SelectSubset<T, ModulePriceFindUniqueArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModulePrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModulePriceFindUniqueOrThrowArgs} args - Arguments to find a ModulePrice
     * @example
     * // Get one ModulePrice
     * const modulePrice = await prisma.modulePrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModulePriceFindUniqueOrThrowArgs>(args: SelectSubset<T, ModulePriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceFindFirstArgs} args - Arguments to find a ModulePrice
     * @example
     * // Get one ModulePrice
     * const modulePrice = await prisma.modulePrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModulePriceFindFirstArgs>(args?: SelectSubset<T, ModulePriceFindFirstArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceFindFirstOrThrowArgs} args - Arguments to find a ModulePrice
     * @example
     * // Get one ModulePrice
     * const modulePrice = await prisma.modulePrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModulePriceFindFirstOrThrowArgs>(args?: SelectSubset<T, ModulePriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModulePrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModulePrices
     * const modulePrices = await prisma.modulePrice.findMany()
     * 
     * // Get first 10 ModulePrices
     * const modulePrices = await prisma.modulePrice.findMany({ take: 10 })
     * 
     * // Only select the `moduleCode`
     * const modulePriceWithModuleCodeOnly = await prisma.modulePrice.findMany({ select: { moduleCode: true } })
     * 
     */
    findMany<T extends ModulePriceFindManyArgs>(args?: SelectSubset<T, ModulePriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModulePrice.
     * @param {ModulePriceCreateArgs} args - Arguments to create a ModulePrice.
     * @example
     * // Create one ModulePrice
     * const ModulePrice = await prisma.modulePrice.create({
     *   data: {
     *     // ... data to create a ModulePrice
     *   }
     * })
     * 
     */
    create<T extends ModulePriceCreateArgs>(args: SelectSubset<T, ModulePriceCreateArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModulePrices.
     * @param {ModulePriceCreateManyArgs} args - Arguments to create many ModulePrices.
     * @example
     * // Create many ModulePrices
     * const modulePrice = await prisma.modulePrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModulePriceCreateManyArgs>(args?: SelectSubset<T, ModulePriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModulePrices and returns the data saved in the database.
     * @param {ModulePriceCreateManyAndReturnArgs} args - Arguments to create many ModulePrices.
     * @example
     * // Create many ModulePrices
     * const modulePrice = await prisma.modulePrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModulePrices and only return the `moduleCode`
     * const modulePriceWithModuleCodeOnly = await prisma.modulePrice.createManyAndReturn({
     *   select: { moduleCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModulePriceCreateManyAndReturnArgs>(args?: SelectSubset<T, ModulePriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModulePrice.
     * @param {ModulePriceDeleteArgs} args - Arguments to delete one ModulePrice.
     * @example
     * // Delete one ModulePrice
     * const ModulePrice = await prisma.modulePrice.delete({
     *   where: {
     *     // ... filter to delete one ModulePrice
     *   }
     * })
     * 
     */
    delete<T extends ModulePriceDeleteArgs>(args: SelectSubset<T, ModulePriceDeleteArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModulePrice.
     * @param {ModulePriceUpdateArgs} args - Arguments to update one ModulePrice.
     * @example
     * // Update one ModulePrice
     * const modulePrice = await prisma.modulePrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModulePriceUpdateArgs>(args: SelectSubset<T, ModulePriceUpdateArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModulePrices.
     * @param {ModulePriceDeleteManyArgs} args - Arguments to filter ModulePrices to delete.
     * @example
     * // Delete a few ModulePrices
     * const { count } = await prisma.modulePrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModulePriceDeleteManyArgs>(args?: SelectSubset<T, ModulePriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModulePrices
     * const modulePrice = await prisma.modulePrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModulePriceUpdateManyArgs>(args: SelectSubset<T, ModulePriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePrices and returns the data updated in the database.
     * @param {ModulePriceUpdateManyAndReturnArgs} args - Arguments to update many ModulePrices.
     * @example
     * // Update many ModulePrices
     * const modulePrice = await prisma.modulePrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModulePrices and only return the `moduleCode`
     * const modulePriceWithModuleCodeOnly = await prisma.modulePrice.updateManyAndReturn({
     *   select: { moduleCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModulePriceUpdateManyAndReturnArgs>(args: SelectSubset<T, ModulePriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModulePrice.
     * @param {ModulePriceUpsertArgs} args - Arguments to update or create a ModulePrice.
     * @example
     * // Update or create a ModulePrice
     * const modulePrice = await prisma.modulePrice.upsert({
     *   create: {
     *     // ... data to create a ModulePrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModulePrice we want to update
     *   }
     * })
     */
    upsert<T extends ModulePriceUpsertArgs>(args: SelectSubset<T, ModulePriceUpsertArgs<ExtArgs>>): Prisma__ModulePriceClient<$Result.GetResult<Prisma.$ModulePricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModulePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceCountArgs} args - Arguments to filter ModulePrices to count.
     * @example
     * // Count the number of ModulePrices
     * const count = await prisma.modulePrice.count({
     *   where: {
     *     // ... the filter for the ModulePrices we want to count
     *   }
     * })
    **/
    count<T extends ModulePriceCountArgs>(
      args?: Subset<T, ModulePriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulePriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModulePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulePriceAggregateArgs>(args: Subset<T, ModulePriceAggregateArgs>): Prisma.PrismaPromise<GetModulePriceAggregateType<T>>

    /**
     * Group by ModulePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModulePriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModulePriceGroupByArgs['orderBy'] }
        : { orderBy?: ModulePriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModulePriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulePriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModulePrice model
   */
  readonly fields: ModulePriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModulePrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModulePriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModulePrice model
   */
  interface ModulePriceFieldRefs {
    readonly moduleCode: FieldRef<"ModulePrice", 'String'>
    readonly priceUsd: FieldRef<"ModulePrice", 'Decimal'>
    readonly priceRub: FieldRef<"ModulePrice", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ModulePrice findUnique
   */
  export type ModulePriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrice to fetch.
     */
    where: ModulePriceWhereUniqueInput
  }

  /**
   * ModulePrice findUniqueOrThrow
   */
  export type ModulePriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrice to fetch.
     */
    where: ModulePriceWhereUniqueInput
  }

  /**
   * ModulePrice findFirst
   */
  export type ModulePriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrice to fetch.
     */
    where?: ModulePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrices to fetch.
     */
    orderBy?: ModulePriceOrderByWithRelationInput | ModulePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePrices.
     */
    cursor?: ModulePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePrices.
     */
    distinct?: ModulePriceScalarFieldEnum | ModulePriceScalarFieldEnum[]
  }

  /**
   * ModulePrice findFirstOrThrow
   */
  export type ModulePriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrice to fetch.
     */
    where?: ModulePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrices to fetch.
     */
    orderBy?: ModulePriceOrderByWithRelationInput | ModulePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePrices.
     */
    cursor?: ModulePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePrices.
     */
    distinct?: ModulePriceScalarFieldEnum | ModulePriceScalarFieldEnum[]
  }

  /**
   * ModulePrice findMany
   */
  export type ModulePriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrices to fetch.
     */
    where?: ModulePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrices to fetch.
     */
    orderBy?: ModulePriceOrderByWithRelationInput | ModulePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModulePrices.
     */
    cursor?: ModulePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrices.
     */
    skip?: number
    distinct?: ModulePriceScalarFieldEnum | ModulePriceScalarFieldEnum[]
  }

  /**
   * ModulePrice create
   */
  export type ModulePriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * The data needed to create a ModulePrice.
     */
    data: XOR<ModulePriceCreateInput, ModulePriceUncheckedCreateInput>
  }

  /**
   * ModulePrice createMany
   */
  export type ModulePriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModulePrices.
     */
    data: ModulePriceCreateManyInput | ModulePriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModulePrice createManyAndReturn
   */
  export type ModulePriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * The data used to create many ModulePrices.
     */
    data: ModulePriceCreateManyInput | ModulePriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePrice update
   */
  export type ModulePriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * The data needed to update a ModulePrice.
     */
    data: XOR<ModulePriceUpdateInput, ModulePriceUncheckedUpdateInput>
    /**
     * Choose, which ModulePrice to update.
     */
    where: ModulePriceWhereUniqueInput
  }

  /**
   * ModulePrice updateMany
   */
  export type ModulePriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModulePrices.
     */
    data: XOR<ModulePriceUpdateManyMutationInput, ModulePriceUncheckedUpdateManyInput>
    /**
     * Filter which ModulePrices to update
     */
    where?: ModulePriceWhereInput
    /**
     * Limit how many ModulePrices to update.
     */
    limit?: number
  }

  /**
   * ModulePrice updateManyAndReturn
   */
  export type ModulePriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * The data used to update ModulePrices.
     */
    data: XOR<ModulePriceUpdateManyMutationInput, ModulePriceUncheckedUpdateManyInput>
    /**
     * Filter which ModulePrices to update
     */
    where?: ModulePriceWhereInput
    /**
     * Limit how many ModulePrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePrice upsert
   */
  export type ModulePriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * The filter to search for the ModulePrice to update in case it exists.
     */
    where: ModulePriceWhereUniqueInput
    /**
     * In case the ModulePrice found by the `where` argument doesn't exist, create a new ModulePrice with this data.
     */
    create: XOR<ModulePriceCreateInput, ModulePriceUncheckedCreateInput>
    /**
     * In case the ModulePrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModulePriceUpdateInput, ModulePriceUncheckedUpdateInput>
  }

  /**
   * ModulePrice delete
   */
  export type ModulePriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
    /**
     * Filter which ModulePrice to delete.
     */
    where: ModulePriceWhereUniqueInput
  }

  /**
   * ModulePrice deleteMany
   */
  export type ModulePriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePrices to delete
     */
    where?: ModulePriceWhereInput
    /**
     * Limit how many ModulePrices to delete.
     */
    limit?: number
  }

  /**
   * ModulePrice without action
   */
  export type ModulePriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrice
     */
    select?: ModulePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePrice
     */
    omit?: ModulePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePriceInclude<ExtArgs> | null
  }


  /**
   * Model CabinetSizeModuleSize
   */

  export type AggregateCabinetSizeModuleSize = {
    _count: CabinetSizeModuleSizeCountAggregateOutputType | null
    _min: CabinetSizeModuleSizeMinAggregateOutputType | null
    _max: CabinetSizeModuleSizeMaxAggregateOutputType | null
  }

  export type CabinetSizeModuleSizeMinAggregateOutputType = {
    cabinetSizeCode: string | null
    moduleSizeCode: string | null
  }

  export type CabinetSizeModuleSizeMaxAggregateOutputType = {
    cabinetSizeCode: string | null
    moduleSizeCode: string | null
  }

  export type CabinetSizeModuleSizeCountAggregateOutputType = {
    cabinetSizeCode: number
    moduleSizeCode: number
    _all: number
  }


  export type CabinetSizeModuleSizeMinAggregateInputType = {
    cabinetSizeCode?: true
    moduleSizeCode?: true
  }

  export type CabinetSizeModuleSizeMaxAggregateInputType = {
    cabinetSizeCode?: true
    moduleSizeCode?: true
  }

  export type CabinetSizeModuleSizeCountAggregateInputType = {
    cabinetSizeCode?: true
    moduleSizeCode?: true
    _all?: true
  }

  export type CabinetSizeModuleSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSizeModuleSize to aggregate.
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizeModuleSizes to fetch.
     */
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizeModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizeModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetSizeModuleSizes
    **/
    _count?: true | CabinetSizeModuleSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetSizeModuleSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetSizeModuleSizeMaxAggregateInputType
  }

  export type GetCabinetSizeModuleSizeAggregateType<T extends CabinetSizeModuleSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetSizeModuleSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetSizeModuleSize[P]>
      : GetScalarType<T[P], AggregateCabinetSizeModuleSize[P]>
  }




  export type CabinetSizeModuleSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetSizeModuleSizeWhereInput
    orderBy?: CabinetSizeModuleSizeOrderByWithAggregationInput | CabinetSizeModuleSizeOrderByWithAggregationInput[]
    by: CabinetSizeModuleSizeScalarFieldEnum[] | CabinetSizeModuleSizeScalarFieldEnum
    having?: CabinetSizeModuleSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetSizeModuleSizeCountAggregateInputType | true
    _min?: CabinetSizeModuleSizeMinAggregateInputType
    _max?: CabinetSizeModuleSizeMaxAggregateInputType
  }

  export type CabinetSizeModuleSizeGroupByOutputType = {
    cabinetSizeCode: string
    moduleSizeCode: string
    _count: CabinetSizeModuleSizeCountAggregateOutputType | null
    _min: CabinetSizeModuleSizeMinAggregateOutputType | null
    _max: CabinetSizeModuleSizeMaxAggregateOutputType | null
  }

  type GetCabinetSizeModuleSizeGroupByPayload<T extends CabinetSizeModuleSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetSizeModuleSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetSizeModuleSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetSizeModuleSizeGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetSizeModuleSizeGroupByOutputType[P]>
        }
      >
    >


  export type CabinetSizeModuleSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetSizeCode?: boolean
    moduleSizeCode?: boolean
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSizeModuleSize"]>

  export type CabinetSizeModuleSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetSizeCode?: boolean
    moduleSizeCode?: boolean
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSizeModuleSize"]>

  export type CabinetSizeModuleSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cabinetSizeCode?: boolean
    moduleSizeCode?: boolean
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetSizeModuleSize"]>

  export type CabinetSizeModuleSizeSelectScalar = {
    cabinetSizeCode?: boolean
    moduleSizeCode?: boolean
  }

  export type CabinetSizeModuleSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cabinetSizeCode" | "moduleSizeCode", ExtArgs["result"]["cabinetSizeModuleSize"]>
  export type CabinetSizeModuleSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }
  export type CabinetSizeModuleSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }
  export type CabinetSizeModuleSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cabinetSize?: boolean | CabinetSizeDefaultArgs<ExtArgs>
    moduleSize?: boolean | ModuleSizeDefaultArgs<ExtArgs>
  }

  export type $CabinetSizeModuleSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetSizeModuleSize"
    objects: {
      cabinetSize: Prisma.$CabinetSizePayload<ExtArgs>
      moduleSize: Prisma.$ModuleSizePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cabinetSizeCode: string
      moduleSizeCode: string
    }, ExtArgs["result"]["cabinetSizeModuleSize"]>
    composites: {}
  }

  type CabinetSizeModuleSizeGetPayload<S extends boolean | null | undefined | CabinetSizeModuleSizeDefaultArgs> = $Result.GetResult<Prisma.$CabinetSizeModuleSizePayload, S>

  type CabinetSizeModuleSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetSizeModuleSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetSizeModuleSizeCountAggregateInputType | true
    }

  export interface CabinetSizeModuleSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetSizeModuleSize'], meta: { name: 'CabinetSizeModuleSize' } }
    /**
     * Find zero or one CabinetSizeModuleSize that matches the filter.
     * @param {CabinetSizeModuleSizeFindUniqueArgs} args - Arguments to find a CabinetSizeModuleSize
     * @example
     * // Get one CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetSizeModuleSizeFindUniqueArgs>(args: SelectSubset<T, CabinetSizeModuleSizeFindUniqueArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetSizeModuleSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetSizeModuleSizeFindUniqueOrThrowArgs} args - Arguments to find a CabinetSizeModuleSize
     * @example
     * // Get one CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetSizeModuleSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetSizeModuleSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSizeModuleSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeFindFirstArgs} args - Arguments to find a CabinetSizeModuleSize
     * @example
     * // Get one CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetSizeModuleSizeFindFirstArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeFindFirstArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetSizeModuleSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeFindFirstOrThrowArgs} args - Arguments to find a CabinetSizeModuleSize
     * @example
     * // Get one CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetSizeModuleSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetSizeModuleSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetSizeModuleSizes
     * const cabinetSizeModuleSizes = await prisma.cabinetSizeModuleSize.findMany()
     * 
     * // Get first 10 CabinetSizeModuleSizes
     * const cabinetSizeModuleSizes = await prisma.cabinetSizeModuleSize.findMany({ take: 10 })
     * 
     * // Only select the `cabinetSizeCode`
     * const cabinetSizeModuleSizeWithCabinetSizeCodeOnly = await prisma.cabinetSizeModuleSize.findMany({ select: { cabinetSizeCode: true } })
     * 
     */
    findMany<T extends CabinetSizeModuleSizeFindManyArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetSizeModuleSize.
     * @param {CabinetSizeModuleSizeCreateArgs} args - Arguments to create a CabinetSizeModuleSize.
     * @example
     * // Create one CabinetSizeModuleSize
     * const CabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.create({
     *   data: {
     *     // ... data to create a CabinetSizeModuleSize
     *   }
     * })
     * 
     */
    create<T extends CabinetSizeModuleSizeCreateArgs>(args: SelectSubset<T, CabinetSizeModuleSizeCreateArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetSizeModuleSizes.
     * @param {CabinetSizeModuleSizeCreateManyArgs} args - Arguments to create many CabinetSizeModuleSizes.
     * @example
     * // Create many CabinetSizeModuleSizes
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetSizeModuleSizeCreateManyArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetSizeModuleSizes and returns the data saved in the database.
     * @param {CabinetSizeModuleSizeCreateManyAndReturnArgs} args - Arguments to create many CabinetSizeModuleSizes.
     * @example
     * // Create many CabinetSizeModuleSizes
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetSizeModuleSizes and only return the `cabinetSizeCode`
     * const cabinetSizeModuleSizeWithCabinetSizeCodeOnly = await prisma.cabinetSizeModuleSize.createManyAndReturn({
     *   select: { cabinetSizeCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetSizeModuleSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetSizeModuleSize.
     * @param {CabinetSizeModuleSizeDeleteArgs} args - Arguments to delete one CabinetSizeModuleSize.
     * @example
     * // Delete one CabinetSizeModuleSize
     * const CabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.delete({
     *   where: {
     *     // ... filter to delete one CabinetSizeModuleSize
     *   }
     * })
     * 
     */
    delete<T extends CabinetSizeModuleSizeDeleteArgs>(args: SelectSubset<T, CabinetSizeModuleSizeDeleteArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetSizeModuleSize.
     * @param {CabinetSizeModuleSizeUpdateArgs} args - Arguments to update one CabinetSizeModuleSize.
     * @example
     * // Update one CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetSizeModuleSizeUpdateArgs>(args: SelectSubset<T, CabinetSizeModuleSizeUpdateArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetSizeModuleSizes.
     * @param {CabinetSizeModuleSizeDeleteManyArgs} args - Arguments to filter CabinetSizeModuleSizes to delete.
     * @example
     * // Delete a few CabinetSizeModuleSizes
     * const { count } = await prisma.cabinetSizeModuleSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetSizeModuleSizeDeleteManyArgs>(args?: SelectSubset<T, CabinetSizeModuleSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSizeModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetSizeModuleSizes
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetSizeModuleSizeUpdateManyArgs>(args: SelectSubset<T, CabinetSizeModuleSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetSizeModuleSizes and returns the data updated in the database.
     * @param {CabinetSizeModuleSizeUpdateManyAndReturnArgs} args - Arguments to update many CabinetSizeModuleSizes.
     * @example
     * // Update many CabinetSizeModuleSizes
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetSizeModuleSizes and only return the `cabinetSizeCode`
     * const cabinetSizeModuleSizeWithCabinetSizeCodeOnly = await prisma.cabinetSizeModuleSize.updateManyAndReturn({
     *   select: { cabinetSizeCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetSizeModuleSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetSizeModuleSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetSizeModuleSize.
     * @param {CabinetSizeModuleSizeUpsertArgs} args - Arguments to update or create a CabinetSizeModuleSize.
     * @example
     * // Update or create a CabinetSizeModuleSize
     * const cabinetSizeModuleSize = await prisma.cabinetSizeModuleSize.upsert({
     *   create: {
     *     // ... data to create a CabinetSizeModuleSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetSizeModuleSize we want to update
     *   }
     * })
     */
    upsert<T extends CabinetSizeModuleSizeUpsertArgs>(args: SelectSubset<T, CabinetSizeModuleSizeUpsertArgs<ExtArgs>>): Prisma__CabinetSizeModuleSizeClient<$Result.GetResult<Prisma.$CabinetSizeModuleSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetSizeModuleSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeCountArgs} args - Arguments to filter CabinetSizeModuleSizes to count.
     * @example
     * // Count the number of CabinetSizeModuleSizes
     * const count = await prisma.cabinetSizeModuleSize.count({
     *   where: {
     *     // ... the filter for the CabinetSizeModuleSizes we want to count
     *   }
     * })
    **/
    count<T extends CabinetSizeModuleSizeCountArgs>(
      args?: Subset<T, CabinetSizeModuleSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetSizeModuleSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetSizeModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetSizeModuleSizeAggregateArgs>(args: Subset<T, CabinetSizeModuleSizeAggregateArgs>): Prisma.PrismaPromise<GetCabinetSizeModuleSizeAggregateType<T>>

    /**
     * Group by CabinetSizeModuleSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetSizeModuleSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetSizeModuleSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetSizeModuleSizeGroupByArgs['orderBy'] }
        : { orderBy?: CabinetSizeModuleSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetSizeModuleSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetSizeModuleSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetSizeModuleSize model
   */
  readonly fields: CabinetSizeModuleSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetSizeModuleSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetSizeModuleSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cabinetSize<T extends CabinetSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetSizeDefaultArgs<ExtArgs>>): Prisma__CabinetSizeClient<$Result.GetResult<Prisma.$CabinetSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moduleSize<T extends ModuleSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleSizeDefaultArgs<ExtArgs>>): Prisma__ModuleSizeClient<$Result.GetResult<Prisma.$ModuleSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetSizeModuleSize model
   */
  interface CabinetSizeModuleSizeFieldRefs {
    readonly cabinetSizeCode: FieldRef<"CabinetSizeModuleSize", 'String'>
    readonly moduleSizeCode: FieldRef<"CabinetSizeModuleSize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CabinetSizeModuleSize findUnique
   */
  export type CabinetSizeModuleSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizeModuleSize to fetch.
     */
    where: CabinetSizeModuleSizeWhereUniqueInput
  }

  /**
   * CabinetSizeModuleSize findUniqueOrThrow
   */
  export type CabinetSizeModuleSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizeModuleSize to fetch.
     */
    where: CabinetSizeModuleSizeWhereUniqueInput
  }

  /**
   * CabinetSizeModuleSize findFirst
   */
  export type CabinetSizeModuleSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizeModuleSize to fetch.
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizeModuleSizes to fetch.
     */
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSizeModuleSizes.
     */
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizeModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizeModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSizeModuleSizes.
     */
    distinct?: CabinetSizeModuleSizeScalarFieldEnum | CabinetSizeModuleSizeScalarFieldEnum[]
  }

  /**
   * CabinetSizeModuleSize findFirstOrThrow
   */
  export type CabinetSizeModuleSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizeModuleSize to fetch.
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizeModuleSizes to fetch.
     */
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetSizeModuleSizes.
     */
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizeModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizeModuleSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetSizeModuleSizes.
     */
    distinct?: CabinetSizeModuleSizeScalarFieldEnum | CabinetSizeModuleSizeScalarFieldEnum[]
  }

  /**
   * CabinetSizeModuleSize findMany
   */
  export type CabinetSizeModuleSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter, which CabinetSizeModuleSizes to fetch.
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetSizeModuleSizes to fetch.
     */
    orderBy?: CabinetSizeModuleSizeOrderByWithRelationInput | CabinetSizeModuleSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetSizeModuleSizes.
     */
    cursor?: CabinetSizeModuleSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetSizeModuleSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetSizeModuleSizes.
     */
    skip?: number
    distinct?: CabinetSizeModuleSizeScalarFieldEnum | CabinetSizeModuleSizeScalarFieldEnum[]
  }

  /**
   * CabinetSizeModuleSize create
   */
  export type CabinetSizeModuleSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetSizeModuleSize.
     */
    data: XOR<CabinetSizeModuleSizeCreateInput, CabinetSizeModuleSizeUncheckedCreateInput>
  }

  /**
   * CabinetSizeModuleSize createMany
   */
  export type CabinetSizeModuleSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetSizeModuleSizes.
     */
    data: CabinetSizeModuleSizeCreateManyInput | CabinetSizeModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CabinetSizeModuleSize createManyAndReturn
   */
  export type CabinetSizeModuleSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetSizeModuleSizes.
     */
    data: CabinetSizeModuleSizeCreateManyInput | CabinetSizeModuleSizeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSizeModuleSize update
   */
  export type CabinetSizeModuleSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetSizeModuleSize.
     */
    data: XOR<CabinetSizeModuleSizeUpdateInput, CabinetSizeModuleSizeUncheckedUpdateInput>
    /**
     * Choose, which CabinetSizeModuleSize to update.
     */
    where: CabinetSizeModuleSizeWhereUniqueInput
  }

  /**
   * CabinetSizeModuleSize updateMany
   */
  export type CabinetSizeModuleSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetSizeModuleSizes.
     */
    data: XOR<CabinetSizeModuleSizeUpdateManyMutationInput, CabinetSizeModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSizeModuleSizes to update
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * Limit how many CabinetSizeModuleSizes to update.
     */
    limit?: number
  }

  /**
   * CabinetSizeModuleSize updateManyAndReturn
   */
  export type CabinetSizeModuleSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * The data used to update CabinetSizeModuleSizes.
     */
    data: XOR<CabinetSizeModuleSizeUpdateManyMutationInput, CabinetSizeModuleSizeUncheckedUpdateManyInput>
    /**
     * Filter which CabinetSizeModuleSizes to update
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * Limit how many CabinetSizeModuleSizes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetSizeModuleSize upsert
   */
  export type CabinetSizeModuleSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetSizeModuleSize to update in case it exists.
     */
    where: CabinetSizeModuleSizeWhereUniqueInput
    /**
     * In case the CabinetSizeModuleSize found by the `where` argument doesn't exist, create a new CabinetSizeModuleSize with this data.
     */
    create: XOR<CabinetSizeModuleSizeCreateInput, CabinetSizeModuleSizeUncheckedCreateInput>
    /**
     * In case the CabinetSizeModuleSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetSizeModuleSizeUpdateInput, CabinetSizeModuleSizeUncheckedUpdateInput>
  }

  /**
   * CabinetSizeModuleSize delete
   */
  export type CabinetSizeModuleSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
    /**
     * Filter which CabinetSizeModuleSize to delete.
     */
    where: CabinetSizeModuleSizeWhereUniqueInput
  }

  /**
   * CabinetSizeModuleSize deleteMany
   */
  export type CabinetSizeModuleSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetSizeModuleSizes to delete
     */
    where?: CabinetSizeModuleSizeWhereInput
    /**
     * Limit how many CabinetSizeModuleSizes to delete.
     */
    limit?: number
  }

  /**
   * CabinetSizeModuleSize without action
   */
  export type CabinetSizeModuleSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetSizeModuleSize
     */
    select?: CabinetSizeModuleSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetSizeModuleSize
     */
    omit?: CabinetSizeModuleSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetSizeModuleSizeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    name: 'name'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ScreenTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScreenTypeScalarFieldEnum = (typeof ScreenTypeScalarFieldEnum)[keyof typeof ScreenTypeScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PlacementScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlacementScalarFieldEnum = (typeof PlacementScalarFieldEnum)[keyof typeof PlacementScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const SensorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SensorScalarFieldEnum = (typeof SensorScalarFieldEnum)[keyof typeof SensorScalarFieldEnum]


  export const ControlTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ControlTypeScalarFieldEnum = (typeof ControlTypeScalarFieldEnum)[keyof typeof ControlTypeScalarFieldEnum]


  export const PitchScalarFieldEnum: {
    id: 'id',
    code: 'code',
    pitchValue: 'pitchValue',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PitchScalarFieldEnum = (typeof PitchScalarFieldEnum)[keyof typeof PitchScalarFieldEnum]


  export const RefreshRateScalarFieldEnum: {
    id: 'id',
    code: 'code',
    value: 'value',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshRateScalarFieldEnum = (typeof RefreshRateScalarFieldEnum)[keyof typeof RefreshRateScalarFieldEnum]


  export const BrightnessScalarFieldEnum: {
    id: 'id',
    code: 'code',
    value: 'value',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrightnessScalarFieldEnum = (typeof BrightnessScalarFieldEnum)[keyof typeof BrightnessScalarFieldEnum]


  export const ManufacturerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManufacturerScalarFieldEnum = (typeof ManufacturerScalarFieldEnum)[keyof typeof ManufacturerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const IpProtectionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    protectionSolid: 'protectionSolid',
    protectionWater: 'protectionWater',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IpProtectionScalarFieldEnum = (typeof IpProtectionScalarFieldEnum)[keyof typeof IpProtectionScalarFieldEnum]


  export const ModuleSizeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    size: 'size',
    width: 'width',
    height: 'height',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleSizeScalarFieldEnum = (typeof ModuleSizeScalarFieldEnum)[keyof typeof ModuleSizeScalarFieldEnum]


  export const CabinetSizeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    size: 'size',
    width: 'width',
    height: 'height',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CabinetSizeScalarFieldEnum = (typeof CabinetSizeScalarFieldEnum)[keyof typeof CabinetSizeScalarFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const ItemSubcategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemSubcategoryScalarFieldEnum = (typeof ItemSubcategoryScalarFieldEnum)[keyof typeof ItemSubcategoryScalarFieldEnum]


  export const CabinetScalarFieldEnum: {
    id: 'id',
    code: 'code',
    sku: 'sku',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CabinetScalarFieldEnum = (typeof CabinetScalarFieldEnum)[keyof typeof CabinetScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    sku: 'sku',
    name: 'name',
    moduleOption: 'moduleOption',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    sku: 'sku',
    name: 'name',
    active: 'active',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ScreenTypeOptionScalarFieldEnum: {
    screenTypeCode: 'screenTypeCode',
    optionCode: 'optionCode'
  };

  export type ScreenTypeOptionScalarFieldEnum = (typeof ScreenTypeOptionScalarFieldEnum)[keyof typeof ScreenTypeOptionScalarFieldEnum]


  export const ScreenTypeControlTypeScalarFieldEnum: {
    screenTypeCode: 'screenTypeCode',
    controlTypeCode: 'controlTypeCode'
  };

  export type ScreenTypeControlTypeScalarFieldEnum = (typeof ScreenTypeControlTypeScalarFieldEnum)[keyof typeof ScreenTypeControlTypeScalarFieldEnum]


  export const ScreenTypeSensorScalarFieldEnum: {
    screenTypeCode: 'screenTypeCode',
    sensorCode: 'sensorCode'
  };

  export type ScreenTypeSensorScalarFieldEnum = (typeof ScreenTypeSensorScalarFieldEnum)[keyof typeof ScreenTypeSensorScalarFieldEnum]


  export const ItemCategoryRelationScalarFieldEnum: {
    itemCode: 'itemCode',
    categoryCode: 'categoryCode'
  };

  export type ItemCategoryRelationScalarFieldEnum = (typeof ItemCategoryRelationScalarFieldEnum)[keyof typeof ItemCategoryRelationScalarFieldEnum]


  export const ItemSubcategoryRelationScalarFieldEnum: {
    itemCode: 'itemCode',
    subcategoryCode: 'subcategoryCode'
  };

  export type ItemSubcategoryRelationScalarFieldEnum = (typeof ItemSubcategoryRelationScalarFieldEnum)[keyof typeof ItemSubcategoryRelationScalarFieldEnum]


  export const ItemPriceScalarFieldEnum: {
    itemCode: 'itemCode',
    priceUsd: 'priceUsd',
    priceRub: 'priceRub'
  };

  export type ItemPriceScalarFieldEnum = (typeof ItemPriceScalarFieldEnum)[keyof typeof ItemPriceScalarFieldEnum]


  export const ItemSupplierScalarFieldEnum: {
    itemCode: 'itemCode',
    supplierCode: 'supplierCode'
  };

  export type ItemSupplierScalarFieldEnum = (typeof ItemSupplierScalarFieldEnum)[keyof typeof ItemSupplierScalarFieldEnum]


  export const ItemCategorySubcategoryScalarFieldEnum: {
    categoryCode: 'categoryCode',
    subcategoryCode: 'subcategoryCode'
  };

  export type ItemCategorySubcategoryScalarFieldEnum = (typeof ItemCategorySubcategoryScalarFieldEnum)[keyof typeof ItemCategorySubcategoryScalarFieldEnum]


  export const CabinetCategoryScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    categoryCode: 'categoryCode'
  };

  export type CabinetCategoryScalarFieldEnum = (typeof CabinetCategoryScalarFieldEnum)[keyof typeof CabinetCategoryScalarFieldEnum]


  export const CabinetSubcategoryScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    subcategoryCode: 'subcategoryCode'
  };

  export type CabinetSubcategoryScalarFieldEnum = (typeof CabinetSubcategoryScalarFieldEnum)[keyof typeof CabinetSubcategoryScalarFieldEnum]


  export const CabinetLocationScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    locationCode: 'locationCode'
  };

  export type CabinetLocationScalarFieldEnum = (typeof CabinetLocationScalarFieldEnum)[keyof typeof CabinetLocationScalarFieldEnum]


  export const CabinetPlacementScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    placementCode: 'placementCode'
  };

  export type CabinetPlacementScalarFieldEnum = (typeof CabinetPlacementScalarFieldEnum)[keyof typeof CabinetPlacementScalarFieldEnum]


  export const CabinetMaterialScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    materialCode: 'materialCode'
  };

  export type CabinetMaterialScalarFieldEnum = (typeof CabinetMaterialScalarFieldEnum)[keyof typeof CabinetMaterialScalarFieldEnum]


  export const CabinetCabinetSizeScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    cabinetSizeCode: 'cabinetSizeCode'
  };

  export type CabinetCabinetSizeScalarFieldEnum = (typeof CabinetCabinetSizeScalarFieldEnum)[keyof typeof CabinetCabinetSizeScalarFieldEnum]


  export const CabinetPitchScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    pitchCode: 'pitchCode'
  };

  export type CabinetPitchScalarFieldEnum = (typeof CabinetPitchScalarFieldEnum)[keyof typeof CabinetPitchScalarFieldEnum]


  export const CabinetManufacturerScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    manufacturerCode: 'manufacturerCode'
  };

  export type CabinetManufacturerScalarFieldEnum = (typeof CabinetManufacturerScalarFieldEnum)[keyof typeof CabinetManufacturerScalarFieldEnum]


  export const CabinetSupplierScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    supplierCode: 'supplierCode'
  };

  export type CabinetSupplierScalarFieldEnum = (typeof CabinetSupplierScalarFieldEnum)[keyof typeof CabinetSupplierScalarFieldEnum]


  export const CabinetItemComponentScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    itemCode: 'itemCode',
    quantity: 'quantity'
  };

  export type CabinetItemComponentScalarFieldEnum = (typeof CabinetItemComponentScalarFieldEnum)[keyof typeof CabinetItemComponentScalarFieldEnum]


  export const CabinetPriceScalarFieldEnum: {
    cabinetCode: 'cabinetCode',
    priceUsd: 'priceUsd',
    priceRub: 'priceRub'
  };

  export type CabinetPriceScalarFieldEnum = (typeof CabinetPriceScalarFieldEnum)[keyof typeof CabinetPriceScalarFieldEnum]


  export const ModuleCategoryScalarFieldEnum: {
    moduleCode: 'moduleCode',
    categoryCode: 'categoryCode'
  };

  export type ModuleCategoryScalarFieldEnum = (typeof ModuleCategoryScalarFieldEnum)[keyof typeof ModuleCategoryScalarFieldEnum]


  export const ModuleSubcategoryScalarFieldEnum: {
    moduleCode: 'moduleCode',
    subcategoryCode: 'subcategoryCode'
  };

  export type ModuleSubcategoryScalarFieldEnum = (typeof ModuleSubcategoryScalarFieldEnum)[keyof typeof ModuleSubcategoryScalarFieldEnum]


  export const ModuleLocationScalarFieldEnum: {
    moduleCode: 'moduleCode',
    locationCode: 'locationCode'
  };

  export type ModuleLocationScalarFieldEnum = (typeof ModuleLocationScalarFieldEnum)[keyof typeof ModuleLocationScalarFieldEnum]


  export const ModuleRefreshRateScalarFieldEnum: {
    moduleCode: 'moduleCode',
    refreshRateCode: 'refreshRateCode'
  };

  export type ModuleRefreshRateScalarFieldEnum = (typeof ModuleRefreshRateScalarFieldEnum)[keyof typeof ModuleRefreshRateScalarFieldEnum]


  export const ModuleBrightnessScalarFieldEnum: {
    moduleCode: 'moduleCode',
    brightnessCode: 'brightnessCode'
  };

  export type ModuleBrightnessScalarFieldEnum = (typeof ModuleBrightnessScalarFieldEnum)[keyof typeof ModuleBrightnessScalarFieldEnum]


  export const ModuleModuleSizeScalarFieldEnum: {
    moduleCode: 'moduleCode',
    moduleSizeCode: 'moduleSizeCode'
  };

  export type ModuleModuleSizeScalarFieldEnum = (typeof ModuleModuleSizeScalarFieldEnum)[keyof typeof ModuleModuleSizeScalarFieldEnum]


  export const ModulePitchScalarFieldEnum: {
    moduleCode: 'moduleCode',
    pitchCode: 'pitchCode'
  };

  export type ModulePitchScalarFieldEnum = (typeof ModulePitchScalarFieldEnum)[keyof typeof ModulePitchScalarFieldEnum]


  export const ModuleManufacturerScalarFieldEnum: {
    moduleCode: 'moduleCode',
    manufacturerCode: 'manufacturerCode'
  };

  export type ModuleManufacturerScalarFieldEnum = (typeof ModuleManufacturerScalarFieldEnum)[keyof typeof ModuleManufacturerScalarFieldEnum]


  export const ModuleItemComponentScalarFieldEnum: {
    moduleCode: 'moduleCode',
    itemCode: 'itemCode',
    quantity: 'quantity'
  };

  export type ModuleItemComponentScalarFieldEnum = (typeof ModuleItemComponentScalarFieldEnum)[keyof typeof ModuleItemComponentScalarFieldEnum]


  export const ModuleOptionScalarFieldEnum: {
    moduleCode: 'moduleCode',
    optionCode: 'optionCode'
  };

  export type ModuleOptionScalarFieldEnum = (typeof ModuleOptionScalarFieldEnum)[keyof typeof ModuleOptionScalarFieldEnum]


  export const ModulePriceScalarFieldEnum: {
    moduleCode: 'moduleCode',
    priceUsd: 'priceUsd',
    priceRub: 'priceRub'
  };

  export type ModulePriceScalarFieldEnum = (typeof ModulePriceScalarFieldEnum)[keyof typeof ModulePriceScalarFieldEnum]


  export const CabinetSizeModuleSizeScalarFieldEnum: {
    cabinetSizeCode: 'cabinetSizeCode',
    moduleSizeCode: 'moduleSizeCode'
  };

  export type CabinetSizeModuleSizeScalarFieldEnum = (typeof CabinetSizeModuleSizeScalarFieldEnum)[keyof typeof CabinetSizeModuleSizeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringWithAggregatesFilter<"User"> | string
  }

  export type ScreenTypeWhereInput = {
    AND?: ScreenTypeWhereInput | ScreenTypeWhereInput[]
    OR?: ScreenTypeWhereInput[]
    NOT?: ScreenTypeWhereInput | ScreenTypeWhereInput[]
    id?: IntFilter<"ScreenType"> | number
    code?: StringFilter<"ScreenType"> | string
    name?: StringFilter<"ScreenType"> | string
    active?: BoolFilter<"ScreenType"> | boolean
    createdAt?: DateTimeFilter<"ScreenType"> | Date | string
    updatedAt?: DateTimeFilter<"ScreenType"> | Date | string
    options?: ScreenTypeOptionListRelationFilter
    controlTypes?: ScreenTypeControlTypeListRelationFilter
    sensors?: ScreenTypeSensorListRelationFilter
  }

  export type ScreenTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    options?: ScreenTypeOptionOrderByRelationAggregateInput
    controlTypes?: ScreenTypeControlTypeOrderByRelationAggregateInput
    sensors?: ScreenTypeSensorOrderByRelationAggregateInput
  }

  export type ScreenTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ScreenTypeWhereInput | ScreenTypeWhereInput[]
    OR?: ScreenTypeWhereInput[]
    NOT?: ScreenTypeWhereInput | ScreenTypeWhereInput[]
    name?: StringFilter<"ScreenType"> | string
    active?: BoolFilter<"ScreenType"> | boolean
    createdAt?: DateTimeFilter<"ScreenType"> | Date | string
    updatedAt?: DateTimeFilter<"ScreenType"> | Date | string
    options?: ScreenTypeOptionListRelationFilter
    controlTypes?: ScreenTypeControlTypeListRelationFilter
    sensors?: ScreenTypeSensorListRelationFilter
  }, "id" | "code">

  export type ScreenTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScreenTypeCountOrderByAggregateInput
    _avg?: ScreenTypeAvgOrderByAggregateInput
    _max?: ScreenTypeMaxOrderByAggregateInput
    _min?: ScreenTypeMinOrderByAggregateInput
    _sum?: ScreenTypeSumOrderByAggregateInput
  }

  export type ScreenTypeScalarWhereWithAggregatesInput = {
    AND?: ScreenTypeScalarWhereWithAggregatesInput | ScreenTypeScalarWhereWithAggregatesInput[]
    OR?: ScreenTypeScalarWhereWithAggregatesInput[]
    NOT?: ScreenTypeScalarWhereWithAggregatesInput | ScreenTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScreenType"> | number
    code?: StringWithAggregatesFilter<"ScreenType"> | string
    name?: StringWithAggregatesFilter<"ScreenType"> | string
    active?: BoolWithAggregatesFilter<"ScreenType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ScreenType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScreenType"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    code?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    active?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    cabinets?: CabinetMaterialListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetMaterialOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    active?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    cabinets?: CabinetMaterialListRelationFilter
  }, "id" | "code">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    code?: StringWithAggregatesFilter<"Material"> | string
    name?: StringWithAggregatesFilter<"Material"> | string
    active?: BoolWithAggregatesFilter<"Material"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    active?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    cabinets?: CabinetLocationListRelationFilter
    modules?: ModuleLocationListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetLocationOrderByRelationAggregateInput
    modules?: ModuleLocationOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    active?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    cabinets?: CabinetLocationListRelationFilter
    modules?: ModuleLocationListRelationFilter
  }, "id" | "code">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    code?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    active?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type PlacementWhereInput = {
    AND?: PlacementWhereInput | PlacementWhereInput[]
    OR?: PlacementWhereInput[]
    NOT?: PlacementWhereInput | PlacementWhereInput[]
    id?: IntFilter<"Placement"> | number
    code?: StringFilter<"Placement"> | string
    name?: StringFilter<"Placement"> | string
    active?: BoolFilter<"Placement"> | boolean
    createdAt?: DateTimeFilter<"Placement"> | Date | string
    updatedAt?: DateTimeFilter<"Placement"> | Date | string
    cabinets?: CabinetPlacementListRelationFilter
  }

  export type PlacementOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetPlacementOrderByRelationAggregateInput
  }

  export type PlacementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PlacementWhereInput | PlacementWhereInput[]
    OR?: PlacementWhereInput[]
    NOT?: PlacementWhereInput | PlacementWhereInput[]
    name?: StringFilter<"Placement"> | string
    active?: BoolFilter<"Placement"> | boolean
    createdAt?: DateTimeFilter<"Placement"> | Date | string
    updatedAt?: DateTimeFilter<"Placement"> | Date | string
    cabinets?: CabinetPlacementListRelationFilter
  }, "id" | "code">

  export type PlacementOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlacementCountOrderByAggregateInput
    _avg?: PlacementAvgOrderByAggregateInput
    _max?: PlacementMaxOrderByAggregateInput
    _min?: PlacementMinOrderByAggregateInput
    _sum?: PlacementSumOrderByAggregateInput
  }

  export type PlacementScalarWhereWithAggregatesInput = {
    AND?: PlacementScalarWhereWithAggregatesInput | PlacementScalarWhereWithAggregatesInput[]
    OR?: PlacementScalarWhereWithAggregatesInput[]
    NOT?: PlacementScalarWhereWithAggregatesInput | PlacementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Placement"> | number
    code?: StringWithAggregatesFilter<"Placement"> | string
    name?: StringWithAggregatesFilter<"Placement"> | string
    active?: BoolWithAggregatesFilter<"Placement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Placement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Placement"> | Date | string
  }

  export type OptionWhereInput = {
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    id?: IntFilter<"Option"> | number
    code?: StringFilter<"Option"> | string
    name?: StringFilter<"Option"> | string
    active?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    screenTypes?: ScreenTypeOptionListRelationFilter
    modules?: ModuleOptionListRelationFilter
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    screenTypes?: ScreenTypeOptionOrderByRelationAggregateInput
    modules?: ModuleOptionOrderByRelationAggregateInput
  }

  export type OptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    name?: StringFilter<"Option"> | string
    active?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    screenTypes?: ScreenTypeOptionListRelationFilter
    modules?: ModuleOptionListRelationFilter
  }, "id" | "code">

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _avg?: OptionAvgOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
    _sum?: OptionSumOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    OR?: OptionScalarWhereWithAggregatesInput[]
    NOT?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Option"> | number
    code?: StringWithAggregatesFilter<"Option"> | string
    name?: StringWithAggregatesFilter<"Option"> | string
    active?: BoolWithAggregatesFilter<"Option"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
  }

  export type SensorWhereInput = {
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    id?: IntFilter<"Sensor"> | number
    code?: StringFilter<"Sensor"> | string
    name?: StringFilter<"Sensor"> | string
    active?: BoolFilter<"Sensor"> | boolean
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    screenTypes?: ScreenTypeSensorListRelationFilter
  }

  export type SensorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    screenTypes?: ScreenTypeSensorOrderByRelationAggregateInput
  }

  export type SensorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    name?: StringFilter<"Sensor"> | string
    active?: BoolFilter<"Sensor"> | boolean
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    screenTypes?: ScreenTypeSensorListRelationFilter
  }, "id" | "code">

  export type SensorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SensorCountOrderByAggregateInput
    _avg?: SensorAvgOrderByAggregateInput
    _max?: SensorMaxOrderByAggregateInput
    _min?: SensorMinOrderByAggregateInput
    _sum?: SensorSumOrderByAggregateInput
  }

  export type SensorScalarWhereWithAggregatesInput = {
    AND?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    OR?: SensorScalarWhereWithAggregatesInput[]
    NOT?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sensor"> | number
    code?: StringWithAggregatesFilter<"Sensor"> | string
    name?: StringWithAggregatesFilter<"Sensor"> | string
    active?: BoolWithAggregatesFilter<"Sensor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
  }

  export type ControlTypeWhereInput = {
    AND?: ControlTypeWhereInput | ControlTypeWhereInput[]
    OR?: ControlTypeWhereInput[]
    NOT?: ControlTypeWhereInput | ControlTypeWhereInput[]
    id?: IntFilter<"ControlType"> | number
    code?: StringFilter<"ControlType"> | string
    name?: StringFilter<"ControlType"> | string
    active?: BoolFilter<"ControlType"> | boolean
    createdAt?: DateTimeFilter<"ControlType"> | Date | string
    updatedAt?: DateTimeFilter<"ControlType"> | Date | string
    screenTypes?: ScreenTypeControlTypeListRelationFilter
  }

  export type ControlTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    screenTypes?: ScreenTypeControlTypeOrderByRelationAggregateInput
  }

  export type ControlTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ControlTypeWhereInput | ControlTypeWhereInput[]
    OR?: ControlTypeWhereInput[]
    NOT?: ControlTypeWhereInput | ControlTypeWhereInput[]
    name?: StringFilter<"ControlType"> | string
    active?: BoolFilter<"ControlType"> | boolean
    createdAt?: DateTimeFilter<"ControlType"> | Date | string
    updatedAt?: DateTimeFilter<"ControlType"> | Date | string
    screenTypes?: ScreenTypeControlTypeListRelationFilter
  }, "id" | "code">

  export type ControlTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ControlTypeCountOrderByAggregateInput
    _avg?: ControlTypeAvgOrderByAggregateInput
    _max?: ControlTypeMaxOrderByAggregateInput
    _min?: ControlTypeMinOrderByAggregateInput
    _sum?: ControlTypeSumOrderByAggregateInput
  }

  export type ControlTypeScalarWhereWithAggregatesInput = {
    AND?: ControlTypeScalarWhereWithAggregatesInput | ControlTypeScalarWhereWithAggregatesInput[]
    OR?: ControlTypeScalarWhereWithAggregatesInput[]
    NOT?: ControlTypeScalarWhereWithAggregatesInput | ControlTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ControlType"> | number
    code?: StringWithAggregatesFilter<"ControlType"> | string
    name?: StringWithAggregatesFilter<"ControlType"> | string
    active?: BoolWithAggregatesFilter<"ControlType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ControlType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ControlType"> | Date | string
  }

  export type PitchWhereInput = {
    AND?: PitchWhereInput | PitchWhereInput[]
    OR?: PitchWhereInput[]
    NOT?: PitchWhereInput | PitchWhereInput[]
    id?: IntFilter<"Pitch"> | number
    code?: StringFilter<"Pitch"> | string
    pitchValue?: DecimalFilter<"Pitch"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"Pitch"> | boolean
    createdAt?: DateTimeFilter<"Pitch"> | Date | string
    updatedAt?: DateTimeFilter<"Pitch"> | Date | string
    cabinets?: CabinetPitchListRelationFilter
    modules?: ModulePitchListRelationFilter
  }

  export type PitchOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    pitchValue?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetPitchOrderByRelationAggregateInput
    modules?: ModulePitchOrderByRelationAggregateInput
  }

  export type PitchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PitchWhereInput | PitchWhereInput[]
    OR?: PitchWhereInput[]
    NOT?: PitchWhereInput | PitchWhereInput[]
    pitchValue?: DecimalFilter<"Pitch"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"Pitch"> | boolean
    createdAt?: DateTimeFilter<"Pitch"> | Date | string
    updatedAt?: DateTimeFilter<"Pitch"> | Date | string
    cabinets?: CabinetPitchListRelationFilter
    modules?: ModulePitchListRelationFilter
  }, "id" | "code">

  export type PitchOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    pitchValue?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PitchCountOrderByAggregateInput
    _avg?: PitchAvgOrderByAggregateInput
    _max?: PitchMaxOrderByAggregateInput
    _min?: PitchMinOrderByAggregateInput
    _sum?: PitchSumOrderByAggregateInput
  }

  export type PitchScalarWhereWithAggregatesInput = {
    AND?: PitchScalarWhereWithAggregatesInput | PitchScalarWhereWithAggregatesInput[]
    OR?: PitchScalarWhereWithAggregatesInput[]
    NOT?: PitchScalarWhereWithAggregatesInput | PitchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pitch"> | number
    code?: StringWithAggregatesFilter<"Pitch"> | string
    pitchValue?: DecimalWithAggregatesFilter<"Pitch"> | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter<"Pitch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Pitch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pitch"> | Date | string
  }

  export type RefreshRateWhereInput = {
    AND?: RefreshRateWhereInput | RefreshRateWhereInput[]
    OR?: RefreshRateWhereInput[]
    NOT?: RefreshRateWhereInput | RefreshRateWhereInput[]
    id?: IntFilter<"RefreshRate"> | number
    code?: StringFilter<"RefreshRate"> | string
    value?: IntFilter<"RefreshRate"> | number
    active?: BoolFilter<"RefreshRate"> | boolean
    createdAt?: DateTimeFilter<"RefreshRate"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshRate"> | Date | string
    modules?: ModuleRefreshRateListRelationFilter
  }

  export type RefreshRateOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleRefreshRateOrderByRelationAggregateInput
  }

  export type RefreshRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: RefreshRateWhereInput | RefreshRateWhereInput[]
    OR?: RefreshRateWhereInput[]
    NOT?: RefreshRateWhereInput | RefreshRateWhereInput[]
    value?: IntFilter<"RefreshRate"> | number
    active?: BoolFilter<"RefreshRate"> | boolean
    createdAt?: DateTimeFilter<"RefreshRate"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshRate"> | Date | string
    modules?: ModuleRefreshRateListRelationFilter
  }, "id" | "code">

  export type RefreshRateOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshRateCountOrderByAggregateInput
    _avg?: RefreshRateAvgOrderByAggregateInput
    _max?: RefreshRateMaxOrderByAggregateInput
    _min?: RefreshRateMinOrderByAggregateInput
    _sum?: RefreshRateSumOrderByAggregateInput
  }

  export type RefreshRateScalarWhereWithAggregatesInput = {
    AND?: RefreshRateScalarWhereWithAggregatesInput | RefreshRateScalarWhereWithAggregatesInput[]
    OR?: RefreshRateScalarWhereWithAggregatesInput[]
    NOT?: RefreshRateScalarWhereWithAggregatesInput | RefreshRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshRate"> | number
    code?: StringWithAggregatesFilter<"RefreshRate"> | string
    value?: IntWithAggregatesFilter<"RefreshRate"> | number
    active?: BoolWithAggregatesFilter<"RefreshRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshRate"> | Date | string
  }

  export type BrightnessWhereInput = {
    AND?: BrightnessWhereInput | BrightnessWhereInput[]
    OR?: BrightnessWhereInput[]
    NOT?: BrightnessWhereInput | BrightnessWhereInput[]
    id?: IntFilter<"Brightness"> | number
    code?: StringFilter<"Brightness"> | string
    value?: IntFilter<"Brightness"> | number
    active?: BoolFilter<"Brightness"> | boolean
    createdAt?: DateTimeFilter<"Brightness"> | Date | string
    updatedAt?: DateTimeFilter<"Brightness"> | Date | string
    modules?: ModuleBrightnessListRelationFilter
  }

  export type BrightnessOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleBrightnessOrderByRelationAggregateInput
  }

  export type BrightnessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: BrightnessWhereInput | BrightnessWhereInput[]
    OR?: BrightnessWhereInput[]
    NOT?: BrightnessWhereInput | BrightnessWhereInput[]
    value?: IntFilter<"Brightness"> | number
    active?: BoolFilter<"Brightness"> | boolean
    createdAt?: DateTimeFilter<"Brightness"> | Date | string
    updatedAt?: DateTimeFilter<"Brightness"> | Date | string
    modules?: ModuleBrightnessListRelationFilter
  }, "id" | "code">

  export type BrightnessOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrightnessCountOrderByAggregateInput
    _avg?: BrightnessAvgOrderByAggregateInput
    _max?: BrightnessMaxOrderByAggregateInput
    _min?: BrightnessMinOrderByAggregateInput
    _sum?: BrightnessSumOrderByAggregateInput
  }

  export type BrightnessScalarWhereWithAggregatesInput = {
    AND?: BrightnessScalarWhereWithAggregatesInput | BrightnessScalarWhereWithAggregatesInput[]
    OR?: BrightnessScalarWhereWithAggregatesInput[]
    NOT?: BrightnessScalarWhereWithAggregatesInput | BrightnessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brightness"> | number
    code?: StringWithAggregatesFilter<"Brightness"> | string
    value?: IntWithAggregatesFilter<"Brightness"> | number
    active?: BoolWithAggregatesFilter<"Brightness"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Brightness"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brightness"> | Date | string
  }

  export type ManufacturerWhereInput = {
    AND?: ManufacturerWhereInput | ManufacturerWhereInput[]
    OR?: ManufacturerWhereInput[]
    NOT?: ManufacturerWhereInput | ManufacturerWhereInput[]
    id?: IntFilter<"Manufacturer"> | number
    code?: StringFilter<"Manufacturer"> | string
    name?: StringFilter<"Manufacturer"> | string
    active?: BoolFilter<"Manufacturer"> | boolean
    createdAt?: DateTimeFilter<"Manufacturer"> | Date | string
    updatedAt?: DateTimeFilter<"Manufacturer"> | Date | string
    cabinets?: CabinetManufacturerListRelationFilter
    modules?: ModuleManufacturerListRelationFilter
  }

  export type ManufacturerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetManufacturerOrderByRelationAggregateInput
    modules?: ModuleManufacturerOrderByRelationAggregateInput
  }

  export type ManufacturerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ManufacturerWhereInput | ManufacturerWhereInput[]
    OR?: ManufacturerWhereInput[]
    NOT?: ManufacturerWhereInput | ManufacturerWhereInput[]
    name?: StringFilter<"Manufacturer"> | string
    active?: BoolFilter<"Manufacturer"> | boolean
    createdAt?: DateTimeFilter<"Manufacturer"> | Date | string
    updatedAt?: DateTimeFilter<"Manufacturer"> | Date | string
    cabinets?: CabinetManufacturerListRelationFilter
    modules?: ModuleManufacturerListRelationFilter
  }, "id" | "code">

  export type ManufacturerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManufacturerCountOrderByAggregateInput
    _avg?: ManufacturerAvgOrderByAggregateInput
    _max?: ManufacturerMaxOrderByAggregateInput
    _min?: ManufacturerMinOrderByAggregateInput
    _sum?: ManufacturerSumOrderByAggregateInput
  }

  export type ManufacturerScalarWhereWithAggregatesInput = {
    AND?: ManufacturerScalarWhereWithAggregatesInput | ManufacturerScalarWhereWithAggregatesInput[]
    OR?: ManufacturerScalarWhereWithAggregatesInput[]
    NOT?: ManufacturerScalarWhereWithAggregatesInput | ManufacturerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Manufacturer"> | number
    code?: StringWithAggregatesFilter<"Manufacturer"> | string
    name?: StringWithAggregatesFilter<"Manufacturer"> | string
    active?: BoolWithAggregatesFilter<"Manufacturer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Manufacturer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Manufacturer"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    active?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    cabinets?: CabinetSupplierListRelationFilter
    items?: ItemSupplierListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetSupplierOrderByRelationAggregateInput
    items?: ItemSupplierOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    active?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    cabinets?: CabinetSupplierListRelationFilter
    items?: ItemSupplierListRelationFilter
  }, "id" | "code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    code?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    active?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type IpProtectionWhereInput = {
    AND?: IpProtectionWhereInput | IpProtectionWhereInput[]
    OR?: IpProtectionWhereInput[]
    NOT?: IpProtectionWhereInput | IpProtectionWhereInput[]
    id?: IntFilter<"IpProtection"> | number
    code?: StringFilter<"IpProtection"> | string
    protectionSolid?: StringFilter<"IpProtection"> | string
    protectionWater?: StringFilter<"IpProtection"> | string
    active?: BoolFilter<"IpProtection"> | boolean
    createdAt?: DateTimeFilter<"IpProtection"> | Date | string
    updatedAt?: DateTimeFilter<"IpProtection"> | Date | string
  }

  export type IpProtectionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    protectionSolid?: SortOrder
    protectionWater?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IpProtectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: IpProtectionWhereInput | IpProtectionWhereInput[]
    OR?: IpProtectionWhereInput[]
    NOT?: IpProtectionWhereInput | IpProtectionWhereInput[]
    protectionSolid?: StringFilter<"IpProtection"> | string
    protectionWater?: StringFilter<"IpProtection"> | string
    active?: BoolFilter<"IpProtection"> | boolean
    createdAt?: DateTimeFilter<"IpProtection"> | Date | string
    updatedAt?: DateTimeFilter<"IpProtection"> | Date | string
  }, "id" | "code">

  export type IpProtectionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    protectionSolid?: SortOrder
    protectionWater?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IpProtectionCountOrderByAggregateInput
    _avg?: IpProtectionAvgOrderByAggregateInput
    _max?: IpProtectionMaxOrderByAggregateInput
    _min?: IpProtectionMinOrderByAggregateInput
    _sum?: IpProtectionSumOrderByAggregateInput
  }

  export type IpProtectionScalarWhereWithAggregatesInput = {
    AND?: IpProtectionScalarWhereWithAggregatesInput | IpProtectionScalarWhereWithAggregatesInput[]
    OR?: IpProtectionScalarWhereWithAggregatesInput[]
    NOT?: IpProtectionScalarWhereWithAggregatesInput | IpProtectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IpProtection"> | number
    code?: StringWithAggregatesFilter<"IpProtection"> | string
    protectionSolid?: StringWithAggregatesFilter<"IpProtection"> | string
    protectionWater?: StringWithAggregatesFilter<"IpProtection"> | string
    active?: BoolWithAggregatesFilter<"IpProtection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IpProtection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IpProtection"> | Date | string
  }

  export type ModuleSizeWhereInput = {
    AND?: ModuleSizeWhereInput | ModuleSizeWhereInput[]
    OR?: ModuleSizeWhereInput[]
    NOT?: ModuleSizeWhereInput | ModuleSizeWhereInput[]
    id?: IntFilter<"ModuleSize"> | number
    code?: StringFilter<"ModuleSize"> | string
    size?: StringFilter<"ModuleSize"> | string
    width?: IntFilter<"ModuleSize"> | number
    height?: IntFilter<"ModuleSize"> | number
    active?: BoolFilter<"ModuleSize"> | boolean
    createdAt?: DateTimeFilter<"ModuleSize"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleSize"> | Date | string
    modules?: ModuleModuleSizeListRelationFilter
    cabinetSizes?: CabinetSizeModuleSizeListRelationFilter
  }

  export type ModuleSizeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleModuleSizeOrderByRelationAggregateInput
    cabinetSizes?: CabinetSizeModuleSizeOrderByRelationAggregateInput
  }

  export type ModuleSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ModuleSizeWhereInput | ModuleSizeWhereInput[]
    OR?: ModuleSizeWhereInput[]
    NOT?: ModuleSizeWhereInput | ModuleSizeWhereInput[]
    size?: StringFilter<"ModuleSize"> | string
    width?: IntFilter<"ModuleSize"> | number
    height?: IntFilter<"ModuleSize"> | number
    active?: BoolFilter<"ModuleSize"> | boolean
    createdAt?: DateTimeFilter<"ModuleSize"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleSize"> | Date | string
    modules?: ModuleModuleSizeListRelationFilter
    cabinetSizes?: CabinetSizeModuleSizeListRelationFilter
  }, "id" | "code">

  export type ModuleSizeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleSizeCountOrderByAggregateInput
    _avg?: ModuleSizeAvgOrderByAggregateInput
    _max?: ModuleSizeMaxOrderByAggregateInput
    _min?: ModuleSizeMinOrderByAggregateInput
    _sum?: ModuleSizeSumOrderByAggregateInput
  }

  export type ModuleSizeScalarWhereWithAggregatesInput = {
    AND?: ModuleSizeScalarWhereWithAggregatesInput | ModuleSizeScalarWhereWithAggregatesInput[]
    OR?: ModuleSizeScalarWhereWithAggregatesInput[]
    NOT?: ModuleSizeScalarWhereWithAggregatesInput | ModuleSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModuleSize"> | number
    code?: StringWithAggregatesFilter<"ModuleSize"> | string
    size?: StringWithAggregatesFilter<"ModuleSize"> | string
    width?: IntWithAggregatesFilter<"ModuleSize"> | number
    height?: IntWithAggregatesFilter<"ModuleSize"> | number
    active?: BoolWithAggregatesFilter<"ModuleSize"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ModuleSize"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModuleSize"> | Date | string
  }

  export type CabinetSizeWhereInput = {
    AND?: CabinetSizeWhereInput | CabinetSizeWhereInput[]
    OR?: CabinetSizeWhereInput[]
    NOT?: CabinetSizeWhereInput | CabinetSizeWhereInput[]
    id?: IntFilter<"CabinetSize"> | number
    code?: StringFilter<"CabinetSize"> | string
    size?: StringFilter<"CabinetSize"> | string
    width?: IntFilter<"CabinetSize"> | number
    height?: IntFilter<"CabinetSize"> | number
    active?: BoolFilter<"CabinetSize"> | boolean
    createdAt?: DateTimeFilter<"CabinetSize"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetSize"> | Date | string
    cabinets?: CabinetCabinetSizeListRelationFilter
    moduleSizes?: CabinetSizeModuleSizeListRelationFilter
  }

  export type CabinetSizeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cabinets?: CabinetCabinetSizeOrderByRelationAggregateInput
    moduleSizes?: CabinetSizeModuleSizeOrderByRelationAggregateInput
  }

  export type CabinetSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CabinetSizeWhereInput | CabinetSizeWhereInput[]
    OR?: CabinetSizeWhereInput[]
    NOT?: CabinetSizeWhereInput | CabinetSizeWhereInput[]
    size?: StringFilter<"CabinetSize"> | string
    width?: IntFilter<"CabinetSize"> | number
    height?: IntFilter<"CabinetSize"> | number
    active?: BoolFilter<"CabinetSize"> | boolean
    createdAt?: DateTimeFilter<"CabinetSize"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetSize"> | Date | string
    cabinets?: CabinetCabinetSizeListRelationFilter
    moduleSizes?: CabinetSizeModuleSizeListRelationFilter
  }, "id" | "code">

  export type CabinetSizeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CabinetSizeCountOrderByAggregateInput
    _avg?: CabinetSizeAvgOrderByAggregateInput
    _max?: CabinetSizeMaxOrderByAggregateInput
    _min?: CabinetSizeMinOrderByAggregateInput
    _sum?: CabinetSizeSumOrderByAggregateInput
  }

  export type CabinetSizeScalarWhereWithAggregatesInput = {
    AND?: CabinetSizeScalarWhereWithAggregatesInput | CabinetSizeScalarWhereWithAggregatesInput[]
    OR?: CabinetSizeScalarWhereWithAggregatesInput[]
    NOT?: CabinetSizeScalarWhereWithAggregatesInput | CabinetSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CabinetSize"> | number
    code?: StringWithAggregatesFilter<"CabinetSize"> | string
    size?: StringWithAggregatesFilter<"CabinetSize"> | string
    width?: IntWithAggregatesFilter<"CabinetSize"> | number
    height?: IntWithAggregatesFilter<"CabinetSize"> | number
    active?: BoolWithAggregatesFilter<"CabinetSize"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CabinetSize"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CabinetSize"> | Date | string
  }

  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    code?: StringFilter<"ItemCategory"> | string
    name?: StringFilter<"ItemCategory"> | string
    active?: BoolFilter<"ItemCategory"> | boolean
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    subcategories?: ItemCategorySubcategoryListRelationFilter
    items?: ItemCategoryRelationListRelationFilter
    cabinets?: CabinetCategoryListRelationFilter
    modules?: ModuleCategoryListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subcategories?: ItemCategorySubcategoryOrderByRelationAggregateInput
    items?: ItemCategoryRelationOrderByRelationAggregateInput
    cabinets?: CabinetCategoryOrderByRelationAggregateInput
    modules?: ModuleCategoryOrderByRelationAggregateInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    name?: StringFilter<"ItemCategory"> | string
    active?: BoolFilter<"ItemCategory"> | boolean
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    subcategories?: ItemCategorySubcategoryListRelationFilter
    items?: ItemCategoryRelationListRelationFilter
    cabinets?: CabinetCategoryListRelationFilter
    modules?: ModuleCategoryListRelationFilter
  }, "id" | "code">

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemCategory"> | number
    code?: StringWithAggregatesFilter<"ItemCategory"> | string
    name?: StringWithAggregatesFilter<"ItemCategory"> | string
    active?: BoolWithAggregatesFilter<"ItemCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
  }

  export type ItemSubcategoryWhereInput = {
    AND?: ItemSubcategoryWhereInput | ItemSubcategoryWhereInput[]
    OR?: ItemSubcategoryWhereInput[]
    NOT?: ItemSubcategoryWhereInput | ItemSubcategoryWhereInput[]
    id?: IntFilter<"ItemSubcategory"> | number
    code?: StringFilter<"ItemSubcategory"> | string
    name?: StringFilter<"ItemSubcategory"> | string
    active?: BoolFilter<"ItemSubcategory"> | boolean
    createdAt?: DateTimeFilter<"ItemSubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemSubcategory"> | Date | string
    categories?: ItemCategorySubcategoryListRelationFilter
    items?: ItemSubcategoryRelationListRelationFilter
    cabinets?: CabinetSubcategoryListRelationFilter
    modules?: ModuleSubcategoryListRelationFilter
  }

  export type ItemSubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: ItemCategorySubcategoryOrderByRelationAggregateInput
    items?: ItemSubcategoryRelationOrderByRelationAggregateInput
    cabinets?: CabinetSubcategoryOrderByRelationAggregateInput
    modules?: ModuleSubcategoryOrderByRelationAggregateInput
  }

  export type ItemSubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ItemSubcategoryWhereInput | ItemSubcategoryWhereInput[]
    OR?: ItemSubcategoryWhereInput[]
    NOT?: ItemSubcategoryWhereInput | ItemSubcategoryWhereInput[]
    name?: StringFilter<"ItemSubcategory"> | string
    active?: BoolFilter<"ItemSubcategory"> | boolean
    createdAt?: DateTimeFilter<"ItemSubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemSubcategory"> | Date | string
    categories?: ItemCategorySubcategoryListRelationFilter
    items?: ItemSubcategoryRelationListRelationFilter
    cabinets?: CabinetSubcategoryListRelationFilter
    modules?: ModuleSubcategoryListRelationFilter
  }, "id" | "code">

  export type ItemSubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemSubcategoryCountOrderByAggregateInput
    _avg?: ItemSubcategoryAvgOrderByAggregateInput
    _max?: ItemSubcategoryMaxOrderByAggregateInput
    _min?: ItemSubcategoryMinOrderByAggregateInput
    _sum?: ItemSubcategorySumOrderByAggregateInput
  }

  export type ItemSubcategoryScalarWhereWithAggregatesInput = {
    AND?: ItemSubcategoryScalarWhereWithAggregatesInput | ItemSubcategoryScalarWhereWithAggregatesInput[]
    OR?: ItemSubcategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemSubcategoryScalarWhereWithAggregatesInput | ItemSubcategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemSubcategory"> | number
    code?: StringWithAggregatesFilter<"ItemSubcategory"> | string
    name?: StringWithAggregatesFilter<"ItemSubcategory"> | string
    active?: BoolWithAggregatesFilter<"ItemSubcategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ItemSubcategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemSubcategory"> | Date | string
  }

  export type CabinetWhereInput = {
    AND?: CabinetWhereInput | CabinetWhereInput[]
    OR?: CabinetWhereInput[]
    NOT?: CabinetWhereInput | CabinetWhereInput[]
    id?: IntFilter<"Cabinet"> | number
    code?: StringFilter<"Cabinet"> | string
    sku?: StringNullableFilter<"Cabinet"> | string | null
    name?: StringNullableFilter<"Cabinet"> | string | null
    active?: BoolFilter<"Cabinet"> | boolean
    createdAt?: DateTimeFilter<"Cabinet"> | Date | string
    updatedAt?: DateTimeFilter<"Cabinet"> | Date | string
    categories?: CabinetCategoryListRelationFilter
    subcategories?: CabinetSubcategoryListRelationFilter
    locations?: CabinetLocationListRelationFilter
    placements?: CabinetPlacementListRelationFilter
    materials?: CabinetMaterialListRelationFilter
    sizes?: CabinetCabinetSizeListRelationFilter
    pitches?: CabinetPitchListRelationFilter
    manufacturers?: CabinetManufacturerListRelationFilter
    suppliers?: CabinetSupplierListRelationFilter
    items?: CabinetItemComponentListRelationFilter
    prices?: CabinetPriceListRelationFilter
  }

  export type CabinetOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: CabinetCategoryOrderByRelationAggregateInput
    subcategories?: CabinetSubcategoryOrderByRelationAggregateInput
    locations?: CabinetLocationOrderByRelationAggregateInput
    placements?: CabinetPlacementOrderByRelationAggregateInput
    materials?: CabinetMaterialOrderByRelationAggregateInput
    sizes?: CabinetCabinetSizeOrderByRelationAggregateInput
    pitches?: CabinetPitchOrderByRelationAggregateInput
    manufacturers?: CabinetManufacturerOrderByRelationAggregateInput
    suppliers?: CabinetSupplierOrderByRelationAggregateInput
    items?: CabinetItemComponentOrderByRelationAggregateInput
    prices?: CabinetPriceOrderByRelationAggregateInput
  }

  export type CabinetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    sku?: string
    AND?: CabinetWhereInput | CabinetWhereInput[]
    OR?: CabinetWhereInput[]
    NOT?: CabinetWhereInput | CabinetWhereInput[]
    name?: StringNullableFilter<"Cabinet"> | string | null
    active?: BoolFilter<"Cabinet"> | boolean
    createdAt?: DateTimeFilter<"Cabinet"> | Date | string
    updatedAt?: DateTimeFilter<"Cabinet"> | Date | string
    categories?: CabinetCategoryListRelationFilter
    subcategories?: CabinetSubcategoryListRelationFilter
    locations?: CabinetLocationListRelationFilter
    placements?: CabinetPlacementListRelationFilter
    materials?: CabinetMaterialListRelationFilter
    sizes?: CabinetCabinetSizeListRelationFilter
    pitches?: CabinetPitchListRelationFilter
    manufacturers?: CabinetManufacturerListRelationFilter
    suppliers?: CabinetSupplierListRelationFilter
    items?: CabinetItemComponentListRelationFilter
    prices?: CabinetPriceListRelationFilter
  }, "id" | "code" | "sku">

  export type CabinetOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CabinetCountOrderByAggregateInput
    _avg?: CabinetAvgOrderByAggregateInput
    _max?: CabinetMaxOrderByAggregateInput
    _min?: CabinetMinOrderByAggregateInput
    _sum?: CabinetSumOrderByAggregateInput
  }

  export type CabinetScalarWhereWithAggregatesInput = {
    AND?: CabinetScalarWhereWithAggregatesInput | CabinetScalarWhereWithAggregatesInput[]
    OR?: CabinetScalarWhereWithAggregatesInput[]
    NOT?: CabinetScalarWhereWithAggregatesInput | CabinetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cabinet"> | number
    code?: StringWithAggregatesFilter<"Cabinet"> | string
    sku?: StringNullableWithAggregatesFilter<"Cabinet"> | string | null
    name?: StringNullableWithAggregatesFilter<"Cabinet"> | string | null
    active?: BoolWithAggregatesFilter<"Cabinet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Cabinet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cabinet"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: IntFilter<"Module"> | number
    code?: StringFilter<"Module"> | string
    sku?: StringNullableFilter<"Module"> | string | null
    name?: StringNullableFilter<"Module"> | string | null
    moduleOption?: StringNullableFilter<"Module"> | string | null
    active?: BoolFilter<"Module"> | boolean
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    categories?: ModuleCategoryListRelationFilter
    subcategories?: ModuleSubcategoryListRelationFilter
    locations?: ModuleLocationListRelationFilter
    refreshRates?: ModuleRefreshRateListRelationFilter
    brightnesses?: ModuleBrightnessListRelationFilter
    sizes?: ModuleModuleSizeListRelationFilter
    pitches?: ModulePitchListRelationFilter
    manufacturers?: ModuleManufacturerListRelationFilter
    items?: ModuleItemComponentListRelationFilter
    options?: ModuleOptionListRelationFilter
    prices?: ModulePriceListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    moduleOption?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: ModuleCategoryOrderByRelationAggregateInput
    subcategories?: ModuleSubcategoryOrderByRelationAggregateInput
    locations?: ModuleLocationOrderByRelationAggregateInput
    refreshRates?: ModuleRefreshRateOrderByRelationAggregateInput
    brightnesses?: ModuleBrightnessOrderByRelationAggregateInput
    sizes?: ModuleModuleSizeOrderByRelationAggregateInput
    pitches?: ModulePitchOrderByRelationAggregateInput
    manufacturers?: ModuleManufacturerOrderByRelationAggregateInput
    items?: ModuleItemComponentOrderByRelationAggregateInput
    options?: ModuleOptionOrderByRelationAggregateInput
    prices?: ModulePriceOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    sku?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    name?: StringNullableFilter<"Module"> | string | null
    moduleOption?: StringNullableFilter<"Module"> | string | null
    active?: BoolFilter<"Module"> | boolean
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    categories?: ModuleCategoryListRelationFilter
    subcategories?: ModuleSubcategoryListRelationFilter
    locations?: ModuleLocationListRelationFilter
    refreshRates?: ModuleRefreshRateListRelationFilter
    brightnesses?: ModuleBrightnessListRelationFilter
    sizes?: ModuleModuleSizeListRelationFilter
    pitches?: ModulePitchListRelationFilter
    manufacturers?: ModuleManufacturerListRelationFilter
    items?: ModuleItemComponentListRelationFilter
    options?: ModuleOptionListRelationFilter
    prices?: ModulePriceListRelationFilter
  }, "id" | "code" | "sku">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    moduleOption?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Module"> | number
    code?: StringWithAggregatesFilter<"Module"> | string
    sku?: StringNullableWithAggregatesFilter<"Module"> | string | null
    name?: StringNullableWithAggregatesFilter<"Module"> | string | null
    moduleOption?: StringNullableWithAggregatesFilter<"Module"> | string | null
    active?: BoolWithAggregatesFilter<"Module"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    code?: StringFilter<"Item"> | string
    sku?: StringNullableFilter<"Item"> | string | null
    name?: StringFilter<"Item"> | string
    active?: BoolFilter<"Item"> | boolean
    comment?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    categories?: ItemCategoryRelationListRelationFilter
    subcategories?: ItemSubcategoryRelationListRelationFilter
    prices?: ItemPriceListRelationFilter
    suppliers?: ItemSupplierListRelationFilter
    cabinets?: CabinetItemComponentListRelationFilter
    modules?: ModuleItemComponentListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    active?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: ItemCategoryRelationOrderByRelationAggregateInput
    subcategories?: ItemSubcategoryRelationOrderByRelationAggregateInput
    prices?: ItemPriceOrderByRelationAggregateInput
    suppliers?: ItemSupplierOrderByRelationAggregateInput
    cabinets?: CabinetItemComponentOrderByRelationAggregateInput
    modules?: ModuleItemComponentOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    sku?: StringNullableFilter<"Item"> | string | null
    name?: StringFilter<"Item"> | string
    active?: BoolFilter<"Item"> | boolean
    comment?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    categories?: ItemCategoryRelationListRelationFilter
    subcategories?: ItemSubcategoryRelationListRelationFilter
    prices?: ItemPriceListRelationFilter
    suppliers?: ItemSupplierListRelationFilter
    cabinets?: CabinetItemComponentListRelationFilter
    modules?: ModuleItemComponentListRelationFilter
  }, "id" | "code">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    active?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    code?: StringWithAggregatesFilter<"Item"> | string
    sku?: StringNullableWithAggregatesFilter<"Item"> | string | null
    name?: StringWithAggregatesFilter<"Item"> | string
    active?: BoolWithAggregatesFilter<"Item"> | boolean
    comment?: StringNullableWithAggregatesFilter<"Item"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type ScreenTypeOptionWhereInput = {
    AND?: ScreenTypeOptionWhereInput | ScreenTypeOptionWhereInput[]
    OR?: ScreenTypeOptionWhereInput[]
    NOT?: ScreenTypeOptionWhereInput | ScreenTypeOptionWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeOption"> | string
    optionCode?: StringFilter<"ScreenTypeOption"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }

  export type ScreenTypeOptionOrderByWithRelationInput = {
    screenTypeCode?: SortOrder
    optionCode?: SortOrder
    screenType?: ScreenTypeOrderByWithRelationInput
    option?: OptionOrderByWithRelationInput
  }

  export type ScreenTypeOptionWhereUniqueInput = Prisma.AtLeast<{
    screenTypeCode_optionCode?: ScreenTypeOptionScreenTypeCodeOptionCodeCompoundUniqueInput
    AND?: ScreenTypeOptionWhereInput | ScreenTypeOptionWhereInput[]
    OR?: ScreenTypeOptionWhereInput[]
    NOT?: ScreenTypeOptionWhereInput | ScreenTypeOptionWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeOption"> | string
    optionCode?: StringFilter<"ScreenTypeOption"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }, "screenTypeCode_optionCode">

  export type ScreenTypeOptionOrderByWithAggregationInput = {
    screenTypeCode?: SortOrder
    optionCode?: SortOrder
    _count?: ScreenTypeOptionCountOrderByAggregateInput
    _max?: ScreenTypeOptionMaxOrderByAggregateInput
    _min?: ScreenTypeOptionMinOrderByAggregateInput
  }

  export type ScreenTypeOptionScalarWhereWithAggregatesInput = {
    AND?: ScreenTypeOptionScalarWhereWithAggregatesInput | ScreenTypeOptionScalarWhereWithAggregatesInput[]
    OR?: ScreenTypeOptionScalarWhereWithAggregatesInput[]
    NOT?: ScreenTypeOptionScalarWhereWithAggregatesInput | ScreenTypeOptionScalarWhereWithAggregatesInput[]
    screenTypeCode?: StringWithAggregatesFilter<"ScreenTypeOption"> | string
    optionCode?: StringWithAggregatesFilter<"ScreenTypeOption"> | string
  }

  export type ScreenTypeControlTypeWhereInput = {
    AND?: ScreenTypeControlTypeWhereInput | ScreenTypeControlTypeWhereInput[]
    OR?: ScreenTypeControlTypeWhereInput[]
    NOT?: ScreenTypeControlTypeWhereInput | ScreenTypeControlTypeWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeControlType"> | string
    controlTypeCode?: StringFilter<"ScreenTypeControlType"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    controlType?: XOR<ControlTypeScalarRelationFilter, ControlTypeWhereInput>
  }

  export type ScreenTypeControlTypeOrderByWithRelationInput = {
    screenTypeCode?: SortOrder
    controlTypeCode?: SortOrder
    screenType?: ScreenTypeOrderByWithRelationInput
    controlType?: ControlTypeOrderByWithRelationInput
  }

  export type ScreenTypeControlTypeWhereUniqueInput = Prisma.AtLeast<{
    screenTypeCode_controlTypeCode?: ScreenTypeControlTypeScreenTypeCodeControlTypeCodeCompoundUniqueInput
    AND?: ScreenTypeControlTypeWhereInput | ScreenTypeControlTypeWhereInput[]
    OR?: ScreenTypeControlTypeWhereInput[]
    NOT?: ScreenTypeControlTypeWhereInput | ScreenTypeControlTypeWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeControlType"> | string
    controlTypeCode?: StringFilter<"ScreenTypeControlType"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    controlType?: XOR<ControlTypeScalarRelationFilter, ControlTypeWhereInput>
  }, "screenTypeCode_controlTypeCode">

  export type ScreenTypeControlTypeOrderByWithAggregationInput = {
    screenTypeCode?: SortOrder
    controlTypeCode?: SortOrder
    _count?: ScreenTypeControlTypeCountOrderByAggregateInput
    _max?: ScreenTypeControlTypeMaxOrderByAggregateInput
    _min?: ScreenTypeControlTypeMinOrderByAggregateInput
  }

  export type ScreenTypeControlTypeScalarWhereWithAggregatesInput = {
    AND?: ScreenTypeControlTypeScalarWhereWithAggregatesInput | ScreenTypeControlTypeScalarWhereWithAggregatesInput[]
    OR?: ScreenTypeControlTypeScalarWhereWithAggregatesInput[]
    NOT?: ScreenTypeControlTypeScalarWhereWithAggregatesInput | ScreenTypeControlTypeScalarWhereWithAggregatesInput[]
    screenTypeCode?: StringWithAggregatesFilter<"ScreenTypeControlType"> | string
    controlTypeCode?: StringWithAggregatesFilter<"ScreenTypeControlType"> | string
  }

  export type ScreenTypeSensorWhereInput = {
    AND?: ScreenTypeSensorWhereInput | ScreenTypeSensorWhereInput[]
    OR?: ScreenTypeSensorWhereInput[]
    NOT?: ScreenTypeSensorWhereInput | ScreenTypeSensorWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeSensor"> | string
    sensorCode?: StringFilter<"ScreenTypeSensor"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    sensor?: XOR<SensorScalarRelationFilter, SensorWhereInput>
  }

  export type ScreenTypeSensorOrderByWithRelationInput = {
    screenTypeCode?: SortOrder
    sensorCode?: SortOrder
    screenType?: ScreenTypeOrderByWithRelationInput
    sensor?: SensorOrderByWithRelationInput
  }

  export type ScreenTypeSensorWhereUniqueInput = Prisma.AtLeast<{
    screenTypeCode_sensorCode?: ScreenTypeSensorScreenTypeCodeSensorCodeCompoundUniqueInput
    AND?: ScreenTypeSensorWhereInput | ScreenTypeSensorWhereInput[]
    OR?: ScreenTypeSensorWhereInput[]
    NOT?: ScreenTypeSensorWhereInput | ScreenTypeSensorWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeSensor"> | string
    sensorCode?: StringFilter<"ScreenTypeSensor"> | string
    screenType?: XOR<ScreenTypeScalarRelationFilter, ScreenTypeWhereInput>
    sensor?: XOR<SensorScalarRelationFilter, SensorWhereInput>
  }, "screenTypeCode_sensorCode">

  export type ScreenTypeSensorOrderByWithAggregationInput = {
    screenTypeCode?: SortOrder
    sensorCode?: SortOrder
    _count?: ScreenTypeSensorCountOrderByAggregateInput
    _max?: ScreenTypeSensorMaxOrderByAggregateInput
    _min?: ScreenTypeSensorMinOrderByAggregateInput
  }

  export type ScreenTypeSensorScalarWhereWithAggregatesInput = {
    AND?: ScreenTypeSensorScalarWhereWithAggregatesInput | ScreenTypeSensorScalarWhereWithAggregatesInput[]
    OR?: ScreenTypeSensorScalarWhereWithAggregatesInput[]
    NOT?: ScreenTypeSensorScalarWhereWithAggregatesInput | ScreenTypeSensorScalarWhereWithAggregatesInput[]
    screenTypeCode?: StringWithAggregatesFilter<"ScreenTypeSensor"> | string
    sensorCode?: StringWithAggregatesFilter<"ScreenTypeSensor"> | string
  }

  export type ItemCategoryRelationWhereInput = {
    AND?: ItemCategoryRelationWhereInput | ItemCategoryRelationWhereInput[]
    OR?: ItemCategoryRelationWhereInput[]
    NOT?: ItemCategoryRelationWhereInput | ItemCategoryRelationWhereInput[]
    itemCode?: StringFilter<"ItemCategoryRelation"> | string
    categoryCode?: StringFilter<"ItemCategoryRelation"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }

  export type ItemCategoryRelationOrderByWithRelationInput = {
    itemCode?: SortOrder
    categoryCode?: SortOrder
    item?: ItemOrderByWithRelationInput
    category?: ItemCategoryOrderByWithRelationInput
  }

  export type ItemCategoryRelationWhereUniqueInput = Prisma.AtLeast<{
    itemCode_categoryCode?: ItemCategoryRelationItemCodeCategoryCodeCompoundUniqueInput
    AND?: ItemCategoryRelationWhereInput | ItemCategoryRelationWhereInput[]
    OR?: ItemCategoryRelationWhereInput[]
    NOT?: ItemCategoryRelationWhereInput | ItemCategoryRelationWhereInput[]
    itemCode?: StringFilter<"ItemCategoryRelation"> | string
    categoryCode?: StringFilter<"ItemCategoryRelation"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }, "itemCode_categoryCode">

  export type ItemCategoryRelationOrderByWithAggregationInput = {
    itemCode?: SortOrder
    categoryCode?: SortOrder
    _count?: ItemCategoryRelationCountOrderByAggregateInput
    _max?: ItemCategoryRelationMaxOrderByAggregateInput
    _min?: ItemCategoryRelationMinOrderByAggregateInput
  }

  export type ItemCategoryRelationScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryRelationScalarWhereWithAggregatesInput | ItemCategoryRelationScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryRelationScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryRelationScalarWhereWithAggregatesInput | ItemCategoryRelationScalarWhereWithAggregatesInput[]
    itemCode?: StringWithAggregatesFilter<"ItemCategoryRelation"> | string
    categoryCode?: StringWithAggregatesFilter<"ItemCategoryRelation"> | string
  }

  export type ItemSubcategoryRelationWhereInput = {
    AND?: ItemSubcategoryRelationWhereInput | ItemSubcategoryRelationWhereInput[]
    OR?: ItemSubcategoryRelationWhereInput[]
    NOT?: ItemSubcategoryRelationWhereInput | ItemSubcategoryRelationWhereInput[]
    itemCode?: StringFilter<"ItemSubcategoryRelation"> | string
    subcategoryCode?: StringFilter<"ItemSubcategoryRelation"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }

  export type ItemSubcategoryRelationOrderByWithRelationInput = {
    itemCode?: SortOrder
    subcategoryCode?: SortOrder
    item?: ItemOrderByWithRelationInput
    subcategory?: ItemSubcategoryOrderByWithRelationInput
  }

  export type ItemSubcategoryRelationWhereUniqueInput = Prisma.AtLeast<{
    itemCode_subcategoryCode?: ItemSubcategoryRelationItemCodeSubcategoryCodeCompoundUniqueInput
    AND?: ItemSubcategoryRelationWhereInput | ItemSubcategoryRelationWhereInput[]
    OR?: ItemSubcategoryRelationWhereInput[]
    NOT?: ItemSubcategoryRelationWhereInput | ItemSubcategoryRelationWhereInput[]
    itemCode?: StringFilter<"ItemSubcategoryRelation"> | string
    subcategoryCode?: StringFilter<"ItemSubcategoryRelation"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }, "itemCode_subcategoryCode">

  export type ItemSubcategoryRelationOrderByWithAggregationInput = {
    itemCode?: SortOrder
    subcategoryCode?: SortOrder
    _count?: ItemSubcategoryRelationCountOrderByAggregateInput
    _max?: ItemSubcategoryRelationMaxOrderByAggregateInput
    _min?: ItemSubcategoryRelationMinOrderByAggregateInput
  }

  export type ItemSubcategoryRelationScalarWhereWithAggregatesInput = {
    AND?: ItemSubcategoryRelationScalarWhereWithAggregatesInput | ItemSubcategoryRelationScalarWhereWithAggregatesInput[]
    OR?: ItemSubcategoryRelationScalarWhereWithAggregatesInput[]
    NOT?: ItemSubcategoryRelationScalarWhereWithAggregatesInput | ItemSubcategoryRelationScalarWhereWithAggregatesInput[]
    itemCode?: StringWithAggregatesFilter<"ItemSubcategoryRelation"> | string
    subcategoryCode?: StringWithAggregatesFilter<"ItemSubcategoryRelation"> | string
  }

  export type ItemPriceWhereInput = {
    AND?: ItemPriceWhereInput | ItemPriceWhereInput[]
    OR?: ItemPriceWhereInput[]
    NOT?: ItemPriceWhereInput | ItemPriceWhereInput[]
    itemCode?: StringFilter<"ItemPrice"> | string
    priceUsd?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemPriceOrderByWithRelationInput = {
    itemCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
  }

  export type ItemPriceWhereUniqueInput = Prisma.AtLeast<{
    itemCode?: string
    AND?: ItemPriceWhereInput | ItemPriceWhereInput[]
    OR?: ItemPriceWhereInput[]
    NOT?: ItemPriceWhereInput | ItemPriceWhereInput[]
    priceUsd?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "itemCode">

  export type ItemPriceOrderByWithAggregationInput = {
    itemCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    _count?: ItemPriceCountOrderByAggregateInput
    _avg?: ItemPriceAvgOrderByAggregateInput
    _max?: ItemPriceMaxOrderByAggregateInput
    _min?: ItemPriceMinOrderByAggregateInput
    _sum?: ItemPriceSumOrderByAggregateInput
  }

  export type ItemPriceScalarWhereWithAggregatesInput = {
    AND?: ItemPriceScalarWhereWithAggregatesInput | ItemPriceScalarWhereWithAggregatesInput[]
    OR?: ItemPriceScalarWhereWithAggregatesInput[]
    NOT?: ItemPriceScalarWhereWithAggregatesInput | ItemPriceScalarWhereWithAggregatesInput[]
    itemCode?: StringWithAggregatesFilter<"ItemPrice"> | string
    priceUsd?: DecimalNullableWithAggregatesFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableWithAggregatesFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemSupplierWhereInput = {
    AND?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    OR?: ItemSupplierWhereInput[]
    NOT?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    itemCode?: StringFilter<"ItemSupplier"> | string
    supplierCode?: StringFilter<"ItemSupplier"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type ItemSupplierOrderByWithRelationInput = {
    itemCode?: SortOrder
    supplierCode?: SortOrder
    item?: ItemOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type ItemSupplierWhereUniqueInput = Prisma.AtLeast<{
    itemCode_supplierCode?: ItemSupplierItemCodeSupplierCodeCompoundUniqueInput
    AND?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    OR?: ItemSupplierWhereInput[]
    NOT?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    itemCode?: StringFilter<"ItemSupplier"> | string
    supplierCode?: StringFilter<"ItemSupplier"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "itemCode_supplierCode">

  export type ItemSupplierOrderByWithAggregationInput = {
    itemCode?: SortOrder
    supplierCode?: SortOrder
    _count?: ItemSupplierCountOrderByAggregateInput
    _max?: ItemSupplierMaxOrderByAggregateInput
    _min?: ItemSupplierMinOrderByAggregateInput
  }

  export type ItemSupplierScalarWhereWithAggregatesInput = {
    AND?: ItemSupplierScalarWhereWithAggregatesInput | ItemSupplierScalarWhereWithAggregatesInput[]
    OR?: ItemSupplierScalarWhereWithAggregatesInput[]
    NOT?: ItemSupplierScalarWhereWithAggregatesInput | ItemSupplierScalarWhereWithAggregatesInput[]
    itemCode?: StringWithAggregatesFilter<"ItemSupplier"> | string
    supplierCode?: StringWithAggregatesFilter<"ItemSupplier"> | string
  }

  export type ItemCategorySubcategoryWhereInput = {
    AND?: ItemCategorySubcategoryWhereInput | ItemCategorySubcategoryWhereInput[]
    OR?: ItemCategorySubcategoryWhereInput[]
    NOT?: ItemCategorySubcategoryWhereInput | ItemCategorySubcategoryWhereInput[]
    categoryCode?: StringFilter<"ItemCategorySubcategory"> | string
    subcategoryCode?: StringFilter<"ItemCategorySubcategory"> | string
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }

  export type ItemCategorySubcategoryOrderByWithRelationInput = {
    categoryCode?: SortOrder
    subcategoryCode?: SortOrder
    category?: ItemCategoryOrderByWithRelationInput
    subcategory?: ItemSubcategoryOrderByWithRelationInput
  }

  export type ItemCategorySubcategoryWhereUniqueInput = Prisma.AtLeast<{
    categoryCode_subcategoryCode?: ItemCategorySubcategoryCategoryCodeSubcategoryCodeCompoundUniqueInput
    AND?: ItemCategorySubcategoryWhereInput | ItemCategorySubcategoryWhereInput[]
    OR?: ItemCategorySubcategoryWhereInput[]
    NOT?: ItemCategorySubcategoryWhereInput | ItemCategorySubcategoryWhereInput[]
    categoryCode?: StringFilter<"ItemCategorySubcategory"> | string
    subcategoryCode?: StringFilter<"ItemCategorySubcategory"> | string
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }, "categoryCode_subcategoryCode">

  export type ItemCategorySubcategoryOrderByWithAggregationInput = {
    categoryCode?: SortOrder
    subcategoryCode?: SortOrder
    _count?: ItemCategorySubcategoryCountOrderByAggregateInput
    _max?: ItemCategorySubcategoryMaxOrderByAggregateInput
    _min?: ItemCategorySubcategoryMinOrderByAggregateInput
  }

  export type ItemCategorySubcategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategorySubcategoryScalarWhereWithAggregatesInput | ItemCategorySubcategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategorySubcategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategorySubcategoryScalarWhereWithAggregatesInput | ItemCategorySubcategoryScalarWhereWithAggregatesInput[]
    categoryCode?: StringWithAggregatesFilter<"ItemCategorySubcategory"> | string
    subcategoryCode?: StringWithAggregatesFilter<"ItemCategorySubcategory"> | string
  }

  export type CabinetCategoryWhereInput = {
    AND?: CabinetCategoryWhereInput | CabinetCategoryWhereInput[]
    OR?: CabinetCategoryWhereInput[]
    NOT?: CabinetCategoryWhereInput | CabinetCategoryWhereInput[]
    cabinetCode?: StringFilter<"CabinetCategory"> | string
    categoryCode?: StringFilter<"CabinetCategory"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }

  export type CabinetCategoryOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    categoryCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    category?: ItemCategoryOrderByWithRelationInput
  }

  export type CabinetCategoryWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_categoryCode?: CabinetCategoryCabinetCodeCategoryCodeCompoundUniqueInput
    AND?: CabinetCategoryWhereInput | CabinetCategoryWhereInput[]
    OR?: CabinetCategoryWhereInput[]
    NOT?: CabinetCategoryWhereInput | CabinetCategoryWhereInput[]
    cabinetCode?: StringFilter<"CabinetCategory"> | string
    categoryCode?: StringFilter<"CabinetCategory"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }, "cabinetCode_categoryCode">

  export type CabinetCategoryOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    categoryCode?: SortOrder
    _count?: CabinetCategoryCountOrderByAggregateInput
    _max?: CabinetCategoryMaxOrderByAggregateInput
    _min?: CabinetCategoryMinOrderByAggregateInput
  }

  export type CabinetCategoryScalarWhereWithAggregatesInput = {
    AND?: CabinetCategoryScalarWhereWithAggregatesInput | CabinetCategoryScalarWhereWithAggregatesInput[]
    OR?: CabinetCategoryScalarWhereWithAggregatesInput[]
    NOT?: CabinetCategoryScalarWhereWithAggregatesInput | CabinetCategoryScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetCategory"> | string
    categoryCode?: StringWithAggregatesFilter<"CabinetCategory"> | string
  }

  export type CabinetSubcategoryWhereInput = {
    AND?: CabinetSubcategoryWhereInput | CabinetSubcategoryWhereInput[]
    OR?: CabinetSubcategoryWhereInput[]
    NOT?: CabinetSubcategoryWhereInput | CabinetSubcategoryWhereInput[]
    cabinetCode?: StringFilter<"CabinetSubcategory"> | string
    subcategoryCode?: StringFilter<"CabinetSubcategory"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }

  export type CabinetSubcategoryOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    subcategoryCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    subcategory?: ItemSubcategoryOrderByWithRelationInput
  }

  export type CabinetSubcategoryWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_subcategoryCode?: CabinetSubcategoryCabinetCodeSubcategoryCodeCompoundUniqueInput
    AND?: CabinetSubcategoryWhereInput | CabinetSubcategoryWhereInput[]
    OR?: CabinetSubcategoryWhereInput[]
    NOT?: CabinetSubcategoryWhereInput | CabinetSubcategoryWhereInput[]
    cabinetCode?: StringFilter<"CabinetSubcategory"> | string
    subcategoryCode?: StringFilter<"CabinetSubcategory"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }, "cabinetCode_subcategoryCode">

  export type CabinetSubcategoryOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    subcategoryCode?: SortOrder
    _count?: CabinetSubcategoryCountOrderByAggregateInput
    _max?: CabinetSubcategoryMaxOrderByAggregateInput
    _min?: CabinetSubcategoryMinOrderByAggregateInput
  }

  export type CabinetSubcategoryScalarWhereWithAggregatesInput = {
    AND?: CabinetSubcategoryScalarWhereWithAggregatesInput | CabinetSubcategoryScalarWhereWithAggregatesInput[]
    OR?: CabinetSubcategoryScalarWhereWithAggregatesInput[]
    NOT?: CabinetSubcategoryScalarWhereWithAggregatesInput | CabinetSubcategoryScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetSubcategory"> | string
    subcategoryCode?: StringWithAggregatesFilter<"CabinetSubcategory"> | string
  }

  export type CabinetLocationWhereInput = {
    AND?: CabinetLocationWhereInput | CabinetLocationWhereInput[]
    OR?: CabinetLocationWhereInput[]
    NOT?: CabinetLocationWhereInput | CabinetLocationWhereInput[]
    cabinetCode?: StringFilter<"CabinetLocation"> | string
    locationCode?: StringFilter<"CabinetLocation"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type CabinetLocationOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    locationCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type CabinetLocationWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_locationCode?: CabinetLocationCabinetCodeLocationCodeCompoundUniqueInput
    AND?: CabinetLocationWhereInput | CabinetLocationWhereInput[]
    OR?: CabinetLocationWhereInput[]
    NOT?: CabinetLocationWhereInput | CabinetLocationWhereInput[]
    cabinetCode?: StringFilter<"CabinetLocation"> | string
    locationCode?: StringFilter<"CabinetLocation"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "cabinetCode_locationCode">

  export type CabinetLocationOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    locationCode?: SortOrder
    _count?: CabinetLocationCountOrderByAggregateInput
    _max?: CabinetLocationMaxOrderByAggregateInput
    _min?: CabinetLocationMinOrderByAggregateInput
  }

  export type CabinetLocationScalarWhereWithAggregatesInput = {
    AND?: CabinetLocationScalarWhereWithAggregatesInput | CabinetLocationScalarWhereWithAggregatesInput[]
    OR?: CabinetLocationScalarWhereWithAggregatesInput[]
    NOT?: CabinetLocationScalarWhereWithAggregatesInput | CabinetLocationScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetLocation"> | string
    locationCode?: StringWithAggregatesFilter<"CabinetLocation"> | string
  }

  export type CabinetPlacementWhereInput = {
    AND?: CabinetPlacementWhereInput | CabinetPlacementWhereInput[]
    OR?: CabinetPlacementWhereInput[]
    NOT?: CabinetPlacementWhereInput | CabinetPlacementWhereInput[]
    cabinetCode?: StringFilter<"CabinetPlacement"> | string
    placementCode?: StringFilter<"CabinetPlacement"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    placement?: XOR<PlacementScalarRelationFilter, PlacementWhereInput>
  }

  export type CabinetPlacementOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    placementCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    placement?: PlacementOrderByWithRelationInput
  }

  export type CabinetPlacementWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_placementCode?: CabinetPlacementCabinetCodePlacementCodeCompoundUniqueInput
    AND?: CabinetPlacementWhereInput | CabinetPlacementWhereInput[]
    OR?: CabinetPlacementWhereInput[]
    NOT?: CabinetPlacementWhereInput | CabinetPlacementWhereInput[]
    cabinetCode?: StringFilter<"CabinetPlacement"> | string
    placementCode?: StringFilter<"CabinetPlacement"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    placement?: XOR<PlacementScalarRelationFilter, PlacementWhereInput>
  }, "cabinetCode_placementCode">

  export type CabinetPlacementOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    placementCode?: SortOrder
    _count?: CabinetPlacementCountOrderByAggregateInput
    _max?: CabinetPlacementMaxOrderByAggregateInput
    _min?: CabinetPlacementMinOrderByAggregateInput
  }

  export type CabinetPlacementScalarWhereWithAggregatesInput = {
    AND?: CabinetPlacementScalarWhereWithAggregatesInput | CabinetPlacementScalarWhereWithAggregatesInput[]
    OR?: CabinetPlacementScalarWhereWithAggregatesInput[]
    NOT?: CabinetPlacementScalarWhereWithAggregatesInput | CabinetPlacementScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetPlacement"> | string
    placementCode?: StringWithAggregatesFilter<"CabinetPlacement"> | string
  }

  export type CabinetMaterialWhereInput = {
    AND?: CabinetMaterialWhereInput | CabinetMaterialWhereInput[]
    OR?: CabinetMaterialWhereInput[]
    NOT?: CabinetMaterialWhereInput | CabinetMaterialWhereInput[]
    cabinetCode?: StringFilter<"CabinetMaterial"> | string
    materialCode?: StringFilter<"CabinetMaterial"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type CabinetMaterialOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    materialCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type CabinetMaterialWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_materialCode?: CabinetMaterialCabinetCodeMaterialCodeCompoundUniqueInput
    AND?: CabinetMaterialWhereInput | CabinetMaterialWhereInput[]
    OR?: CabinetMaterialWhereInput[]
    NOT?: CabinetMaterialWhereInput | CabinetMaterialWhereInput[]
    cabinetCode?: StringFilter<"CabinetMaterial"> | string
    materialCode?: StringFilter<"CabinetMaterial"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "cabinetCode_materialCode">

  export type CabinetMaterialOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    materialCode?: SortOrder
    _count?: CabinetMaterialCountOrderByAggregateInput
    _max?: CabinetMaterialMaxOrderByAggregateInput
    _min?: CabinetMaterialMinOrderByAggregateInput
  }

  export type CabinetMaterialScalarWhereWithAggregatesInput = {
    AND?: CabinetMaterialScalarWhereWithAggregatesInput | CabinetMaterialScalarWhereWithAggregatesInput[]
    OR?: CabinetMaterialScalarWhereWithAggregatesInput[]
    NOT?: CabinetMaterialScalarWhereWithAggregatesInput | CabinetMaterialScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetMaterial"> | string
    materialCode?: StringWithAggregatesFilter<"CabinetMaterial"> | string
  }

  export type CabinetCabinetSizeWhereInput = {
    AND?: CabinetCabinetSizeWhereInput | CabinetCabinetSizeWhereInput[]
    OR?: CabinetCabinetSizeWhereInput[]
    NOT?: CabinetCabinetSizeWhereInput | CabinetCabinetSizeWhereInput[]
    cabinetCode?: StringFilter<"CabinetCabinetSize"> | string
    cabinetSizeCode?: StringFilter<"CabinetCabinetSize"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    size?: XOR<CabinetSizeScalarRelationFilter, CabinetSizeWhereInput>
  }

  export type CabinetCabinetSizeOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    cabinetSizeCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    size?: CabinetSizeOrderByWithRelationInput
  }

  export type CabinetCabinetSizeWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_cabinetSizeCode?: CabinetCabinetSizeCabinetCodeCabinetSizeCodeCompoundUniqueInput
    AND?: CabinetCabinetSizeWhereInput | CabinetCabinetSizeWhereInput[]
    OR?: CabinetCabinetSizeWhereInput[]
    NOT?: CabinetCabinetSizeWhereInput | CabinetCabinetSizeWhereInput[]
    cabinetCode?: StringFilter<"CabinetCabinetSize"> | string
    cabinetSizeCode?: StringFilter<"CabinetCabinetSize"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    size?: XOR<CabinetSizeScalarRelationFilter, CabinetSizeWhereInput>
  }, "cabinetCode_cabinetSizeCode">

  export type CabinetCabinetSizeOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    cabinetSizeCode?: SortOrder
    _count?: CabinetCabinetSizeCountOrderByAggregateInput
    _max?: CabinetCabinetSizeMaxOrderByAggregateInput
    _min?: CabinetCabinetSizeMinOrderByAggregateInput
  }

  export type CabinetCabinetSizeScalarWhereWithAggregatesInput = {
    AND?: CabinetCabinetSizeScalarWhereWithAggregatesInput | CabinetCabinetSizeScalarWhereWithAggregatesInput[]
    OR?: CabinetCabinetSizeScalarWhereWithAggregatesInput[]
    NOT?: CabinetCabinetSizeScalarWhereWithAggregatesInput | CabinetCabinetSizeScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetCabinetSize"> | string
    cabinetSizeCode?: StringWithAggregatesFilter<"CabinetCabinetSize"> | string
  }

  export type CabinetPitchWhereInput = {
    AND?: CabinetPitchWhereInput | CabinetPitchWhereInput[]
    OR?: CabinetPitchWhereInput[]
    NOT?: CabinetPitchWhereInput | CabinetPitchWhereInput[]
    cabinetCode?: StringFilter<"CabinetPitch"> | string
    pitchCode?: StringFilter<"CabinetPitch"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    pitch?: XOR<PitchScalarRelationFilter, PitchWhereInput>
  }

  export type CabinetPitchOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    pitchCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    pitch?: PitchOrderByWithRelationInput
  }

  export type CabinetPitchWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_pitchCode?: CabinetPitchCabinetCodePitchCodeCompoundUniqueInput
    AND?: CabinetPitchWhereInput | CabinetPitchWhereInput[]
    OR?: CabinetPitchWhereInput[]
    NOT?: CabinetPitchWhereInput | CabinetPitchWhereInput[]
    cabinetCode?: StringFilter<"CabinetPitch"> | string
    pitchCode?: StringFilter<"CabinetPitch"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    pitch?: XOR<PitchScalarRelationFilter, PitchWhereInput>
  }, "cabinetCode_pitchCode">

  export type CabinetPitchOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    pitchCode?: SortOrder
    _count?: CabinetPitchCountOrderByAggregateInput
    _max?: CabinetPitchMaxOrderByAggregateInput
    _min?: CabinetPitchMinOrderByAggregateInput
  }

  export type CabinetPitchScalarWhereWithAggregatesInput = {
    AND?: CabinetPitchScalarWhereWithAggregatesInput | CabinetPitchScalarWhereWithAggregatesInput[]
    OR?: CabinetPitchScalarWhereWithAggregatesInput[]
    NOT?: CabinetPitchScalarWhereWithAggregatesInput | CabinetPitchScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetPitch"> | string
    pitchCode?: StringWithAggregatesFilter<"CabinetPitch"> | string
  }

  export type CabinetManufacturerWhereInput = {
    AND?: CabinetManufacturerWhereInput | CabinetManufacturerWhereInput[]
    OR?: CabinetManufacturerWhereInput[]
    NOT?: CabinetManufacturerWhereInput | CabinetManufacturerWhereInput[]
    cabinetCode?: StringFilter<"CabinetManufacturer"> | string
    manufacturerCode?: StringFilter<"CabinetManufacturer"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    manufacturer?: XOR<ManufacturerScalarRelationFilter, ManufacturerWhereInput>
  }

  export type CabinetManufacturerOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    manufacturerCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    manufacturer?: ManufacturerOrderByWithRelationInput
  }

  export type CabinetManufacturerWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_manufacturerCode?: CabinetManufacturerCabinetCodeManufacturerCodeCompoundUniqueInput
    AND?: CabinetManufacturerWhereInput | CabinetManufacturerWhereInput[]
    OR?: CabinetManufacturerWhereInput[]
    NOT?: CabinetManufacturerWhereInput | CabinetManufacturerWhereInput[]
    cabinetCode?: StringFilter<"CabinetManufacturer"> | string
    manufacturerCode?: StringFilter<"CabinetManufacturer"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    manufacturer?: XOR<ManufacturerScalarRelationFilter, ManufacturerWhereInput>
  }, "cabinetCode_manufacturerCode">

  export type CabinetManufacturerOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    manufacturerCode?: SortOrder
    _count?: CabinetManufacturerCountOrderByAggregateInput
    _max?: CabinetManufacturerMaxOrderByAggregateInput
    _min?: CabinetManufacturerMinOrderByAggregateInput
  }

  export type CabinetManufacturerScalarWhereWithAggregatesInput = {
    AND?: CabinetManufacturerScalarWhereWithAggregatesInput | CabinetManufacturerScalarWhereWithAggregatesInput[]
    OR?: CabinetManufacturerScalarWhereWithAggregatesInput[]
    NOT?: CabinetManufacturerScalarWhereWithAggregatesInput | CabinetManufacturerScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetManufacturer"> | string
    manufacturerCode?: StringWithAggregatesFilter<"CabinetManufacturer"> | string
  }

  export type CabinetSupplierWhereInput = {
    AND?: CabinetSupplierWhereInput | CabinetSupplierWhereInput[]
    OR?: CabinetSupplierWhereInput[]
    NOT?: CabinetSupplierWhereInput | CabinetSupplierWhereInput[]
    cabinetCode?: StringFilter<"CabinetSupplier"> | string
    supplierCode?: StringFilter<"CabinetSupplier"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type CabinetSupplierOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    supplierCode?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type CabinetSupplierWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_supplierCode?: CabinetSupplierCabinetCodeSupplierCodeCompoundUniqueInput
    AND?: CabinetSupplierWhereInput | CabinetSupplierWhereInput[]
    OR?: CabinetSupplierWhereInput[]
    NOT?: CabinetSupplierWhereInput | CabinetSupplierWhereInput[]
    cabinetCode?: StringFilter<"CabinetSupplier"> | string
    supplierCode?: StringFilter<"CabinetSupplier"> | string
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "cabinetCode_supplierCode">

  export type CabinetSupplierOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    supplierCode?: SortOrder
    _count?: CabinetSupplierCountOrderByAggregateInput
    _max?: CabinetSupplierMaxOrderByAggregateInput
    _min?: CabinetSupplierMinOrderByAggregateInput
  }

  export type CabinetSupplierScalarWhereWithAggregatesInput = {
    AND?: CabinetSupplierScalarWhereWithAggregatesInput | CabinetSupplierScalarWhereWithAggregatesInput[]
    OR?: CabinetSupplierScalarWhereWithAggregatesInput[]
    NOT?: CabinetSupplierScalarWhereWithAggregatesInput | CabinetSupplierScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetSupplier"> | string
    supplierCode?: StringWithAggregatesFilter<"CabinetSupplier"> | string
  }

  export type CabinetItemComponentWhereInput = {
    AND?: CabinetItemComponentWhereInput | CabinetItemComponentWhereInput[]
    OR?: CabinetItemComponentWhereInput[]
    NOT?: CabinetItemComponentWhereInput | CabinetItemComponentWhereInput[]
    cabinetCode?: StringFilter<"CabinetItemComponent"> | string
    itemCode?: StringFilter<"CabinetItemComponent"> | string
    quantity?: IntFilter<"CabinetItemComponent"> | number
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type CabinetItemComponentOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
    cabinet?: CabinetOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type CabinetItemComponentWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode_itemCode?: CabinetItemComponentCabinetCodeItemCodeCompoundUniqueInput
    AND?: CabinetItemComponentWhereInput | CabinetItemComponentWhereInput[]
    OR?: CabinetItemComponentWhereInput[]
    NOT?: CabinetItemComponentWhereInput | CabinetItemComponentWhereInput[]
    cabinetCode?: StringFilter<"CabinetItemComponent"> | string
    itemCode?: StringFilter<"CabinetItemComponent"> | string
    quantity?: IntFilter<"CabinetItemComponent"> | number
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "cabinetCode_itemCode">

  export type CabinetItemComponentOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
    _count?: CabinetItemComponentCountOrderByAggregateInput
    _avg?: CabinetItemComponentAvgOrderByAggregateInput
    _max?: CabinetItemComponentMaxOrderByAggregateInput
    _min?: CabinetItemComponentMinOrderByAggregateInput
    _sum?: CabinetItemComponentSumOrderByAggregateInput
  }

  export type CabinetItemComponentScalarWhereWithAggregatesInput = {
    AND?: CabinetItemComponentScalarWhereWithAggregatesInput | CabinetItemComponentScalarWhereWithAggregatesInput[]
    OR?: CabinetItemComponentScalarWhereWithAggregatesInput[]
    NOT?: CabinetItemComponentScalarWhereWithAggregatesInput | CabinetItemComponentScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetItemComponent"> | string
    itemCode?: StringWithAggregatesFilter<"CabinetItemComponent"> | string
    quantity?: IntWithAggregatesFilter<"CabinetItemComponent"> | number
  }

  export type CabinetPriceWhereInput = {
    AND?: CabinetPriceWhereInput | CabinetPriceWhereInput[]
    OR?: CabinetPriceWhereInput[]
    NOT?: CabinetPriceWhereInput | CabinetPriceWhereInput[]
    cabinetCode?: StringFilter<"CabinetPrice"> | string
    priceUsd?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
  }

  export type CabinetPriceOrderByWithRelationInput = {
    cabinetCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    cabinet?: CabinetOrderByWithRelationInput
  }

  export type CabinetPriceWhereUniqueInput = Prisma.AtLeast<{
    cabinetCode?: string
    AND?: CabinetPriceWhereInput | CabinetPriceWhereInput[]
    OR?: CabinetPriceWhereInput[]
    NOT?: CabinetPriceWhereInput | CabinetPriceWhereInput[]
    priceUsd?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    cabinet?: XOR<CabinetScalarRelationFilter, CabinetWhereInput>
  }, "cabinetCode">

  export type CabinetPriceOrderByWithAggregationInput = {
    cabinetCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    _count?: CabinetPriceCountOrderByAggregateInput
    _avg?: CabinetPriceAvgOrderByAggregateInput
    _max?: CabinetPriceMaxOrderByAggregateInput
    _min?: CabinetPriceMinOrderByAggregateInput
    _sum?: CabinetPriceSumOrderByAggregateInput
  }

  export type CabinetPriceScalarWhereWithAggregatesInput = {
    AND?: CabinetPriceScalarWhereWithAggregatesInput | CabinetPriceScalarWhereWithAggregatesInput[]
    OR?: CabinetPriceScalarWhereWithAggregatesInput[]
    NOT?: CabinetPriceScalarWhereWithAggregatesInput | CabinetPriceScalarWhereWithAggregatesInput[]
    cabinetCode?: StringWithAggregatesFilter<"CabinetPrice"> | string
    priceUsd?: DecimalNullableWithAggregatesFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableWithAggregatesFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ModuleCategoryWhereInput = {
    AND?: ModuleCategoryWhereInput | ModuleCategoryWhereInput[]
    OR?: ModuleCategoryWhereInput[]
    NOT?: ModuleCategoryWhereInput | ModuleCategoryWhereInput[]
    moduleCode?: StringFilter<"ModuleCategory"> | string
    categoryCode?: StringFilter<"ModuleCategory"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }

  export type ModuleCategoryOrderByWithRelationInput = {
    moduleCode?: SortOrder
    categoryCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    category?: ItemCategoryOrderByWithRelationInput
  }

  export type ModuleCategoryWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_categoryCode?: ModuleCategoryModuleCodeCategoryCodeCompoundUniqueInput
    AND?: ModuleCategoryWhereInput | ModuleCategoryWhereInput[]
    OR?: ModuleCategoryWhereInput[]
    NOT?: ModuleCategoryWhereInput | ModuleCategoryWhereInput[]
    moduleCode?: StringFilter<"ModuleCategory"> | string
    categoryCode?: StringFilter<"ModuleCategory"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    category?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
  }, "moduleCode_categoryCode">

  export type ModuleCategoryOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    categoryCode?: SortOrder
    _count?: ModuleCategoryCountOrderByAggregateInput
    _max?: ModuleCategoryMaxOrderByAggregateInput
    _min?: ModuleCategoryMinOrderByAggregateInput
  }

  export type ModuleCategoryScalarWhereWithAggregatesInput = {
    AND?: ModuleCategoryScalarWhereWithAggregatesInput | ModuleCategoryScalarWhereWithAggregatesInput[]
    OR?: ModuleCategoryScalarWhereWithAggregatesInput[]
    NOT?: ModuleCategoryScalarWhereWithAggregatesInput | ModuleCategoryScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleCategory"> | string
    categoryCode?: StringWithAggregatesFilter<"ModuleCategory"> | string
  }

  export type ModuleSubcategoryWhereInput = {
    AND?: ModuleSubcategoryWhereInput | ModuleSubcategoryWhereInput[]
    OR?: ModuleSubcategoryWhereInput[]
    NOT?: ModuleSubcategoryWhereInput | ModuleSubcategoryWhereInput[]
    moduleCode?: StringFilter<"ModuleSubcategory"> | string
    subcategoryCode?: StringFilter<"ModuleSubcategory"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }

  export type ModuleSubcategoryOrderByWithRelationInput = {
    moduleCode?: SortOrder
    subcategoryCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    subcategory?: ItemSubcategoryOrderByWithRelationInput
  }

  export type ModuleSubcategoryWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_subcategoryCode?: ModuleSubcategoryModuleCodeSubcategoryCodeCompoundUniqueInput
    AND?: ModuleSubcategoryWhereInput | ModuleSubcategoryWhereInput[]
    OR?: ModuleSubcategoryWhereInput[]
    NOT?: ModuleSubcategoryWhereInput | ModuleSubcategoryWhereInput[]
    moduleCode?: StringFilter<"ModuleSubcategory"> | string
    subcategoryCode?: StringFilter<"ModuleSubcategory"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    subcategory?: XOR<ItemSubcategoryScalarRelationFilter, ItemSubcategoryWhereInput>
  }, "moduleCode_subcategoryCode">

  export type ModuleSubcategoryOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    subcategoryCode?: SortOrder
    _count?: ModuleSubcategoryCountOrderByAggregateInput
    _max?: ModuleSubcategoryMaxOrderByAggregateInput
    _min?: ModuleSubcategoryMinOrderByAggregateInput
  }

  export type ModuleSubcategoryScalarWhereWithAggregatesInput = {
    AND?: ModuleSubcategoryScalarWhereWithAggregatesInput | ModuleSubcategoryScalarWhereWithAggregatesInput[]
    OR?: ModuleSubcategoryScalarWhereWithAggregatesInput[]
    NOT?: ModuleSubcategoryScalarWhereWithAggregatesInput | ModuleSubcategoryScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleSubcategory"> | string
    subcategoryCode?: StringWithAggregatesFilter<"ModuleSubcategory"> | string
  }

  export type ModuleLocationWhereInput = {
    AND?: ModuleLocationWhereInput | ModuleLocationWhereInput[]
    OR?: ModuleLocationWhereInput[]
    NOT?: ModuleLocationWhereInput | ModuleLocationWhereInput[]
    moduleCode?: StringFilter<"ModuleLocation"> | string
    locationCode?: StringFilter<"ModuleLocation"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type ModuleLocationOrderByWithRelationInput = {
    moduleCode?: SortOrder
    locationCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type ModuleLocationWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_locationCode?: ModuleLocationModuleCodeLocationCodeCompoundUniqueInput
    AND?: ModuleLocationWhereInput | ModuleLocationWhereInput[]
    OR?: ModuleLocationWhereInput[]
    NOT?: ModuleLocationWhereInput | ModuleLocationWhereInput[]
    moduleCode?: StringFilter<"ModuleLocation"> | string
    locationCode?: StringFilter<"ModuleLocation"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "moduleCode_locationCode">

  export type ModuleLocationOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    locationCode?: SortOrder
    _count?: ModuleLocationCountOrderByAggregateInput
    _max?: ModuleLocationMaxOrderByAggregateInput
    _min?: ModuleLocationMinOrderByAggregateInput
  }

  export type ModuleLocationScalarWhereWithAggregatesInput = {
    AND?: ModuleLocationScalarWhereWithAggregatesInput | ModuleLocationScalarWhereWithAggregatesInput[]
    OR?: ModuleLocationScalarWhereWithAggregatesInput[]
    NOT?: ModuleLocationScalarWhereWithAggregatesInput | ModuleLocationScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleLocation"> | string
    locationCode?: StringWithAggregatesFilter<"ModuleLocation"> | string
  }

  export type ModuleRefreshRateWhereInput = {
    AND?: ModuleRefreshRateWhereInput | ModuleRefreshRateWhereInput[]
    OR?: ModuleRefreshRateWhereInput[]
    NOT?: ModuleRefreshRateWhereInput | ModuleRefreshRateWhereInput[]
    moduleCode?: StringFilter<"ModuleRefreshRate"> | string
    refreshRateCode?: StringFilter<"ModuleRefreshRate"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    refreshRate?: XOR<RefreshRateScalarRelationFilter, RefreshRateWhereInput>
  }

  export type ModuleRefreshRateOrderByWithRelationInput = {
    moduleCode?: SortOrder
    refreshRateCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    refreshRate?: RefreshRateOrderByWithRelationInput
  }

  export type ModuleRefreshRateWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_refreshRateCode?: ModuleRefreshRateModuleCodeRefreshRateCodeCompoundUniqueInput
    AND?: ModuleRefreshRateWhereInput | ModuleRefreshRateWhereInput[]
    OR?: ModuleRefreshRateWhereInput[]
    NOT?: ModuleRefreshRateWhereInput | ModuleRefreshRateWhereInput[]
    moduleCode?: StringFilter<"ModuleRefreshRate"> | string
    refreshRateCode?: StringFilter<"ModuleRefreshRate"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    refreshRate?: XOR<RefreshRateScalarRelationFilter, RefreshRateWhereInput>
  }, "moduleCode_refreshRateCode">

  export type ModuleRefreshRateOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    refreshRateCode?: SortOrder
    _count?: ModuleRefreshRateCountOrderByAggregateInput
    _max?: ModuleRefreshRateMaxOrderByAggregateInput
    _min?: ModuleRefreshRateMinOrderByAggregateInput
  }

  export type ModuleRefreshRateScalarWhereWithAggregatesInput = {
    AND?: ModuleRefreshRateScalarWhereWithAggregatesInput | ModuleRefreshRateScalarWhereWithAggregatesInput[]
    OR?: ModuleRefreshRateScalarWhereWithAggregatesInput[]
    NOT?: ModuleRefreshRateScalarWhereWithAggregatesInput | ModuleRefreshRateScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleRefreshRate"> | string
    refreshRateCode?: StringWithAggregatesFilter<"ModuleRefreshRate"> | string
  }

  export type ModuleBrightnessWhereInput = {
    AND?: ModuleBrightnessWhereInput | ModuleBrightnessWhereInput[]
    OR?: ModuleBrightnessWhereInput[]
    NOT?: ModuleBrightnessWhereInput | ModuleBrightnessWhereInput[]
    moduleCode?: StringFilter<"ModuleBrightness"> | string
    brightnessCode?: StringFilter<"ModuleBrightness"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    brightness?: XOR<BrightnessScalarRelationFilter, BrightnessWhereInput>
  }

  export type ModuleBrightnessOrderByWithRelationInput = {
    moduleCode?: SortOrder
    brightnessCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    brightness?: BrightnessOrderByWithRelationInput
  }

  export type ModuleBrightnessWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_brightnessCode?: ModuleBrightnessModuleCodeBrightnessCodeCompoundUniqueInput
    AND?: ModuleBrightnessWhereInput | ModuleBrightnessWhereInput[]
    OR?: ModuleBrightnessWhereInput[]
    NOT?: ModuleBrightnessWhereInput | ModuleBrightnessWhereInput[]
    moduleCode?: StringFilter<"ModuleBrightness"> | string
    brightnessCode?: StringFilter<"ModuleBrightness"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    brightness?: XOR<BrightnessScalarRelationFilter, BrightnessWhereInput>
  }, "moduleCode_brightnessCode">

  export type ModuleBrightnessOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    brightnessCode?: SortOrder
    _count?: ModuleBrightnessCountOrderByAggregateInput
    _max?: ModuleBrightnessMaxOrderByAggregateInput
    _min?: ModuleBrightnessMinOrderByAggregateInput
  }

  export type ModuleBrightnessScalarWhereWithAggregatesInput = {
    AND?: ModuleBrightnessScalarWhereWithAggregatesInput | ModuleBrightnessScalarWhereWithAggregatesInput[]
    OR?: ModuleBrightnessScalarWhereWithAggregatesInput[]
    NOT?: ModuleBrightnessScalarWhereWithAggregatesInput | ModuleBrightnessScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleBrightness"> | string
    brightnessCode?: StringWithAggregatesFilter<"ModuleBrightness"> | string
  }

  export type ModuleModuleSizeWhereInput = {
    AND?: ModuleModuleSizeWhereInput | ModuleModuleSizeWhereInput[]
    OR?: ModuleModuleSizeWhereInput[]
    NOT?: ModuleModuleSizeWhereInput | ModuleModuleSizeWhereInput[]
    moduleCode?: StringFilter<"ModuleModuleSize"> | string
    moduleSizeCode?: StringFilter<"ModuleModuleSize"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    size?: XOR<ModuleSizeScalarRelationFilter, ModuleSizeWhereInput>
  }

  export type ModuleModuleSizeOrderByWithRelationInput = {
    moduleCode?: SortOrder
    moduleSizeCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    size?: ModuleSizeOrderByWithRelationInput
  }

  export type ModuleModuleSizeWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_moduleSizeCode?: ModuleModuleSizeModuleCodeModuleSizeCodeCompoundUniqueInput
    AND?: ModuleModuleSizeWhereInput | ModuleModuleSizeWhereInput[]
    OR?: ModuleModuleSizeWhereInput[]
    NOT?: ModuleModuleSizeWhereInput | ModuleModuleSizeWhereInput[]
    moduleCode?: StringFilter<"ModuleModuleSize"> | string
    moduleSizeCode?: StringFilter<"ModuleModuleSize"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    size?: XOR<ModuleSizeScalarRelationFilter, ModuleSizeWhereInput>
  }, "moduleCode_moduleSizeCode">

  export type ModuleModuleSizeOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    moduleSizeCode?: SortOrder
    _count?: ModuleModuleSizeCountOrderByAggregateInput
    _max?: ModuleModuleSizeMaxOrderByAggregateInput
    _min?: ModuleModuleSizeMinOrderByAggregateInput
  }

  export type ModuleModuleSizeScalarWhereWithAggregatesInput = {
    AND?: ModuleModuleSizeScalarWhereWithAggregatesInput | ModuleModuleSizeScalarWhereWithAggregatesInput[]
    OR?: ModuleModuleSizeScalarWhereWithAggregatesInput[]
    NOT?: ModuleModuleSizeScalarWhereWithAggregatesInput | ModuleModuleSizeScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleModuleSize"> | string
    moduleSizeCode?: StringWithAggregatesFilter<"ModuleModuleSize"> | string
  }

  export type ModulePitchWhereInput = {
    AND?: ModulePitchWhereInput | ModulePitchWhereInput[]
    OR?: ModulePitchWhereInput[]
    NOT?: ModulePitchWhereInput | ModulePitchWhereInput[]
    moduleCode?: StringFilter<"ModulePitch"> | string
    pitchCode?: StringFilter<"ModulePitch"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    pitch?: XOR<PitchScalarRelationFilter, PitchWhereInput>
  }

  export type ModulePitchOrderByWithRelationInput = {
    moduleCode?: SortOrder
    pitchCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    pitch?: PitchOrderByWithRelationInput
  }

  export type ModulePitchWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_pitchCode?: ModulePitchModuleCodePitchCodeCompoundUniqueInput
    AND?: ModulePitchWhereInput | ModulePitchWhereInput[]
    OR?: ModulePitchWhereInput[]
    NOT?: ModulePitchWhereInput | ModulePitchWhereInput[]
    moduleCode?: StringFilter<"ModulePitch"> | string
    pitchCode?: StringFilter<"ModulePitch"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    pitch?: XOR<PitchScalarRelationFilter, PitchWhereInput>
  }, "moduleCode_pitchCode">

  export type ModulePitchOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    pitchCode?: SortOrder
    _count?: ModulePitchCountOrderByAggregateInput
    _max?: ModulePitchMaxOrderByAggregateInput
    _min?: ModulePitchMinOrderByAggregateInput
  }

  export type ModulePitchScalarWhereWithAggregatesInput = {
    AND?: ModulePitchScalarWhereWithAggregatesInput | ModulePitchScalarWhereWithAggregatesInput[]
    OR?: ModulePitchScalarWhereWithAggregatesInput[]
    NOT?: ModulePitchScalarWhereWithAggregatesInput | ModulePitchScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModulePitch"> | string
    pitchCode?: StringWithAggregatesFilter<"ModulePitch"> | string
  }

  export type ModuleManufacturerWhereInput = {
    AND?: ModuleManufacturerWhereInput | ModuleManufacturerWhereInput[]
    OR?: ModuleManufacturerWhereInput[]
    NOT?: ModuleManufacturerWhereInput | ModuleManufacturerWhereInput[]
    moduleCode?: StringFilter<"ModuleManufacturer"> | string
    manufacturerCode?: StringFilter<"ModuleManufacturer"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    manufacturer?: XOR<ManufacturerScalarRelationFilter, ManufacturerWhereInput>
  }

  export type ModuleManufacturerOrderByWithRelationInput = {
    moduleCode?: SortOrder
    manufacturerCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    manufacturer?: ManufacturerOrderByWithRelationInput
  }

  export type ModuleManufacturerWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_manufacturerCode?: ModuleManufacturerModuleCodeManufacturerCodeCompoundUniqueInput
    AND?: ModuleManufacturerWhereInput | ModuleManufacturerWhereInput[]
    OR?: ModuleManufacturerWhereInput[]
    NOT?: ModuleManufacturerWhereInput | ModuleManufacturerWhereInput[]
    moduleCode?: StringFilter<"ModuleManufacturer"> | string
    manufacturerCode?: StringFilter<"ModuleManufacturer"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    manufacturer?: XOR<ManufacturerScalarRelationFilter, ManufacturerWhereInput>
  }, "moduleCode_manufacturerCode">

  export type ModuleManufacturerOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    manufacturerCode?: SortOrder
    _count?: ModuleManufacturerCountOrderByAggregateInput
    _max?: ModuleManufacturerMaxOrderByAggregateInput
    _min?: ModuleManufacturerMinOrderByAggregateInput
  }

  export type ModuleManufacturerScalarWhereWithAggregatesInput = {
    AND?: ModuleManufacturerScalarWhereWithAggregatesInput | ModuleManufacturerScalarWhereWithAggregatesInput[]
    OR?: ModuleManufacturerScalarWhereWithAggregatesInput[]
    NOT?: ModuleManufacturerScalarWhereWithAggregatesInput | ModuleManufacturerScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleManufacturer"> | string
    manufacturerCode?: StringWithAggregatesFilter<"ModuleManufacturer"> | string
  }

  export type ModuleItemComponentWhereInput = {
    AND?: ModuleItemComponentWhereInput | ModuleItemComponentWhereInput[]
    OR?: ModuleItemComponentWhereInput[]
    NOT?: ModuleItemComponentWhereInput | ModuleItemComponentWhereInput[]
    moduleCode?: StringFilter<"ModuleItemComponent"> | string
    itemCode?: StringFilter<"ModuleItemComponent"> | string
    quantity?: IntFilter<"ModuleItemComponent"> | number
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ModuleItemComponentOrderByWithRelationInput = {
    moduleCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
    module?: ModuleOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ModuleItemComponentWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_itemCode?: ModuleItemComponentModuleCodeItemCodeCompoundUniqueInput
    AND?: ModuleItemComponentWhereInput | ModuleItemComponentWhereInput[]
    OR?: ModuleItemComponentWhereInput[]
    NOT?: ModuleItemComponentWhereInput | ModuleItemComponentWhereInput[]
    moduleCode?: StringFilter<"ModuleItemComponent"> | string
    itemCode?: StringFilter<"ModuleItemComponent"> | string
    quantity?: IntFilter<"ModuleItemComponent"> | number
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "moduleCode_itemCode">

  export type ModuleItemComponentOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
    _count?: ModuleItemComponentCountOrderByAggregateInput
    _avg?: ModuleItemComponentAvgOrderByAggregateInput
    _max?: ModuleItemComponentMaxOrderByAggregateInput
    _min?: ModuleItemComponentMinOrderByAggregateInput
    _sum?: ModuleItemComponentSumOrderByAggregateInput
  }

  export type ModuleItemComponentScalarWhereWithAggregatesInput = {
    AND?: ModuleItemComponentScalarWhereWithAggregatesInput | ModuleItemComponentScalarWhereWithAggregatesInput[]
    OR?: ModuleItemComponentScalarWhereWithAggregatesInput[]
    NOT?: ModuleItemComponentScalarWhereWithAggregatesInput | ModuleItemComponentScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleItemComponent"> | string
    itemCode?: StringWithAggregatesFilter<"ModuleItemComponent"> | string
    quantity?: IntWithAggregatesFilter<"ModuleItemComponent"> | number
  }

  export type ModuleOptionWhereInput = {
    AND?: ModuleOptionWhereInput | ModuleOptionWhereInput[]
    OR?: ModuleOptionWhereInput[]
    NOT?: ModuleOptionWhereInput | ModuleOptionWhereInput[]
    moduleCode?: StringFilter<"ModuleOption"> | string
    optionCode?: StringFilter<"ModuleOption"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }

  export type ModuleOptionOrderByWithRelationInput = {
    moduleCode?: SortOrder
    optionCode?: SortOrder
    module?: ModuleOrderByWithRelationInput
    option?: OptionOrderByWithRelationInput
  }

  export type ModuleOptionWhereUniqueInput = Prisma.AtLeast<{
    moduleCode_optionCode?: ModuleOptionModuleCodeOptionCodeCompoundUniqueInput
    AND?: ModuleOptionWhereInput | ModuleOptionWhereInput[]
    OR?: ModuleOptionWhereInput[]
    NOT?: ModuleOptionWhereInput | ModuleOptionWhereInput[]
    moduleCode?: StringFilter<"ModuleOption"> | string
    optionCode?: StringFilter<"ModuleOption"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }, "moduleCode_optionCode">

  export type ModuleOptionOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    optionCode?: SortOrder
    _count?: ModuleOptionCountOrderByAggregateInput
    _max?: ModuleOptionMaxOrderByAggregateInput
    _min?: ModuleOptionMinOrderByAggregateInput
  }

  export type ModuleOptionScalarWhereWithAggregatesInput = {
    AND?: ModuleOptionScalarWhereWithAggregatesInput | ModuleOptionScalarWhereWithAggregatesInput[]
    OR?: ModuleOptionScalarWhereWithAggregatesInput[]
    NOT?: ModuleOptionScalarWhereWithAggregatesInput | ModuleOptionScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModuleOption"> | string
    optionCode?: StringWithAggregatesFilter<"ModuleOption"> | string
  }

  export type ModulePriceWhereInput = {
    AND?: ModulePriceWhereInput | ModulePriceWhereInput[]
    OR?: ModulePriceWhereInput[]
    NOT?: ModulePriceWhereInput | ModulePriceWhereInput[]
    moduleCode?: StringFilter<"ModulePrice"> | string
    priceUsd?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }

  export type ModulePriceOrderByWithRelationInput = {
    moduleCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    module?: ModuleOrderByWithRelationInput
  }

  export type ModulePriceWhereUniqueInput = Prisma.AtLeast<{
    moduleCode?: string
    AND?: ModulePriceWhereInput | ModulePriceWhereInput[]
    OR?: ModulePriceWhereInput[]
    NOT?: ModulePriceWhereInput | ModulePriceWhereInput[]
    priceUsd?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }, "moduleCode">

  export type ModulePriceOrderByWithAggregationInput = {
    moduleCode?: SortOrder
    priceUsd?: SortOrderInput | SortOrder
    priceRub?: SortOrderInput | SortOrder
    _count?: ModulePriceCountOrderByAggregateInput
    _avg?: ModulePriceAvgOrderByAggregateInput
    _max?: ModulePriceMaxOrderByAggregateInput
    _min?: ModulePriceMinOrderByAggregateInput
    _sum?: ModulePriceSumOrderByAggregateInput
  }

  export type ModulePriceScalarWhereWithAggregatesInput = {
    AND?: ModulePriceScalarWhereWithAggregatesInput | ModulePriceScalarWhereWithAggregatesInput[]
    OR?: ModulePriceScalarWhereWithAggregatesInput[]
    NOT?: ModulePriceScalarWhereWithAggregatesInput | ModulePriceScalarWhereWithAggregatesInput[]
    moduleCode?: StringWithAggregatesFilter<"ModulePrice"> | string
    priceUsd?: DecimalNullableWithAggregatesFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableWithAggregatesFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetSizeModuleSizeWhereInput = {
    AND?: CabinetSizeModuleSizeWhereInput | CabinetSizeModuleSizeWhereInput[]
    OR?: CabinetSizeModuleSizeWhereInput[]
    NOT?: CabinetSizeModuleSizeWhereInput | CabinetSizeModuleSizeWhereInput[]
    cabinetSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
    moduleSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
    cabinetSize?: XOR<CabinetSizeScalarRelationFilter, CabinetSizeWhereInput>
    moduleSize?: XOR<ModuleSizeScalarRelationFilter, ModuleSizeWhereInput>
  }

  export type CabinetSizeModuleSizeOrderByWithRelationInput = {
    cabinetSizeCode?: SortOrder
    moduleSizeCode?: SortOrder
    cabinetSize?: CabinetSizeOrderByWithRelationInput
    moduleSize?: ModuleSizeOrderByWithRelationInput
  }

  export type CabinetSizeModuleSizeWhereUniqueInput = Prisma.AtLeast<{
    cabinetSizeCode_moduleSizeCode?: CabinetSizeModuleSizeCabinetSizeCodeModuleSizeCodeCompoundUniqueInput
    AND?: CabinetSizeModuleSizeWhereInput | CabinetSizeModuleSizeWhereInput[]
    OR?: CabinetSizeModuleSizeWhereInput[]
    NOT?: CabinetSizeModuleSizeWhereInput | CabinetSizeModuleSizeWhereInput[]
    cabinetSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
    moduleSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
    cabinetSize?: XOR<CabinetSizeScalarRelationFilter, CabinetSizeWhereInput>
    moduleSize?: XOR<ModuleSizeScalarRelationFilter, ModuleSizeWhereInput>
  }, "cabinetSizeCode_moduleSizeCode">

  export type CabinetSizeModuleSizeOrderByWithAggregationInput = {
    cabinetSizeCode?: SortOrder
    moduleSizeCode?: SortOrder
    _count?: CabinetSizeModuleSizeCountOrderByAggregateInput
    _max?: CabinetSizeModuleSizeMaxOrderByAggregateInput
    _min?: CabinetSizeModuleSizeMinOrderByAggregateInput
  }

  export type CabinetSizeModuleSizeScalarWhereWithAggregatesInput = {
    AND?: CabinetSizeModuleSizeScalarWhereWithAggregatesInput | CabinetSizeModuleSizeScalarWhereWithAggregatesInput[]
    OR?: CabinetSizeModuleSizeScalarWhereWithAggregatesInput[]
    NOT?: CabinetSizeModuleSizeScalarWhereWithAggregatesInput | CabinetSizeModuleSizeScalarWhereWithAggregatesInput[]
    cabinetSizeCode?: StringWithAggregatesFilter<"CabinetSizeModuleSize"> | string
    moduleSizeCode?: StringWithAggregatesFilter<"CabinetSizeModuleSize"> | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    name: string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    name: string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    name: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionCreateNestedManyWithoutScreenTypeInput
    controlTypes?: ScreenTypeControlTypeCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionUncheckedCreateNestedManyWithoutScreenTypeInput
    controlTypes?: ScreenTypeControlTypeUncheckedCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorUncheckedCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUpdateManyWithoutScreenTypeNestedInput
    controlTypes?: ScreenTypeControlTypeUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUpdateManyWithoutScreenTypeNestedInput
  }

  export type ScreenTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeNestedInput
    controlTypes?: ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeNestedInput
  }

  export type ScreenTypeCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScreenTypeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetMaterialCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetMaterialUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetMaterialUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetMaterialUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetLocationCreateNestedManyWithoutLocationInput
    modules?: ModuleLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetLocationUncheckedCreateNestedManyWithoutLocationInput
    modules?: ModuleLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetLocationUpdateManyWithoutLocationNestedInput
    modules?: ModuleLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetLocationUncheckedUpdateManyWithoutLocationNestedInput
    modules?: ModuleLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPlacementCreateNestedManyWithoutPlacementInput
  }

  export type PlacementUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPlacementUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPlacementUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPlacementUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlacementUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeOptionCreateNestedManyWithoutOptionInput
    modules?: ModuleOptionCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeOptionUncheckedCreateNestedManyWithoutOptionInput
    modules?: ModuleOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeOptionUpdateManyWithoutOptionNestedInput
    modules?: ModuleOptionUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeOptionUncheckedUpdateManyWithoutOptionNestedInput
    modules?: ModuleOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeSensorCreateNestedManyWithoutSensorInput
  }

  export type SensorUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeSensorUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeSensorUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeSensorUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SensorUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlTypeCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeControlTypeCreateNestedManyWithoutControlTypeInput
  }

  export type ControlTypeUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeControlTypeUncheckedCreateNestedManyWithoutControlTypeInput
  }

  export type ControlTypeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeControlTypeUpdateManyWithoutControlTypeNestedInput
  }

  export type ControlTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeControlTypeUncheckedUpdateManyWithoutControlTypeNestedInput
  }

  export type ControlTypeCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlTypeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PitchCreateInput = {
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPitchCreateNestedManyWithoutPitchInput
    modules?: ModulePitchCreateNestedManyWithoutPitchInput
  }

  export type PitchUncheckedCreateInput = {
    id?: number
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPitchUncheckedCreateNestedManyWithoutPitchInput
    modules?: ModulePitchUncheckedCreateNestedManyWithoutPitchInput
  }

  export type PitchUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPitchUpdateManyWithoutPitchNestedInput
    modules?: ModulePitchUpdateManyWithoutPitchNestedInput
  }

  export type PitchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPitchUncheckedUpdateManyWithoutPitchNestedInput
    modules?: ModulePitchUncheckedUpdateManyWithoutPitchNestedInput
  }

  export type PitchCreateManyInput = {
    id?: number
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PitchUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PitchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshRateCreateInput = {
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleRefreshRateCreateNestedManyWithoutRefreshRateInput
  }

  export type RefreshRateUncheckedCreateInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleRefreshRateUncheckedCreateNestedManyWithoutRefreshRateInput
  }

  export type RefreshRateUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleRefreshRateUpdateManyWithoutRefreshRateNestedInput
  }

  export type RefreshRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleRefreshRateUncheckedUpdateManyWithoutRefreshRateNestedInput
  }

  export type RefreshRateCreateManyInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshRateUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrightnessCreateInput = {
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleBrightnessCreateNestedManyWithoutBrightnessInput
  }

  export type BrightnessUncheckedCreateInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleBrightnessUncheckedCreateNestedManyWithoutBrightnessInput
  }

  export type BrightnessUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleBrightnessUpdateManyWithoutBrightnessNestedInput
  }

  export type BrightnessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleBrightnessUncheckedUpdateManyWithoutBrightnessNestedInput
  }

  export type BrightnessCreateManyInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrightnessUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrightnessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturerCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetManufacturerCreateNestedManyWithoutManufacturerInput
    modules?: ModuleManufacturerCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetManufacturerUncheckedCreateNestedManyWithoutManufacturerInput
    modules?: ModuleManufacturerUncheckedCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetManufacturerUpdateManyWithoutManufacturerNestedInput
    modules?: ModuleManufacturerUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput
    modules?: ModuleManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManufacturerUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetSupplierCreateNestedManyWithoutSupplierInput
    items?: ItemSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetSupplierUncheckedCreateNestedManyWithoutSupplierInput
    items?: ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetSupplierUpdateManyWithoutSupplierNestedInput
    items?: ItemSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    items?: ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpProtectionCreateInput = {
    code: string
    protectionSolid: string
    protectionWater: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpProtectionUncheckedCreateInput = {
    id?: number
    code: string
    protectionSolid: string
    protectionWater: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpProtectionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    protectionSolid?: StringFieldUpdateOperationsInput | string
    protectionWater?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpProtectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    protectionSolid?: StringFieldUpdateOperationsInput | string
    protectionWater?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpProtectionCreateManyInput = {
    id?: number
    code: string
    protectionSolid: string
    protectionWater: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpProtectionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    protectionSolid?: StringFieldUpdateOperationsInput | string
    protectionWater?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpProtectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    protectionSolid?: StringFieldUpdateOperationsInput | string
    protectionWater?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleSizeCreateInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleModuleSizeCreateNestedManyWithoutSizeInput
    cabinetSizes?: CabinetSizeModuleSizeCreateNestedManyWithoutModuleSizeInput
  }

  export type ModuleSizeUncheckedCreateInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleModuleSizeUncheckedCreateNestedManyWithoutSizeInput
    cabinetSizes?: CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutModuleSizeInput
  }

  export type ModuleSizeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleModuleSizeUpdateManyWithoutSizeNestedInput
    cabinetSizes?: CabinetSizeModuleSizeUpdateManyWithoutModuleSizeNestedInput
  }

  export type ModuleSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleModuleSizeUncheckedUpdateManyWithoutSizeNestedInput
    cabinetSizes?: CabinetSizeModuleSizeUncheckedUpdateManyWithoutModuleSizeNestedInput
  }

  export type ModuleSizeCreateManyInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleSizeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetSizeCreateInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetCabinetSizeCreateNestedManyWithoutSizeInput
    moduleSizes?: CabinetSizeModuleSizeCreateNestedManyWithoutCabinetSizeInput
  }

  export type CabinetSizeUncheckedCreateInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutSizeInput
    moduleSizes?: CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutCabinetSizeInput
  }

  export type CabinetSizeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetCabinetSizeUpdateManyWithoutSizeNestedInput
    moduleSizes?: CabinetSizeModuleSizeUpdateManyWithoutCabinetSizeNestedInput
  }

  export type CabinetSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetCabinetSizeUncheckedUpdateManyWithoutSizeNestedInput
    moduleSizes?: CabinetSizeModuleSizeUncheckedUpdateManyWithoutCabinetSizeNestedInput
  }

  export type CabinetSizeCreateManyInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetSizeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationUncheckedCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUncheckedUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSubcategoryCreateInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryCreateManyInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemSubcategoryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSubcategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetCreateInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetCreateManyInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenTypeOptionCreateInput = {
    screenType: ScreenTypeCreateNestedOneWithoutOptionsInput
    option: OptionCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeOptionUncheckedCreateInput = {
    screenTypeCode: string
    optionCode: string
  }

  export type ScreenTypeOptionUpdateInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutOptionsNestedInput
    option?: OptionUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeOptionUncheckedUpdateInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeOptionCreateManyInput = {
    screenTypeCode: string
    optionCode: string
  }

  export type ScreenTypeOptionUpdateManyMutationInput = {

  }

  export type ScreenTypeOptionUncheckedUpdateManyInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeCreateInput = {
    screenType: ScreenTypeCreateNestedOneWithoutControlTypesInput
    controlType: ControlTypeCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeControlTypeUncheckedCreateInput = {
    screenTypeCode: string
    controlTypeCode: string
  }

  export type ScreenTypeControlTypeUpdateInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutControlTypesNestedInput
    controlType?: ControlTypeUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeControlTypeUncheckedUpdateInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    controlTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeCreateManyInput = {
    screenTypeCode: string
    controlTypeCode: string
  }

  export type ScreenTypeControlTypeUpdateManyMutationInput = {

  }

  export type ScreenTypeControlTypeUncheckedUpdateManyInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    controlTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorCreateInput = {
    screenType: ScreenTypeCreateNestedOneWithoutSensorsInput
    sensor: SensorCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeSensorUncheckedCreateInput = {
    screenTypeCode: string
    sensorCode: string
  }

  export type ScreenTypeSensorUpdateInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutSensorsNestedInput
    sensor?: SensorUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeSensorUncheckedUpdateInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    sensorCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorCreateManyInput = {
    screenTypeCode: string
    sensorCode: string
  }

  export type ScreenTypeSensorUpdateManyMutationInput = {

  }

  export type ScreenTypeSensorUncheckedUpdateManyInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
    sensorCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryRelationCreateInput = {
    item: ItemCreateNestedOneWithoutCategoriesInput
    category: ItemCategoryCreateNestedOneWithoutItemsInput
  }

  export type ItemCategoryRelationUncheckedCreateInput = {
    itemCode: string
    categoryCode: string
  }

  export type ItemCategoryRelationUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutCategoriesNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemCategoryRelationUncheckedUpdateInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryRelationCreateManyInput = {
    itemCode: string
    categoryCode: string
  }

  export type ItemCategoryRelationUpdateManyMutationInput = {

  }

  export type ItemCategoryRelationUncheckedUpdateManyInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationCreateInput = {
    item: ItemCreateNestedOneWithoutSubcategoriesInput
    subcategory: ItemSubcategoryCreateNestedOneWithoutItemsInput
  }

  export type ItemSubcategoryRelationUncheckedCreateInput = {
    itemCode: string
    subcategoryCode: string
  }

  export type ItemSubcategoryRelationUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutSubcategoriesNestedInput
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemSubcategoryRelationUncheckedUpdateInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationCreateManyInput = {
    itemCode: string
    subcategoryCode: string
  }

  export type ItemSubcategoryRelationUpdateManyMutationInput = {

  }

  export type ItemSubcategoryRelationUncheckedUpdateManyInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemPriceCreateInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
    item: ItemCreateNestedOneWithoutPricesInput
  }

  export type ItemPriceUncheckedCreateInput = {
    itemCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUpdateInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item?: ItemUpdateOneRequiredWithoutPricesNestedInput
  }

  export type ItemPriceUncheckedUpdateInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceCreateManyInput = {
    itemCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUpdateManyMutationInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUncheckedUpdateManyInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemSupplierCreateInput = {
    item: ItemCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutItemsInput
  }

  export type ItemSupplierUncheckedCreateInput = {
    itemCode: string
    supplierCode: string
  }

  export type ItemSupplierUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemSupplierUncheckedUpdateInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSupplierCreateManyInput = {
    itemCode: string
    supplierCode: string
  }

  export type ItemSupplierUpdateManyMutationInput = {

  }

  export type ItemSupplierUncheckedUpdateManyInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryCreateInput = {
    category: ItemCategoryCreateNestedOneWithoutSubcategoriesInput
    subcategory: ItemSubcategoryCreateNestedOneWithoutCategoriesInput
  }

  export type ItemCategorySubcategoryUncheckedCreateInput = {
    categoryCode: string
    subcategoryCode: string
  }

  export type ItemCategorySubcategoryUpdateInput = {
    category?: ItemCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ItemCategorySubcategoryUncheckedUpdateInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryCreateManyInput = {
    categoryCode: string
    subcategoryCode: string
  }

  export type ItemCategorySubcategoryUpdateManyMutationInput = {

  }

  export type ItemCategorySubcategoryUncheckedUpdateManyInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutCategoriesInput
    category: ItemCategoryCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetCategoryUncheckedCreateInput = {
    cabinetCode: string
    categoryCode: string
  }

  export type CabinetCategoryUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutCategoriesNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetCategoryUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryCreateManyInput = {
    cabinetCode: string
    categoryCode: string
  }

  export type CabinetCategoryUpdateManyMutationInput = {

  }

  export type CabinetCategoryUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutSubcategoriesInput
    subcategory: ItemSubcategoryCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetSubcategoryUncheckedCreateInput = {
    cabinetCode: string
    subcategoryCode: string
  }

  export type CabinetSubcategoryUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSubcategoriesNestedInput
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetSubcategoryUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryCreateManyInput = {
    cabinetCode: string
    subcategoryCode: string
  }

  export type CabinetSubcategoryUpdateManyMutationInput = {

  }

  export type CabinetSubcategoryUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetLocationUncheckedCreateInput = {
    cabinetCode: string
    locationCode: string
  }

  export type CabinetLocationUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetLocationUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationCreateManyInput = {
    cabinetCode: string
    locationCode: string
  }

  export type CabinetLocationUpdateManyMutationInput = {

  }

  export type CabinetLocationUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutPlacementsInput
    placement: PlacementCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetPlacementUncheckedCreateInput = {
    cabinetCode: string
    placementCode: string
  }

  export type CabinetPlacementUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutPlacementsNestedInput
    placement?: PlacementUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetPlacementUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    placementCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementCreateManyInput = {
    cabinetCode: string
    placementCode: string
  }

  export type CabinetPlacementUpdateManyMutationInput = {

  }

  export type CabinetPlacementUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    placementCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutMaterialsInput
    material: MaterialCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetMaterialUncheckedCreateInput = {
    cabinetCode: string
    materialCode: string
  }

  export type CabinetMaterialUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutMaterialsNestedInput
    material?: MaterialUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetMaterialUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    materialCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialCreateManyInput = {
    cabinetCode: string
    materialCode: string
  }

  export type CabinetMaterialUpdateManyMutationInput = {

  }

  export type CabinetMaterialUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    materialCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutSizesInput
    size: CabinetSizeCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetCabinetSizeUncheckedCreateInput = {
    cabinetCode: string
    cabinetSizeCode: string
  }

  export type CabinetCabinetSizeUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSizesNestedInput
    size?: CabinetSizeUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetCabinetSizeUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeCreateManyInput = {
    cabinetCode: string
    cabinetSizeCode: string
  }

  export type CabinetCabinetSizeUpdateManyMutationInput = {

  }

  export type CabinetCabinetSizeUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutPitchesInput
    pitch: PitchCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetPitchUncheckedCreateInput = {
    cabinetCode: string
    pitchCode: string
  }

  export type CabinetPitchUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutPitchesNestedInput
    pitch?: PitchUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetPitchUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchCreateManyInput = {
    cabinetCode: string
    pitchCode: string
  }

  export type CabinetPitchUpdateManyMutationInput = {

  }

  export type CabinetPitchUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutManufacturersInput
    manufacturer: ManufacturerCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetManufacturerUncheckedCreateInput = {
    cabinetCode: string
    manufacturerCode: string
  }

  export type CabinetManufacturerUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutManufacturersNestedInput
    manufacturer?: ManufacturerUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetManufacturerUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerCreateManyInput = {
    cabinetCode: string
    manufacturerCode: string
  }

  export type CabinetManufacturerUpdateManyMutationInput = {

  }

  export type CabinetManufacturerUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierCreateInput = {
    cabinet: CabinetCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetSupplierUncheckedCreateInput = {
    cabinetCode: string
    supplierCode: string
  }

  export type CabinetSupplierUpdateInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetSupplierUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierCreateManyInput = {
    cabinetCode: string
    supplierCode: string
  }

  export type CabinetSupplierUpdateManyMutationInput = {

  }

  export type CabinetSupplierUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetItemComponentCreateInput = {
    quantity: number
    cabinet: CabinetCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetItemComponentUncheckedCreateInput = {
    cabinetCode: string
    itemCode: string
    quantity: number
  }

  export type CabinetItemComponentUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cabinet?: CabinetUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetItemComponentUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetItemComponentCreateManyInput = {
    cabinetCode: string
    itemCode: string
    quantity: number
  }

  export type CabinetItemComponentUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetItemComponentUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetPriceCreateInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
    cabinet: CabinetCreateNestedOneWithoutPricesInput
  }

  export type CabinetPriceUncheckedCreateInput = {
    cabinetCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUpdateInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cabinet?: CabinetUpdateOneRequiredWithoutPricesNestedInput
  }

  export type CabinetPriceUncheckedUpdateInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceCreateManyInput = {
    cabinetCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUpdateManyMutationInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUncheckedUpdateManyInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModuleCategoryCreateInput = {
    module: ModuleCreateNestedOneWithoutCategoriesInput
    category: ItemCategoryCreateNestedOneWithoutModulesInput
  }

  export type ModuleCategoryUncheckedCreateInput = {
    moduleCode: string
    categoryCode: string
  }

  export type ModuleCategoryUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutCategoriesNestedInput
    category?: ItemCategoryUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleCategoryUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleCategoryCreateManyInput = {
    moduleCode: string
    categoryCode: string
  }

  export type ModuleCategoryUpdateManyMutationInput = {

  }

  export type ModuleCategoryUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryCreateInput = {
    module: ModuleCreateNestedOneWithoutSubcategoriesInput
    subcategory: ItemSubcategoryCreateNestedOneWithoutModulesInput
  }

  export type ModuleSubcategoryUncheckedCreateInput = {
    moduleCode: string
    subcategoryCode: string
  }

  export type ModuleSubcategoryUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutSubcategoriesNestedInput
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleSubcategoryUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryCreateManyInput = {
    moduleCode: string
    subcategoryCode: string
  }

  export type ModuleSubcategoryUpdateManyMutationInput = {

  }

  export type ModuleSubcategoryUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationCreateInput = {
    module: ModuleCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutModulesInput
  }

  export type ModuleLocationUncheckedCreateInput = {
    moduleCode: string
    locationCode: string
  }

  export type ModuleLocationUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleLocationUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationCreateManyInput = {
    moduleCode: string
    locationCode: string
  }

  export type ModuleLocationUpdateManyMutationInput = {

  }

  export type ModuleLocationUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateCreateInput = {
    module: ModuleCreateNestedOneWithoutRefreshRatesInput
    refreshRate: RefreshRateCreateNestedOneWithoutModulesInput
  }

  export type ModuleRefreshRateUncheckedCreateInput = {
    moduleCode: string
    refreshRateCode: string
  }

  export type ModuleRefreshRateUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutRefreshRatesNestedInput
    refreshRate?: RefreshRateUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleRefreshRateUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    refreshRateCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateCreateManyInput = {
    moduleCode: string
    refreshRateCode: string
  }

  export type ModuleRefreshRateUpdateManyMutationInput = {

  }

  export type ModuleRefreshRateUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    refreshRateCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessCreateInput = {
    module: ModuleCreateNestedOneWithoutBrightnessesInput
    brightness: BrightnessCreateNestedOneWithoutModulesInput
  }

  export type ModuleBrightnessUncheckedCreateInput = {
    moduleCode: string
    brightnessCode: string
  }

  export type ModuleBrightnessUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutBrightnessesNestedInput
    brightness?: BrightnessUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleBrightnessUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    brightnessCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessCreateManyInput = {
    moduleCode: string
    brightnessCode: string
  }

  export type ModuleBrightnessUpdateManyMutationInput = {

  }

  export type ModuleBrightnessUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    brightnessCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeCreateInput = {
    module: ModuleCreateNestedOneWithoutSizesInput
    size: ModuleSizeCreateNestedOneWithoutModulesInput
  }

  export type ModuleModuleSizeUncheckedCreateInput = {
    moduleCode: string
    moduleSizeCode: string
  }

  export type ModuleModuleSizeUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutSizesNestedInput
    size?: ModuleSizeUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleModuleSizeUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeCreateManyInput = {
    moduleCode: string
    moduleSizeCode: string
  }

  export type ModuleModuleSizeUpdateManyMutationInput = {

  }

  export type ModuleModuleSizeUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchCreateInput = {
    module: ModuleCreateNestedOneWithoutPitchesInput
    pitch: PitchCreateNestedOneWithoutModulesInput
  }

  export type ModulePitchUncheckedCreateInput = {
    moduleCode: string
    pitchCode: string
  }

  export type ModulePitchUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutPitchesNestedInput
    pitch?: PitchUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModulePitchUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchCreateManyInput = {
    moduleCode: string
    pitchCode: string
  }

  export type ModulePitchUpdateManyMutationInput = {

  }

  export type ModulePitchUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerCreateInput = {
    module: ModuleCreateNestedOneWithoutManufacturersInput
    manufacturer: ManufacturerCreateNestedOneWithoutModulesInput
  }

  export type ModuleManufacturerUncheckedCreateInput = {
    moduleCode: string
    manufacturerCode: string
  }

  export type ModuleManufacturerUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutManufacturersNestedInput
    manufacturer?: ManufacturerUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleManufacturerUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerCreateManyInput = {
    moduleCode: string
    manufacturerCode: string
  }

  export type ModuleManufacturerUpdateManyMutationInput = {

  }

  export type ModuleManufacturerUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleItemComponentCreateInput = {
    quantity: number
    module: ModuleCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutModulesInput
  }

  export type ModuleItemComponentUncheckedCreateInput = {
    moduleCode: string
    itemCode: string
    quantity: number
  }

  export type ModuleItemComponentUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleItemComponentUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleItemComponentCreateManyInput = {
    moduleCode: string
    itemCode: string
    quantity: number
  }

  export type ModuleItemComponentUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleItemComponentUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleOptionCreateInput = {
    module: ModuleCreateNestedOneWithoutOptionsInput
    option: OptionCreateNestedOneWithoutModulesInput
  }

  export type ModuleOptionUncheckedCreateInput = {
    moduleCode: string
    optionCode: string
  }

  export type ModuleOptionUpdateInput = {
    module?: ModuleUpdateOneRequiredWithoutOptionsNestedInput
    option?: OptionUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleOptionUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleOptionCreateManyInput = {
    moduleCode: string
    optionCode: string
  }

  export type ModuleOptionUpdateManyMutationInput = {

  }

  export type ModuleOptionUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePriceCreateInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
    module: ModuleCreateNestedOneWithoutPricesInput
  }

  export type ModulePriceUncheckedCreateInput = {
    moduleCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUpdateInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    module?: ModuleUpdateOneRequiredWithoutPricesNestedInput
  }

  export type ModulePriceUncheckedUpdateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceCreateManyInput = {
    moduleCode: string
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUpdateManyMutationInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUncheckedUpdateManyInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetSizeModuleSizeCreateInput = {
    cabinetSize: CabinetSizeCreateNestedOneWithoutModuleSizesInput
    moduleSize: ModuleSizeCreateNestedOneWithoutCabinetSizesInput
  }

  export type CabinetSizeModuleSizeUncheckedCreateInput = {
    cabinetSizeCode: string
    moduleSizeCode: string
  }

  export type CabinetSizeModuleSizeUpdateInput = {
    cabinetSize?: CabinetSizeUpdateOneRequiredWithoutModuleSizesNestedInput
    moduleSize?: ModuleSizeUpdateOneRequiredWithoutCabinetSizesNestedInput
  }

  export type CabinetSizeModuleSizeUncheckedUpdateInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSizeModuleSizeCreateManyInput = {
    cabinetSizeCode: string
    moduleSizeCode: string
  }

  export type CabinetSizeModuleSizeUpdateManyMutationInput = {

  }

  export type CabinetSizeModuleSizeUncheckedUpdateManyInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ScreenTypeOptionListRelationFilter = {
    every?: ScreenTypeOptionWhereInput
    some?: ScreenTypeOptionWhereInput
    none?: ScreenTypeOptionWhereInput
  }

  export type ScreenTypeControlTypeListRelationFilter = {
    every?: ScreenTypeControlTypeWhereInput
    some?: ScreenTypeControlTypeWhereInput
    none?: ScreenTypeControlTypeWhereInput
  }

  export type ScreenTypeSensorListRelationFilter = {
    every?: ScreenTypeSensorWhereInput
    some?: ScreenTypeSensorWhereInput
    none?: ScreenTypeSensorWhereInput
  }

  export type ScreenTypeOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScreenTypeControlTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScreenTypeSensorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScreenTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScreenTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ScreenTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScreenTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScreenTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CabinetMaterialListRelationFilter = {
    every?: CabinetMaterialWhereInput
    some?: CabinetMaterialWhereInput
    none?: CabinetMaterialWhereInput
  }

  export type CabinetMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CabinetLocationListRelationFilter = {
    every?: CabinetLocationWhereInput
    some?: CabinetLocationWhereInput
    none?: CabinetLocationWhereInput
  }

  export type ModuleLocationListRelationFilter = {
    every?: ModuleLocationWhereInput
    some?: ModuleLocationWhereInput
    none?: ModuleLocationWhereInput
  }

  export type CabinetLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CabinetPlacementListRelationFilter = {
    every?: CabinetPlacementWhereInput
    some?: CabinetPlacementWhereInput
    none?: CabinetPlacementWhereInput
  }

  export type CabinetPlacementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlacementAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlacementMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlacementMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlacementSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModuleOptionListRelationFilter = {
    every?: ModuleOptionWhereInput
    some?: ModuleOptionWhereInput
    none?: ModuleOptionWhereInput
  }

  export type ModuleOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SensorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SensorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SensorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SensorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SensorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ControlTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ControlTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CabinetPitchListRelationFilter = {
    every?: CabinetPitchWhereInput
    some?: CabinetPitchWhereInput
    none?: CabinetPitchWhereInput
  }

  export type ModulePitchListRelationFilter = {
    every?: ModulePitchWhereInput
    some?: ModulePitchWhereInput
    none?: ModulePitchWhereInput
  }

  export type CabinetPitchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModulePitchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PitchCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    pitchValue?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PitchAvgOrderByAggregateInput = {
    id?: SortOrder
    pitchValue?: SortOrder
  }

  export type PitchMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    pitchValue?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PitchMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    pitchValue?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PitchSumOrderByAggregateInput = {
    id?: SortOrder
    pitchValue?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ModuleRefreshRateListRelationFilter = {
    every?: ModuleRefreshRateWhereInput
    some?: ModuleRefreshRateWhereInput
    none?: ModuleRefreshRateWhereInput
  }

  export type ModuleRefreshRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshRateCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshRateAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type RefreshRateMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshRateMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshRateSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type ModuleBrightnessListRelationFilter = {
    every?: ModuleBrightnessWhereInput
    some?: ModuleBrightnessWhereInput
    none?: ModuleBrightnessWhereInput
  }

  export type ModuleBrightnessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrightnessCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrightnessAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type BrightnessMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrightnessMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrightnessSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type CabinetManufacturerListRelationFilter = {
    every?: CabinetManufacturerWhereInput
    some?: CabinetManufacturerWhereInput
    none?: CabinetManufacturerWhereInput
  }

  export type ModuleManufacturerListRelationFilter = {
    every?: ModuleManufacturerWhereInput
    some?: ModuleManufacturerWhereInput
    none?: ModuleManufacturerWhereInput
  }

  export type CabinetManufacturerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleManufacturerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManufacturerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManufacturerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CabinetSupplierListRelationFilter = {
    every?: CabinetSupplierWhereInput
    some?: CabinetSupplierWhereInput
    none?: CabinetSupplierWhereInput
  }

  export type ItemSupplierListRelationFilter = {
    every?: ItemSupplierWhereInput
    some?: ItemSupplierWhereInput
    none?: ItemSupplierWhereInput
  }

  export type CabinetSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IpProtectionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    protectionSolid?: SortOrder
    protectionWater?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IpProtectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IpProtectionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    protectionSolid?: SortOrder
    protectionWater?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IpProtectionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    protectionSolid?: SortOrder
    protectionWater?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IpProtectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModuleModuleSizeListRelationFilter = {
    every?: ModuleModuleSizeWhereInput
    some?: ModuleModuleSizeWhereInput
    none?: ModuleModuleSizeWhereInput
  }

  export type CabinetSizeModuleSizeListRelationFilter = {
    every?: CabinetSizeModuleSizeWhereInput
    some?: CabinetSizeModuleSizeWhereInput
    none?: CabinetSizeModuleSizeWhereInput
  }

  export type ModuleModuleSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetSizeModuleSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleSizeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type ModuleSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSizeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSizeSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type CabinetCabinetSizeListRelationFilter = {
    every?: CabinetCabinetSizeWhereInput
    some?: CabinetCabinetSizeWhereInput
    none?: CabinetCabinetSizeWhereInput
  }

  export type CabinetCabinetSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetSizeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type CabinetSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetSizeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetSizeSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type ItemCategorySubcategoryListRelationFilter = {
    every?: ItemCategorySubcategoryWhereInput
    some?: ItemCategorySubcategoryWhereInput
    none?: ItemCategorySubcategoryWhereInput
  }

  export type ItemCategoryRelationListRelationFilter = {
    every?: ItemCategoryRelationWhereInput
    some?: ItemCategoryRelationWhereInput
    none?: ItemCategoryRelationWhereInput
  }

  export type CabinetCategoryListRelationFilter = {
    every?: CabinetCategoryWhereInput
    some?: CabinetCategoryWhereInput
    none?: CabinetCategoryWhereInput
  }

  export type ModuleCategoryListRelationFilter = {
    every?: ModuleCategoryWhereInput
    some?: ModuleCategoryWhereInput
    none?: ModuleCategoryWhereInput
  }

  export type ItemCategorySubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemSubcategoryRelationListRelationFilter = {
    every?: ItemSubcategoryRelationWhereInput
    some?: ItemSubcategoryRelationWhereInput
    none?: ItemSubcategoryRelationWhereInput
  }

  export type CabinetSubcategoryListRelationFilter = {
    every?: CabinetSubcategoryWhereInput
    some?: CabinetSubcategoryWhereInput
    none?: CabinetSubcategoryWhereInput
  }

  export type ModuleSubcategoryListRelationFilter = {
    every?: ModuleSubcategoryWhereInput
    some?: ModuleSubcategoryWhereInput
    none?: ModuleSubcategoryWhereInput
  }

  export type ItemSubcategoryRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetSubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleSubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemSubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSubcategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemSubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSubcategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CabinetItemComponentListRelationFilter = {
    every?: CabinetItemComponentWhereInput
    some?: CabinetItemComponentWhereInput
    none?: CabinetItemComponentWhereInput
  }

  export type CabinetPriceListRelationFilter = {
    every?: CabinetPriceWhereInput
    some?: CabinetPriceWhereInput
    none?: CabinetPriceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CabinetItemComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CabinetMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ModuleItemComponentListRelationFilter = {
    every?: ModuleItemComponentWhereInput
    some?: ModuleItemComponentWhereInput
    none?: ModuleItemComponentWhereInput
  }

  export type ModulePriceListRelationFilter = {
    every?: ModulePriceWhereInput
    some?: ModulePriceWhereInput
    none?: ModulePriceWhereInput
  }

  export type ModuleItemComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModulePriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    moduleOption?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    moduleOption?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    moduleOption?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemPriceListRelationFilter = {
    every?: ItemPriceWhereInput
    some?: ItemPriceWhereInput
    none?: ItemPriceWhereInput
  }

  export type ItemPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    active?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ScreenTypeScalarRelationFilter = {
    is?: ScreenTypeWhereInput
    isNot?: ScreenTypeWhereInput
  }

  export type OptionScalarRelationFilter = {
    is?: OptionWhereInput
    isNot?: OptionWhereInput
  }

  export type ScreenTypeOptionScreenTypeCodeOptionCodeCompoundUniqueInput = {
    screenTypeCode: string
    optionCode: string
  }

  export type ScreenTypeOptionCountOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ScreenTypeOptionMaxOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ScreenTypeOptionMinOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ControlTypeScalarRelationFilter = {
    is?: ControlTypeWhereInput
    isNot?: ControlTypeWhereInput
  }

  export type ScreenTypeControlTypeScreenTypeCodeControlTypeCodeCompoundUniqueInput = {
    screenTypeCode: string
    controlTypeCode: string
  }

  export type ScreenTypeControlTypeCountOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    controlTypeCode?: SortOrder
  }

  export type ScreenTypeControlTypeMaxOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    controlTypeCode?: SortOrder
  }

  export type ScreenTypeControlTypeMinOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    controlTypeCode?: SortOrder
  }

  export type SensorScalarRelationFilter = {
    is?: SensorWhereInput
    isNot?: SensorWhereInput
  }

  export type ScreenTypeSensorScreenTypeCodeSensorCodeCompoundUniqueInput = {
    screenTypeCode: string
    sensorCode: string
  }

  export type ScreenTypeSensorCountOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    sensorCode?: SortOrder
  }

  export type ScreenTypeSensorMaxOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    sensorCode?: SortOrder
  }

  export type ScreenTypeSensorMinOrderByAggregateInput = {
    screenTypeCode?: SortOrder
    sensorCode?: SortOrder
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemCategoryScalarRelationFilter = {
    is?: ItemCategoryWhereInput
    isNot?: ItemCategoryWhereInput
  }

  export type ItemCategoryRelationItemCodeCategoryCodeCompoundUniqueInput = {
    itemCode: string
    categoryCode: string
  }

  export type ItemCategoryRelationCountOrderByAggregateInput = {
    itemCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ItemCategoryRelationMaxOrderByAggregateInput = {
    itemCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ItemCategoryRelationMinOrderByAggregateInput = {
    itemCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ItemSubcategoryScalarRelationFilter = {
    is?: ItemSubcategoryWhereInput
    isNot?: ItemSubcategoryWhereInput
  }

  export type ItemSubcategoryRelationItemCodeSubcategoryCodeCompoundUniqueInput = {
    itemCode: string
    subcategoryCode: string
  }

  export type ItemSubcategoryRelationCountOrderByAggregateInput = {
    itemCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ItemSubcategoryRelationMaxOrderByAggregateInput = {
    itemCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ItemSubcategoryRelationMinOrderByAggregateInput = {
    itemCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceCountOrderByAggregateInput = {
    itemCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ItemPriceAvgOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ItemPriceMaxOrderByAggregateInput = {
    itemCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ItemPriceMinOrderByAggregateInput = {
    itemCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ItemPriceSumOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type ItemSupplierItemCodeSupplierCodeCompoundUniqueInput = {
    itemCode: string
    supplierCode: string
  }

  export type ItemSupplierCountOrderByAggregateInput = {
    itemCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type ItemSupplierMaxOrderByAggregateInput = {
    itemCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type ItemSupplierMinOrderByAggregateInput = {
    itemCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type ItemCategorySubcategoryCategoryCodeSubcategoryCodeCompoundUniqueInput = {
    categoryCode: string
    subcategoryCode: string
  }

  export type ItemCategorySubcategoryCountOrderByAggregateInput = {
    categoryCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ItemCategorySubcategoryMaxOrderByAggregateInput = {
    categoryCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ItemCategorySubcategoryMinOrderByAggregateInput = {
    categoryCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type CabinetScalarRelationFilter = {
    is?: CabinetWhereInput
    isNot?: CabinetWhereInput
  }

  export type CabinetCategoryCabinetCodeCategoryCodeCompoundUniqueInput = {
    cabinetCode: string
    categoryCode: string
  }

  export type CabinetCategoryCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type CabinetCategoryMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type CabinetCategoryMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type CabinetSubcategoryCabinetCodeSubcategoryCodeCompoundUniqueInput = {
    cabinetCode: string
    subcategoryCode: string
  }

  export type CabinetSubcategoryCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type CabinetSubcategoryMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type CabinetSubcategoryMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type CabinetLocationCabinetCodeLocationCodeCompoundUniqueInput = {
    cabinetCode: string
    locationCode: string
  }

  export type CabinetLocationCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    locationCode?: SortOrder
  }

  export type CabinetLocationMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    locationCode?: SortOrder
  }

  export type CabinetLocationMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    locationCode?: SortOrder
  }

  export type PlacementScalarRelationFilter = {
    is?: PlacementWhereInput
    isNot?: PlacementWhereInput
  }

  export type CabinetPlacementCabinetCodePlacementCodeCompoundUniqueInput = {
    cabinetCode: string
    placementCode: string
  }

  export type CabinetPlacementCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    placementCode?: SortOrder
  }

  export type CabinetPlacementMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    placementCode?: SortOrder
  }

  export type CabinetPlacementMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    placementCode?: SortOrder
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type CabinetMaterialCabinetCodeMaterialCodeCompoundUniqueInput = {
    cabinetCode: string
    materialCode: string
  }

  export type CabinetMaterialCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    materialCode?: SortOrder
  }

  export type CabinetMaterialMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    materialCode?: SortOrder
  }

  export type CabinetMaterialMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    materialCode?: SortOrder
  }

  export type CabinetSizeScalarRelationFilter = {
    is?: CabinetSizeWhereInput
    isNot?: CabinetSizeWhereInput
  }

  export type CabinetCabinetSizeCabinetCodeCabinetSizeCodeCompoundUniqueInput = {
    cabinetCode: string
    cabinetSizeCode: string
  }

  export type CabinetCabinetSizeCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    cabinetSizeCode?: SortOrder
  }

  export type CabinetCabinetSizeMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    cabinetSizeCode?: SortOrder
  }

  export type CabinetCabinetSizeMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    cabinetSizeCode?: SortOrder
  }

  export type PitchScalarRelationFilter = {
    is?: PitchWhereInput
    isNot?: PitchWhereInput
  }

  export type CabinetPitchCabinetCodePitchCodeCompoundUniqueInput = {
    cabinetCode: string
    pitchCode: string
  }

  export type CabinetPitchCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type CabinetPitchMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type CabinetPitchMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type ManufacturerScalarRelationFilter = {
    is?: ManufacturerWhereInput
    isNot?: ManufacturerWhereInput
  }

  export type CabinetManufacturerCabinetCodeManufacturerCodeCompoundUniqueInput = {
    cabinetCode: string
    manufacturerCode: string
  }

  export type CabinetManufacturerCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type CabinetManufacturerMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type CabinetManufacturerMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type CabinetSupplierCabinetCodeSupplierCodeCompoundUniqueInput = {
    cabinetCode: string
    supplierCode: string
  }

  export type CabinetSupplierCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type CabinetSupplierMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type CabinetSupplierMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    supplierCode?: SortOrder
  }

  export type CabinetItemComponentCabinetCodeItemCodeCompoundUniqueInput = {
    cabinetCode: string
    itemCode: string
  }

  export type CabinetItemComponentCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type CabinetItemComponentAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CabinetItemComponentMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type CabinetItemComponentMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type CabinetItemComponentSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CabinetPriceCountOrderByAggregateInput = {
    cabinetCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type CabinetPriceAvgOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type CabinetPriceMaxOrderByAggregateInput = {
    cabinetCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type CabinetPriceMinOrderByAggregateInput = {
    cabinetCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type CabinetPriceSumOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ModuleCategoryModuleCodeCategoryCodeCompoundUniqueInput = {
    moduleCode: string
    categoryCode: string
  }

  export type ModuleCategoryCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ModuleCategoryMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ModuleCategoryMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    categoryCode?: SortOrder
  }

  export type ModuleSubcategoryModuleCodeSubcategoryCodeCompoundUniqueInput = {
    moduleCode: string
    subcategoryCode: string
  }

  export type ModuleSubcategoryCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ModuleSubcategoryMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ModuleSubcategoryMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    subcategoryCode?: SortOrder
  }

  export type ModuleLocationModuleCodeLocationCodeCompoundUniqueInput = {
    moduleCode: string
    locationCode: string
  }

  export type ModuleLocationCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    locationCode?: SortOrder
  }

  export type ModuleLocationMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    locationCode?: SortOrder
  }

  export type ModuleLocationMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    locationCode?: SortOrder
  }

  export type RefreshRateScalarRelationFilter = {
    is?: RefreshRateWhereInput
    isNot?: RefreshRateWhereInput
  }

  export type ModuleRefreshRateModuleCodeRefreshRateCodeCompoundUniqueInput = {
    moduleCode: string
    refreshRateCode: string
  }

  export type ModuleRefreshRateCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    refreshRateCode?: SortOrder
  }

  export type ModuleRefreshRateMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    refreshRateCode?: SortOrder
  }

  export type ModuleRefreshRateMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    refreshRateCode?: SortOrder
  }

  export type BrightnessScalarRelationFilter = {
    is?: BrightnessWhereInput
    isNot?: BrightnessWhereInput
  }

  export type ModuleBrightnessModuleCodeBrightnessCodeCompoundUniqueInput = {
    moduleCode: string
    brightnessCode: string
  }

  export type ModuleBrightnessCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    brightnessCode?: SortOrder
  }

  export type ModuleBrightnessMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    brightnessCode?: SortOrder
  }

  export type ModuleBrightnessMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    brightnessCode?: SortOrder
  }

  export type ModuleSizeScalarRelationFilter = {
    is?: ModuleSizeWhereInput
    isNot?: ModuleSizeWhereInput
  }

  export type ModuleModuleSizeModuleCodeModuleSizeCodeCompoundUniqueInput = {
    moduleCode: string
    moduleSizeCode: string
  }

  export type ModuleModuleSizeCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type ModuleModuleSizeMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type ModuleModuleSizeMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type ModulePitchModuleCodePitchCodeCompoundUniqueInput = {
    moduleCode: string
    pitchCode: string
  }

  export type ModulePitchCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type ModulePitchMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type ModulePitchMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    pitchCode?: SortOrder
  }

  export type ModuleManufacturerModuleCodeManufacturerCodeCompoundUniqueInput = {
    moduleCode: string
    manufacturerCode: string
  }

  export type ModuleManufacturerCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type ModuleManufacturerMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type ModuleManufacturerMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    manufacturerCode?: SortOrder
  }

  export type ModuleItemComponentModuleCodeItemCodeCompoundUniqueInput = {
    moduleCode: string
    itemCode: string
  }

  export type ModuleItemComponentCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type ModuleItemComponentAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ModuleItemComponentMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type ModuleItemComponentMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    itemCode?: SortOrder
    quantity?: SortOrder
  }

  export type ModuleItemComponentSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ModuleOptionModuleCodeOptionCodeCompoundUniqueInput = {
    moduleCode: string
    optionCode: string
  }

  export type ModuleOptionCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ModuleOptionMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ModuleOptionMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    optionCode?: SortOrder
  }

  export type ModulePriceCountOrderByAggregateInput = {
    moduleCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ModulePriceAvgOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ModulePriceMaxOrderByAggregateInput = {
    moduleCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ModulePriceMinOrderByAggregateInput = {
    moduleCode?: SortOrder
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type ModulePriceSumOrderByAggregateInput = {
    priceUsd?: SortOrder
    priceRub?: SortOrder
  }

  export type CabinetSizeModuleSizeCabinetSizeCodeModuleSizeCodeCompoundUniqueInput = {
    cabinetSizeCode: string
    moduleSizeCode: string
  }

  export type CabinetSizeModuleSizeCountOrderByAggregateInput = {
    cabinetSizeCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type CabinetSizeModuleSizeMaxOrderByAggregateInput = {
    cabinetSizeCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type CabinetSizeModuleSizeMinOrderByAggregateInput = {
    cabinetSizeCode?: SortOrder
    moduleSizeCode?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ScreenTypeOptionCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput> | ScreenTypeOptionCreateWithoutScreenTypeInput[] | ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput | ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeOptionCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
  }

  export type ScreenTypeControlTypeCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput> | ScreenTypeControlTypeCreateWithoutScreenTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
  }

  export type ScreenTypeSensorCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput> | ScreenTypeSensorCreateWithoutScreenTypeInput[] | ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput | ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeSensorCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
  }

  export type ScreenTypeOptionUncheckedCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput> | ScreenTypeOptionCreateWithoutScreenTypeInput[] | ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput | ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeOptionCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
  }

  export type ScreenTypeControlTypeUncheckedCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput> | ScreenTypeControlTypeCreateWithoutScreenTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
  }

  export type ScreenTypeSensorUncheckedCreateNestedManyWithoutScreenTypeInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput> | ScreenTypeSensorCreateWithoutScreenTypeInput[] | ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput | ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput[]
    createMany?: ScreenTypeSensorCreateManyScreenTypeInputEnvelope
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ScreenTypeOptionUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput> | ScreenTypeOptionCreateWithoutScreenTypeInput[] | ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput | ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeOptionUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeOptionUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeOptionCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    disconnect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    delete?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    update?: ScreenTypeOptionUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeOptionUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeOptionUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeOptionUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
  }

  export type ScreenTypeControlTypeUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput> | ScreenTypeControlTypeCreateWithoutScreenTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeControlTypeUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeControlTypeUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    disconnect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    delete?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    update?: ScreenTypeControlTypeUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeControlTypeUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeControlTypeUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeControlTypeUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
  }

  export type ScreenTypeSensorUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput> | ScreenTypeSensorCreateWithoutScreenTypeInput[] | ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput | ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeSensorUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeSensorUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeSensorCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    disconnect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    delete?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    update?: ScreenTypeSensorUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeSensorUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeSensorUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeSensorUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
  }

  export type ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput> | ScreenTypeOptionCreateWithoutScreenTypeInput[] | ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput | ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeOptionUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeOptionUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeOptionCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    disconnect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    delete?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    update?: ScreenTypeOptionUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeOptionUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeOptionUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeOptionUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
  }

  export type ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput> | ScreenTypeControlTypeCreateWithoutScreenTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeControlTypeUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeControlTypeUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    disconnect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    delete?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    update?: ScreenTypeControlTypeUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeControlTypeUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeControlTypeUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeControlTypeUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
  }

  export type ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeNestedInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput> | ScreenTypeSensorCreateWithoutScreenTypeInput[] | ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput | ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput[]
    upsert?: ScreenTypeSensorUpsertWithWhereUniqueWithoutScreenTypeInput | ScreenTypeSensorUpsertWithWhereUniqueWithoutScreenTypeInput[]
    createMany?: ScreenTypeSensorCreateManyScreenTypeInputEnvelope
    set?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    disconnect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    delete?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    update?: ScreenTypeSensorUpdateWithWhereUniqueWithoutScreenTypeInput | ScreenTypeSensorUpdateWithWhereUniqueWithoutScreenTypeInput[]
    updateMany?: ScreenTypeSensorUpdateManyWithWhereWithoutScreenTypeInput | ScreenTypeSensorUpdateManyWithWhereWithoutScreenTypeInput[]
    deleteMany?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
  }

  export type CabinetMaterialCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput> | CabinetMaterialCreateWithoutMaterialInput[] | CabinetMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutMaterialInput | CabinetMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: CabinetMaterialCreateManyMaterialInputEnvelope
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
  }

  export type CabinetMaterialUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput> | CabinetMaterialCreateWithoutMaterialInput[] | CabinetMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutMaterialInput | CabinetMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: CabinetMaterialCreateManyMaterialInputEnvelope
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
  }

  export type CabinetMaterialUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput> | CabinetMaterialCreateWithoutMaterialInput[] | CabinetMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutMaterialInput | CabinetMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: CabinetMaterialUpsertWithWhereUniqueWithoutMaterialInput | CabinetMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CabinetMaterialCreateManyMaterialInputEnvelope
    set?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    disconnect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    delete?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    update?: CabinetMaterialUpdateWithWhereUniqueWithoutMaterialInput | CabinetMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CabinetMaterialUpdateManyWithWhereWithoutMaterialInput | CabinetMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
  }

  export type CabinetMaterialUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput> | CabinetMaterialCreateWithoutMaterialInput[] | CabinetMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutMaterialInput | CabinetMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: CabinetMaterialUpsertWithWhereUniqueWithoutMaterialInput | CabinetMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CabinetMaterialCreateManyMaterialInputEnvelope
    set?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    disconnect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    delete?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    update?: CabinetMaterialUpdateWithWhereUniqueWithoutMaterialInput | CabinetMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CabinetMaterialUpdateManyWithWhereWithoutMaterialInput | CabinetMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
  }

  export type CabinetLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput> | CabinetLocationCreateWithoutLocationInput[] | CabinetLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutLocationInput | CabinetLocationCreateOrConnectWithoutLocationInput[]
    createMany?: CabinetLocationCreateManyLocationInputEnvelope
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
  }

  export type ModuleLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput> | ModuleLocationCreateWithoutLocationInput[] | ModuleLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutLocationInput | ModuleLocationCreateOrConnectWithoutLocationInput[]
    createMany?: ModuleLocationCreateManyLocationInputEnvelope
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
  }

  export type CabinetLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput> | CabinetLocationCreateWithoutLocationInput[] | CabinetLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutLocationInput | CabinetLocationCreateOrConnectWithoutLocationInput[]
    createMany?: CabinetLocationCreateManyLocationInputEnvelope
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
  }

  export type ModuleLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput> | ModuleLocationCreateWithoutLocationInput[] | ModuleLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutLocationInput | ModuleLocationCreateOrConnectWithoutLocationInput[]
    createMany?: ModuleLocationCreateManyLocationInputEnvelope
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
  }

  export type CabinetLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput> | CabinetLocationCreateWithoutLocationInput[] | CabinetLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutLocationInput | CabinetLocationCreateOrConnectWithoutLocationInput[]
    upsert?: CabinetLocationUpsertWithWhereUniqueWithoutLocationInput | CabinetLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CabinetLocationCreateManyLocationInputEnvelope
    set?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    disconnect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    delete?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    update?: CabinetLocationUpdateWithWhereUniqueWithoutLocationInput | CabinetLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CabinetLocationUpdateManyWithWhereWithoutLocationInput | CabinetLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
  }

  export type ModuleLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput> | ModuleLocationCreateWithoutLocationInput[] | ModuleLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutLocationInput | ModuleLocationCreateOrConnectWithoutLocationInput[]
    upsert?: ModuleLocationUpsertWithWhereUniqueWithoutLocationInput | ModuleLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ModuleLocationCreateManyLocationInputEnvelope
    set?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    disconnect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    delete?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    update?: ModuleLocationUpdateWithWhereUniqueWithoutLocationInput | ModuleLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ModuleLocationUpdateManyWithWhereWithoutLocationInput | ModuleLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
  }

  export type CabinetLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput> | CabinetLocationCreateWithoutLocationInput[] | CabinetLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutLocationInput | CabinetLocationCreateOrConnectWithoutLocationInput[]
    upsert?: CabinetLocationUpsertWithWhereUniqueWithoutLocationInput | CabinetLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CabinetLocationCreateManyLocationInputEnvelope
    set?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    disconnect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    delete?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    update?: CabinetLocationUpdateWithWhereUniqueWithoutLocationInput | CabinetLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CabinetLocationUpdateManyWithWhereWithoutLocationInput | CabinetLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
  }

  export type ModuleLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput> | ModuleLocationCreateWithoutLocationInput[] | ModuleLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutLocationInput | ModuleLocationCreateOrConnectWithoutLocationInput[]
    upsert?: ModuleLocationUpsertWithWhereUniqueWithoutLocationInput | ModuleLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ModuleLocationCreateManyLocationInputEnvelope
    set?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    disconnect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    delete?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    update?: ModuleLocationUpdateWithWhereUniqueWithoutLocationInput | ModuleLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ModuleLocationUpdateManyWithWhereWithoutLocationInput | ModuleLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
  }

  export type CabinetPlacementCreateNestedManyWithoutPlacementInput = {
    create?: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput> | CabinetPlacementCreateWithoutPlacementInput[] | CabinetPlacementUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutPlacementInput | CabinetPlacementCreateOrConnectWithoutPlacementInput[]
    createMany?: CabinetPlacementCreateManyPlacementInputEnvelope
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
  }

  export type CabinetPlacementUncheckedCreateNestedManyWithoutPlacementInput = {
    create?: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput> | CabinetPlacementCreateWithoutPlacementInput[] | CabinetPlacementUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutPlacementInput | CabinetPlacementCreateOrConnectWithoutPlacementInput[]
    createMany?: CabinetPlacementCreateManyPlacementInputEnvelope
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
  }

  export type CabinetPlacementUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput> | CabinetPlacementCreateWithoutPlacementInput[] | CabinetPlacementUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutPlacementInput | CabinetPlacementCreateOrConnectWithoutPlacementInput[]
    upsert?: CabinetPlacementUpsertWithWhereUniqueWithoutPlacementInput | CabinetPlacementUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: CabinetPlacementCreateManyPlacementInputEnvelope
    set?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    disconnect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    delete?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    update?: CabinetPlacementUpdateWithWhereUniqueWithoutPlacementInput | CabinetPlacementUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: CabinetPlacementUpdateManyWithWhereWithoutPlacementInput | CabinetPlacementUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
  }

  export type CabinetPlacementUncheckedUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput> | CabinetPlacementCreateWithoutPlacementInput[] | CabinetPlacementUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutPlacementInput | CabinetPlacementCreateOrConnectWithoutPlacementInput[]
    upsert?: CabinetPlacementUpsertWithWhereUniqueWithoutPlacementInput | CabinetPlacementUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: CabinetPlacementCreateManyPlacementInputEnvelope
    set?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    disconnect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    delete?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    update?: CabinetPlacementUpdateWithWhereUniqueWithoutPlacementInput | CabinetPlacementUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: CabinetPlacementUpdateManyWithWhereWithoutPlacementInput | CabinetPlacementUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
  }

  export type ScreenTypeOptionCreateNestedManyWithoutOptionInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput> | ScreenTypeOptionCreateWithoutOptionInput[] | ScreenTypeOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutOptionInput | ScreenTypeOptionCreateOrConnectWithoutOptionInput[]
    createMany?: ScreenTypeOptionCreateManyOptionInputEnvelope
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
  }

  export type ModuleOptionCreateNestedManyWithoutOptionInput = {
    create?: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput> | ModuleOptionCreateWithoutOptionInput[] | ModuleOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutOptionInput | ModuleOptionCreateOrConnectWithoutOptionInput[]
    createMany?: ModuleOptionCreateManyOptionInputEnvelope
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
  }

  export type ScreenTypeOptionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput> | ScreenTypeOptionCreateWithoutOptionInput[] | ScreenTypeOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutOptionInput | ScreenTypeOptionCreateOrConnectWithoutOptionInput[]
    createMany?: ScreenTypeOptionCreateManyOptionInputEnvelope
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
  }

  export type ModuleOptionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput> | ModuleOptionCreateWithoutOptionInput[] | ModuleOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutOptionInput | ModuleOptionCreateOrConnectWithoutOptionInput[]
    createMany?: ModuleOptionCreateManyOptionInputEnvelope
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
  }

  export type ScreenTypeOptionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput> | ScreenTypeOptionCreateWithoutOptionInput[] | ScreenTypeOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutOptionInput | ScreenTypeOptionCreateOrConnectWithoutOptionInput[]
    upsert?: ScreenTypeOptionUpsertWithWhereUniqueWithoutOptionInput | ScreenTypeOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ScreenTypeOptionCreateManyOptionInputEnvelope
    set?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    disconnect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    delete?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    update?: ScreenTypeOptionUpdateWithWhereUniqueWithoutOptionInput | ScreenTypeOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ScreenTypeOptionUpdateManyWithWhereWithoutOptionInput | ScreenTypeOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
  }

  export type ModuleOptionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput> | ModuleOptionCreateWithoutOptionInput[] | ModuleOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutOptionInput | ModuleOptionCreateOrConnectWithoutOptionInput[]
    upsert?: ModuleOptionUpsertWithWhereUniqueWithoutOptionInput | ModuleOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ModuleOptionCreateManyOptionInputEnvelope
    set?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    disconnect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    delete?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    update?: ModuleOptionUpdateWithWhereUniqueWithoutOptionInput | ModuleOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ModuleOptionUpdateManyWithWhereWithoutOptionInput | ModuleOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
  }

  export type ScreenTypeOptionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput> | ScreenTypeOptionCreateWithoutOptionInput[] | ScreenTypeOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ScreenTypeOptionCreateOrConnectWithoutOptionInput | ScreenTypeOptionCreateOrConnectWithoutOptionInput[]
    upsert?: ScreenTypeOptionUpsertWithWhereUniqueWithoutOptionInput | ScreenTypeOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ScreenTypeOptionCreateManyOptionInputEnvelope
    set?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    disconnect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    delete?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    connect?: ScreenTypeOptionWhereUniqueInput | ScreenTypeOptionWhereUniqueInput[]
    update?: ScreenTypeOptionUpdateWithWhereUniqueWithoutOptionInput | ScreenTypeOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ScreenTypeOptionUpdateManyWithWhereWithoutOptionInput | ScreenTypeOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
  }

  export type ModuleOptionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput> | ModuleOptionCreateWithoutOptionInput[] | ModuleOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutOptionInput | ModuleOptionCreateOrConnectWithoutOptionInput[]
    upsert?: ModuleOptionUpsertWithWhereUniqueWithoutOptionInput | ModuleOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ModuleOptionCreateManyOptionInputEnvelope
    set?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    disconnect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    delete?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    update?: ModuleOptionUpdateWithWhereUniqueWithoutOptionInput | ModuleOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ModuleOptionUpdateManyWithWhereWithoutOptionInput | ModuleOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
  }

  export type ScreenTypeSensorCreateNestedManyWithoutSensorInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput> | ScreenTypeSensorCreateWithoutSensorInput[] | ScreenTypeSensorUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutSensorInput | ScreenTypeSensorCreateOrConnectWithoutSensorInput[]
    createMany?: ScreenTypeSensorCreateManySensorInputEnvelope
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
  }

  export type ScreenTypeSensorUncheckedCreateNestedManyWithoutSensorInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput> | ScreenTypeSensorCreateWithoutSensorInput[] | ScreenTypeSensorUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutSensorInput | ScreenTypeSensorCreateOrConnectWithoutSensorInput[]
    createMany?: ScreenTypeSensorCreateManySensorInputEnvelope
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
  }

  export type ScreenTypeSensorUpdateManyWithoutSensorNestedInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput> | ScreenTypeSensorCreateWithoutSensorInput[] | ScreenTypeSensorUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutSensorInput | ScreenTypeSensorCreateOrConnectWithoutSensorInput[]
    upsert?: ScreenTypeSensorUpsertWithWhereUniqueWithoutSensorInput | ScreenTypeSensorUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: ScreenTypeSensorCreateManySensorInputEnvelope
    set?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    disconnect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    delete?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    update?: ScreenTypeSensorUpdateWithWhereUniqueWithoutSensorInput | ScreenTypeSensorUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: ScreenTypeSensorUpdateManyWithWhereWithoutSensorInput | ScreenTypeSensorUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
  }

  export type ScreenTypeSensorUncheckedUpdateManyWithoutSensorNestedInput = {
    create?: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput> | ScreenTypeSensorCreateWithoutSensorInput[] | ScreenTypeSensorUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: ScreenTypeSensorCreateOrConnectWithoutSensorInput | ScreenTypeSensorCreateOrConnectWithoutSensorInput[]
    upsert?: ScreenTypeSensorUpsertWithWhereUniqueWithoutSensorInput | ScreenTypeSensorUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: ScreenTypeSensorCreateManySensorInputEnvelope
    set?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    disconnect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    delete?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    connect?: ScreenTypeSensorWhereUniqueInput | ScreenTypeSensorWhereUniqueInput[]
    update?: ScreenTypeSensorUpdateWithWhereUniqueWithoutSensorInput | ScreenTypeSensorUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: ScreenTypeSensorUpdateManyWithWhereWithoutSensorInput | ScreenTypeSensorUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
  }

  export type ScreenTypeControlTypeCreateNestedManyWithoutControlTypeInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput> | ScreenTypeControlTypeCreateWithoutControlTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyControlTypeInputEnvelope
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
  }

  export type ScreenTypeControlTypeUncheckedCreateNestedManyWithoutControlTypeInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput> | ScreenTypeControlTypeCreateWithoutControlTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyControlTypeInputEnvelope
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
  }

  export type ScreenTypeControlTypeUpdateManyWithoutControlTypeNestedInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput> | ScreenTypeControlTypeCreateWithoutControlTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput[]
    upsert?: ScreenTypeControlTypeUpsertWithWhereUniqueWithoutControlTypeInput | ScreenTypeControlTypeUpsertWithWhereUniqueWithoutControlTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyControlTypeInputEnvelope
    set?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    disconnect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    delete?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    update?: ScreenTypeControlTypeUpdateWithWhereUniqueWithoutControlTypeInput | ScreenTypeControlTypeUpdateWithWhereUniqueWithoutControlTypeInput[]
    updateMany?: ScreenTypeControlTypeUpdateManyWithWhereWithoutControlTypeInput | ScreenTypeControlTypeUpdateManyWithWhereWithoutControlTypeInput[]
    deleteMany?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
  }

  export type ScreenTypeControlTypeUncheckedUpdateManyWithoutControlTypeNestedInput = {
    create?: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput> | ScreenTypeControlTypeCreateWithoutControlTypeInput[] | ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput[]
    connectOrCreate?: ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput | ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput[]
    upsert?: ScreenTypeControlTypeUpsertWithWhereUniqueWithoutControlTypeInput | ScreenTypeControlTypeUpsertWithWhereUniqueWithoutControlTypeInput[]
    createMany?: ScreenTypeControlTypeCreateManyControlTypeInputEnvelope
    set?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    disconnect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    delete?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    connect?: ScreenTypeControlTypeWhereUniqueInput | ScreenTypeControlTypeWhereUniqueInput[]
    update?: ScreenTypeControlTypeUpdateWithWhereUniqueWithoutControlTypeInput | ScreenTypeControlTypeUpdateWithWhereUniqueWithoutControlTypeInput[]
    updateMany?: ScreenTypeControlTypeUpdateManyWithWhereWithoutControlTypeInput | ScreenTypeControlTypeUpdateManyWithWhereWithoutControlTypeInput[]
    deleteMany?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
  }

  export type CabinetPitchCreateNestedManyWithoutPitchInput = {
    create?: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput> | CabinetPitchCreateWithoutPitchInput[] | CabinetPitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutPitchInput | CabinetPitchCreateOrConnectWithoutPitchInput[]
    createMany?: CabinetPitchCreateManyPitchInputEnvelope
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
  }

  export type ModulePitchCreateNestedManyWithoutPitchInput = {
    create?: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput> | ModulePitchCreateWithoutPitchInput[] | ModulePitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutPitchInput | ModulePitchCreateOrConnectWithoutPitchInput[]
    createMany?: ModulePitchCreateManyPitchInputEnvelope
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
  }

  export type CabinetPitchUncheckedCreateNestedManyWithoutPitchInput = {
    create?: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput> | CabinetPitchCreateWithoutPitchInput[] | CabinetPitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutPitchInput | CabinetPitchCreateOrConnectWithoutPitchInput[]
    createMany?: CabinetPitchCreateManyPitchInputEnvelope
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
  }

  export type ModulePitchUncheckedCreateNestedManyWithoutPitchInput = {
    create?: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput> | ModulePitchCreateWithoutPitchInput[] | ModulePitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutPitchInput | ModulePitchCreateOrConnectWithoutPitchInput[]
    createMany?: ModulePitchCreateManyPitchInputEnvelope
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CabinetPitchUpdateManyWithoutPitchNestedInput = {
    create?: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput> | CabinetPitchCreateWithoutPitchInput[] | CabinetPitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutPitchInput | CabinetPitchCreateOrConnectWithoutPitchInput[]
    upsert?: CabinetPitchUpsertWithWhereUniqueWithoutPitchInput | CabinetPitchUpsertWithWhereUniqueWithoutPitchInput[]
    createMany?: CabinetPitchCreateManyPitchInputEnvelope
    set?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    disconnect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    delete?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    update?: CabinetPitchUpdateWithWhereUniqueWithoutPitchInput | CabinetPitchUpdateWithWhereUniqueWithoutPitchInput[]
    updateMany?: CabinetPitchUpdateManyWithWhereWithoutPitchInput | CabinetPitchUpdateManyWithWhereWithoutPitchInput[]
    deleteMany?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
  }

  export type ModulePitchUpdateManyWithoutPitchNestedInput = {
    create?: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput> | ModulePitchCreateWithoutPitchInput[] | ModulePitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutPitchInput | ModulePitchCreateOrConnectWithoutPitchInput[]
    upsert?: ModulePitchUpsertWithWhereUniqueWithoutPitchInput | ModulePitchUpsertWithWhereUniqueWithoutPitchInput[]
    createMany?: ModulePitchCreateManyPitchInputEnvelope
    set?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    disconnect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    delete?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    update?: ModulePitchUpdateWithWhereUniqueWithoutPitchInput | ModulePitchUpdateWithWhereUniqueWithoutPitchInput[]
    updateMany?: ModulePitchUpdateManyWithWhereWithoutPitchInput | ModulePitchUpdateManyWithWhereWithoutPitchInput[]
    deleteMany?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
  }

  export type CabinetPitchUncheckedUpdateManyWithoutPitchNestedInput = {
    create?: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput> | CabinetPitchCreateWithoutPitchInput[] | CabinetPitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutPitchInput | CabinetPitchCreateOrConnectWithoutPitchInput[]
    upsert?: CabinetPitchUpsertWithWhereUniqueWithoutPitchInput | CabinetPitchUpsertWithWhereUniqueWithoutPitchInput[]
    createMany?: CabinetPitchCreateManyPitchInputEnvelope
    set?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    disconnect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    delete?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    update?: CabinetPitchUpdateWithWhereUniqueWithoutPitchInput | CabinetPitchUpdateWithWhereUniqueWithoutPitchInput[]
    updateMany?: CabinetPitchUpdateManyWithWhereWithoutPitchInput | CabinetPitchUpdateManyWithWhereWithoutPitchInput[]
    deleteMany?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
  }

  export type ModulePitchUncheckedUpdateManyWithoutPitchNestedInput = {
    create?: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput> | ModulePitchCreateWithoutPitchInput[] | ModulePitchUncheckedCreateWithoutPitchInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutPitchInput | ModulePitchCreateOrConnectWithoutPitchInput[]
    upsert?: ModulePitchUpsertWithWhereUniqueWithoutPitchInput | ModulePitchUpsertWithWhereUniqueWithoutPitchInput[]
    createMany?: ModulePitchCreateManyPitchInputEnvelope
    set?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    disconnect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    delete?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    update?: ModulePitchUpdateWithWhereUniqueWithoutPitchInput | ModulePitchUpdateWithWhereUniqueWithoutPitchInput[]
    updateMany?: ModulePitchUpdateManyWithWhereWithoutPitchInput | ModulePitchUpdateManyWithWhereWithoutPitchInput[]
    deleteMany?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
  }

  export type ModuleRefreshRateCreateNestedManyWithoutRefreshRateInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput> | ModuleRefreshRateCreateWithoutRefreshRateInput[] | ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput | ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput[]
    createMany?: ModuleRefreshRateCreateManyRefreshRateInputEnvelope
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
  }

  export type ModuleRefreshRateUncheckedCreateNestedManyWithoutRefreshRateInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput> | ModuleRefreshRateCreateWithoutRefreshRateInput[] | ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput | ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput[]
    createMany?: ModuleRefreshRateCreateManyRefreshRateInputEnvelope
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
  }

  export type ModuleRefreshRateUpdateManyWithoutRefreshRateNestedInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput> | ModuleRefreshRateCreateWithoutRefreshRateInput[] | ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput | ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput[]
    upsert?: ModuleRefreshRateUpsertWithWhereUniqueWithoutRefreshRateInput | ModuleRefreshRateUpsertWithWhereUniqueWithoutRefreshRateInput[]
    createMany?: ModuleRefreshRateCreateManyRefreshRateInputEnvelope
    set?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    disconnect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    delete?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    update?: ModuleRefreshRateUpdateWithWhereUniqueWithoutRefreshRateInput | ModuleRefreshRateUpdateWithWhereUniqueWithoutRefreshRateInput[]
    updateMany?: ModuleRefreshRateUpdateManyWithWhereWithoutRefreshRateInput | ModuleRefreshRateUpdateManyWithWhereWithoutRefreshRateInput[]
    deleteMany?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
  }

  export type ModuleRefreshRateUncheckedUpdateManyWithoutRefreshRateNestedInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput> | ModuleRefreshRateCreateWithoutRefreshRateInput[] | ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput | ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput[]
    upsert?: ModuleRefreshRateUpsertWithWhereUniqueWithoutRefreshRateInput | ModuleRefreshRateUpsertWithWhereUniqueWithoutRefreshRateInput[]
    createMany?: ModuleRefreshRateCreateManyRefreshRateInputEnvelope
    set?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    disconnect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    delete?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    update?: ModuleRefreshRateUpdateWithWhereUniqueWithoutRefreshRateInput | ModuleRefreshRateUpdateWithWhereUniqueWithoutRefreshRateInput[]
    updateMany?: ModuleRefreshRateUpdateManyWithWhereWithoutRefreshRateInput | ModuleRefreshRateUpdateManyWithWhereWithoutRefreshRateInput[]
    deleteMany?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
  }

  export type ModuleBrightnessCreateNestedManyWithoutBrightnessInput = {
    create?: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput> | ModuleBrightnessCreateWithoutBrightnessInput[] | ModuleBrightnessUncheckedCreateWithoutBrightnessInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutBrightnessInput | ModuleBrightnessCreateOrConnectWithoutBrightnessInput[]
    createMany?: ModuleBrightnessCreateManyBrightnessInputEnvelope
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
  }

  export type ModuleBrightnessUncheckedCreateNestedManyWithoutBrightnessInput = {
    create?: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput> | ModuleBrightnessCreateWithoutBrightnessInput[] | ModuleBrightnessUncheckedCreateWithoutBrightnessInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutBrightnessInput | ModuleBrightnessCreateOrConnectWithoutBrightnessInput[]
    createMany?: ModuleBrightnessCreateManyBrightnessInputEnvelope
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
  }

  export type ModuleBrightnessUpdateManyWithoutBrightnessNestedInput = {
    create?: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput> | ModuleBrightnessCreateWithoutBrightnessInput[] | ModuleBrightnessUncheckedCreateWithoutBrightnessInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutBrightnessInput | ModuleBrightnessCreateOrConnectWithoutBrightnessInput[]
    upsert?: ModuleBrightnessUpsertWithWhereUniqueWithoutBrightnessInput | ModuleBrightnessUpsertWithWhereUniqueWithoutBrightnessInput[]
    createMany?: ModuleBrightnessCreateManyBrightnessInputEnvelope
    set?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    disconnect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    delete?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    update?: ModuleBrightnessUpdateWithWhereUniqueWithoutBrightnessInput | ModuleBrightnessUpdateWithWhereUniqueWithoutBrightnessInput[]
    updateMany?: ModuleBrightnessUpdateManyWithWhereWithoutBrightnessInput | ModuleBrightnessUpdateManyWithWhereWithoutBrightnessInput[]
    deleteMany?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
  }

  export type ModuleBrightnessUncheckedUpdateManyWithoutBrightnessNestedInput = {
    create?: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput> | ModuleBrightnessCreateWithoutBrightnessInput[] | ModuleBrightnessUncheckedCreateWithoutBrightnessInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutBrightnessInput | ModuleBrightnessCreateOrConnectWithoutBrightnessInput[]
    upsert?: ModuleBrightnessUpsertWithWhereUniqueWithoutBrightnessInput | ModuleBrightnessUpsertWithWhereUniqueWithoutBrightnessInput[]
    createMany?: ModuleBrightnessCreateManyBrightnessInputEnvelope
    set?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    disconnect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    delete?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    update?: ModuleBrightnessUpdateWithWhereUniqueWithoutBrightnessInput | ModuleBrightnessUpdateWithWhereUniqueWithoutBrightnessInput[]
    updateMany?: ModuleBrightnessUpdateManyWithWhereWithoutBrightnessInput | ModuleBrightnessUpdateManyWithWhereWithoutBrightnessInput[]
    deleteMany?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
  }

  export type CabinetManufacturerCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput> | CabinetManufacturerCreateWithoutManufacturerInput[] | CabinetManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutManufacturerInput | CabinetManufacturerCreateOrConnectWithoutManufacturerInput[]
    createMany?: CabinetManufacturerCreateManyManufacturerInputEnvelope
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
  }

  export type ModuleManufacturerCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput> | ModuleManufacturerCreateWithoutManufacturerInput[] | ModuleManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutManufacturerInput | ModuleManufacturerCreateOrConnectWithoutManufacturerInput[]
    createMany?: ModuleManufacturerCreateManyManufacturerInputEnvelope
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
  }

  export type CabinetManufacturerUncheckedCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput> | CabinetManufacturerCreateWithoutManufacturerInput[] | CabinetManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutManufacturerInput | CabinetManufacturerCreateOrConnectWithoutManufacturerInput[]
    createMany?: CabinetManufacturerCreateManyManufacturerInputEnvelope
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
  }

  export type ModuleManufacturerUncheckedCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput> | ModuleManufacturerCreateWithoutManufacturerInput[] | ModuleManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutManufacturerInput | ModuleManufacturerCreateOrConnectWithoutManufacturerInput[]
    createMany?: ModuleManufacturerCreateManyManufacturerInputEnvelope
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
  }

  export type CabinetManufacturerUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput> | CabinetManufacturerCreateWithoutManufacturerInput[] | CabinetManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutManufacturerInput | CabinetManufacturerCreateOrConnectWithoutManufacturerInput[]
    upsert?: CabinetManufacturerUpsertWithWhereUniqueWithoutManufacturerInput | CabinetManufacturerUpsertWithWhereUniqueWithoutManufacturerInput[]
    createMany?: CabinetManufacturerCreateManyManufacturerInputEnvelope
    set?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    disconnect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    delete?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    update?: CabinetManufacturerUpdateWithWhereUniqueWithoutManufacturerInput | CabinetManufacturerUpdateWithWhereUniqueWithoutManufacturerInput[]
    updateMany?: CabinetManufacturerUpdateManyWithWhereWithoutManufacturerInput | CabinetManufacturerUpdateManyWithWhereWithoutManufacturerInput[]
    deleteMany?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
  }

  export type ModuleManufacturerUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput> | ModuleManufacturerCreateWithoutManufacturerInput[] | ModuleManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutManufacturerInput | ModuleManufacturerCreateOrConnectWithoutManufacturerInput[]
    upsert?: ModuleManufacturerUpsertWithWhereUniqueWithoutManufacturerInput | ModuleManufacturerUpsertWithWhereUniqueWithoutManufacturerInput[]
    createMany?: ModuleManufacturerCreateManyManufacturerInputEnvelope
    set?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    disconnect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    delete?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    update?: ModuleManufacturerUpdateWithWhereUniqueWithoutManufacturerInput | ModuleManufacturerUpdateWithWhereUniqueWithoutManufacturerInput[]
    updateMany?: ModuleManufacturerUpdateManyWithWhereWithoutManufacturerInput | ModuleManufacturerUpdateManyWithWhereWithoutManufacturerInput[]
    deleteMany?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
  }

  export type CabinetManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput> | CabinetManufacturerCreateWithoutManufacturerInput[] | CabinetManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutManufacturerInput | CabinetManufacturerCreateOrConnectWithoutManufacturerInput[]
    upsert?: CabinetManufacturerUpsertWithWhereUniqueWithoutManufacturerInput | CabinetManufacturerUpsertWithWhereUniqueWithoutManufacturerInput[]
    createMany?: CabinetManufacturerCreateManyManufacturerInputEnvelope
    set?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    disconnect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    delete?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    update?: CabinetManufacturerUpdateWithWhereUniqueWithoutManufacturerInput | CabinetManufacturerUpdateWithWhereUniqueWithoutManufacturerInput[]
    updateMany?: CabinetManufacturerUpdateManyWithWhereWithoutManufacturerInput | CabinetManufacturerUpdateManyWithWhereWithoutManufacturerInput[]
    deleteMany?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
  }

  export type ModuleManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput> | ModuleManufacturerCreateWithoutManufacturerInput[] | ModuleManufacturerUncheckedCreateWithoutManufacturerInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutManufacturerInput | ModuleManufacturerCreateOrConnectWithoutManufacturerInput[]
    upsert?: ModuleManufacturerUpsertWithWhereUniqueWithoutManufacturerInput | ModuleManufacturerUpsertWithWhereUniqueWithoutManufacturerInput[]
    createMany?: ModuleManufacturerCreateManyManufacturerInputEnvelope
    set?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    disconnect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    delete?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    update?: ModuleManufacturerUpdateWithWhereUniqueWithoutManufacturerInput | ModuleManufacturerUpdateWithWhereUniqueWithoutManufacturerInput[]
    updateMany?: ModuleManufacturerUpdateManyWithWhereWithoutManufacturerInput | ModuleManufacturerUpdateManyWithWhereWithoutManufacturerInput[]
    deleteMany?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
  }

  export type CabinetSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput> | CabinetSupplierCreateWithoutSupplierInput[] | CabinetSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutSupplierInput | CabinetSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: CabinetSupplierCreateManySupplierInputEnvelope
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
  }

  export type ItemSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type CabinetSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput> | CabinetSupplierCreateWithoutSupplierInput[] | CabinetSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutSupplierInput | CabinetSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: CabinetSupplierCreateManySupplierInputEnvelope
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
  }

  export type ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type CabinetSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput> | CabinetSupplierCreateWithoutSupplierInput[] | CabinetSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutSupplierInput | CabinetSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: CabinetSupplierUpsertWithWhereUniqueWithoutSupplierInput | CabinetSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CabinetSupplierCreateManySupplierInputEnvelope
    set?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    disconnect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    delete?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    update?: CabinetSupplierUpdateWithWhereUniqueWithoutSupplierInput | CabinetSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CabinetSupplierUpdateManyWithWhereWithoutSupplierInput | CabinetSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
  }

  export type ItemSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput | ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput | ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutSupplierInput | ItemSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type CabinetSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput> | CabinetSupplierCreateWithoutSupplierInput[] | CabinetSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutSupplierInput | CabinetSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: CabinetSupplierUpsertWithWhereUniqueWithoutSupplierInput | CabinetSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CabinetSupplierCreateManySupplierInputEnvelope
    set?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    disconnect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    delete?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    update?: CabinetSupplierUpdateWithWhereUniqueWithoutSupplierInput | CabinetSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CabinetSupplierUpdateManyWithWhereWithoutSupplierInput | CabinetSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
  }

  export type ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput | ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput | ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutSupplierInput | ItemSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type ModuleModuleSizeCreateNestedManyWithoutSizeInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput> | ModuleModuleSizeCreateWithoutSizeInput[] | ModuleModuleSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutSizeInput | ModuleModuleSizeCreateOrConnectWithoutSizeInput[]
    createMany?: ModuleModuleSizeCreateManySizeInputEnvelope
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
  }

  export type CabinetSizeModuleSizeCreateNestedManyWithoutModuleSizeInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput> | CabinetSizeModuleSizeCreateWithoutModuleSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyModuleSizeInputEnvelope
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
  }

  export type ModuleModuleSizeUncheckedCreateNestedManyWithoutSizeInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput> | ModuleModuleSizeCreateWithoutSizeInput[] | ModuleModuleSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutSizeInput | ModuleModuleSizeCreateOrConnectWithoutSizeInput[]
    createMany?: ModuleModuleSizeCreateManySizeInputEnvelope
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
  }

  export type CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutModuleSizeInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput> | CabinetSizeModuleSizeCreateWithoutModuleSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyModuleSizeInputEnvelope
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
  }

  export type ModuleModuleSizeUpdateManyWithoutSizeNestedInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput> | ModuleModuleSizeCreateWithoutSizeInput[] | ModuleModuleSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutSizeInput | ModuleModuleSizeCreateOrConnectWithoutSizeInput[]
    upsert?: ModuleModuleSizeUpsertWithWhereUniqueWithoutSizeInput | ModuleModuleSizeUpsertWithWhereUniqueWithoutSizeInput[]
    createMany?: ModuleModuleSizeCreateManySizeInputEnvelope
    set?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    disconnect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    delete?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    update?: ModuleModuleSizeUpdateWithWhereUniqueWithoutSizeInput | ModuleModuleSizeUpdateWithWhereUniqueWithoutSizeInput[]
    updateMany?: ModuleModuleSizeUpdateManyWithWhereWithoutSizeInput | ModuleModuleSizeUpdateManyWithWhereWithoutSizeInput[]
    deleteMany?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
  }

  export type CabinetSizeModuleSizeUpdateManyWithoutModuleSizeNestedInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput> | CabinetSizeModuleSizeCreateWithoutModuleSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput[]
    upsert?: CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutModuleSizeInput | CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutModuleSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyModuleSizeInputEnvelope
    set?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    disconnect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    delete?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    update?: CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutModuleSizeInput | CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutModuleSizeInput[]
    updateMany?: CabinetSizeModuleSizeUpdateManyWithWhereWithoutModuleSizeInput | CabinetSizeModuleSizeUpdateManyWithWhereWithoutModuleSizeInput[]
    deleteMany?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
  }

  export type ModuleModuleSizeUncheckedUpdateManyWithoutSizeNestedInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput> | ModuleModuleSizeCreateWithoutSizeInput[] | ModuleModuleSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutSizeInput | ModuleModuleSizeCreateOrConnectWithoutSizeInput[]
    upsert?: ModuleModuleSizeUpsertWithWhereUniqueWithoutSizeInput | ModuleModuleSizeUpsertWithWhereUniqueWithoutSizeInput[]
    createMany?: ModuleModuleSizeCreateManySizeInputEnvelope
    set?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    disconnect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    delete?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    update?: ModuleModuleSizeUpdateWithWhereUniqueWithoutSizeInput | ModuleModuleSizeUpdateWithWhereUniqueWithoutSizeInput[]
    updateMany?: ModuleModuleSizeUpdateManyWithWhereWithoutSizeInput | ModuleModuleSizeUpdateManyWithWhereWithoutSizeInput[]
    deleteMany?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
  }

  export type CabinetSizeModuleSizeUncheckedUpdateManyWithoutModuleSizeNestedInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput> | CabinetSizeModuleSizeCreateWithoutModuleSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput[]
    upsert?: CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutModuleSizeInput | CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutModuleSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyModuleSizeInputEnvelope
    set?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    disconnect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    delete?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    update?: CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutModuleSizeInput | CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutModuleSizeInput[]
    updateMany?: CabinetSizeModuleSizeUpdateManyWithWhereWithoutModuleSizeInput | CabinetSizeModuleSizeUpdateManyWithWhereWithoutModuleSizeInput[]
    deleteMany?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
  }

  export type CabinetCabinetSizeCreateNestedManyWithoutSizeInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput> | CabinetCabinetSizeCreateWithoutSizeInput[] | CabinetCabinetSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutSizeInput | CabinetCabinetSizeCreateOrConnectWithoutSizeInput[]
    createMany?: CabinetCabinetSizeCreateManySizeInputEnvelope
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
  }

  export type CabinetSizeModuleSizeCreateNestedManyWithoutCabinetSizeInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput> | CabinetSizeModuleSizeCreateWithoutCabinetSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyCabinetSizeInputEnvelope
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
  }

  export type CabinetCabinetSizeUncheckedCreateNestedManyWithoutSizeInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput> | CabinetCabinetSizeCreateWithoutSizeInput[] | CabinetCabinetSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutSizeInput | CabinetCabinetSizeCreateOrConnectWithoutSizeInput[]
    createMany?: CabinetCabinetSizeCreateManySizeInputEnvelope
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
  }

  export type CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutCabinetSizeInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput> | CabinetSizeModuleSizeCreateWithoutCabinetSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyCabinetSizeInputEnvelope
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
  }

  export type CabinetCabinetSizeUpdateManyWithoutSizeNestedInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput> | CabinetCabinetSizeCreateWithoutSizeInput[] | CabinetCabinetSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutSizeInput | CabinetCabinetSizeCreateOrConnectWithoutSizeInput[]
    upsert?: CabinetCabinetSizeUpsertWithWhereUniqueWithoutSizeInput | CabinetCabinetSizeUpsertWithWhereUniqueWithoutSizeInput[]
    createMany?: CabinetCabinetSizeCreateManySizeInputEnvelope
    set?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    disconnect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    delete?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    update?: CabinetCabinetSizeUpdateWithWhereUniqueWithoutSizeInput | CabinetCabinetSizeUpdateWithWhereUniqueWithoutSizeInput[]
    updateMany?: CabinetCabinetSizeUpdateManyWithWhereWithoutSizeInput | CabinetCabinetSizeUpdateManyWithWhereWithoutSizeInput[]
    deleteMany?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
  }

  export type CabinetSizeModuleSizeUpdateManyWithoutCabinetSizeNestedInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput> | CabinetSizeModuleSizeCreateWithoutCabinetSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput[]
    upsert?: CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutCabinetSizeInput | CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutCabinetSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyCabinetSizeInputEnvelope
    set?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    disconnect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    delete?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    update?: CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutCabinetSizeInput | CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutCabinetSizeInput[]
    updateMany?: CabinetSizeModuleSizeUpdateManyWithWhereWithoutCabinetSizeInput | CabinetSizeModuleSizeUpdateManyWithWhereWithoutCabinetSizeInput[]
    deleteMany?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
  }

  export type CabinetCabinetSizeUncheckedUpdateManyWithoutSizeNestedInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput> | CabinetCabinetSizeCreateWithoutSizeInput[] | CabinetCabinetSizeUncheckedCreateWithoutSizeInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutSizeInput | CabinetCabinetSizeCreateOrConnectWithoutSizeInput[]
    upsert?: CabinetCabinetSizeUpsertWithWhereUniqueWithoutSizeInput | CabinetCabinetSizeUpsertWithWhereUniqueWithoutSizeInput[]
    createMany?: CabinetCabinetSizeCreateManySizeInputEnvelope
    set?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    disconnect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    delete?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    update?: CabinetCabinetSizeUpdateWithWhereUniqueWithoutSizeInput | CabinetCabinetSizeUpdateWithWhereUniqueWithoutSizeInput[]
    updateMany?: CabinetCabinetSizeUpdateManyWithWhereWithoutSizeInput | CabinetCabinetSizeUpdateManyWithWhereWithoutSizeInput[]
    deleteMany?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
  }

  export type CabinetSizeModuleSizeUncheckedUpdateManyWithoutCabinetSizeNestedInput = {
    create?: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput> | CabinetSizeModuleSizeCreateWithoutCabinetSizeInput[] | CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput[]
    connectOrCreate?: CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput | CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput[]
    upsert?: CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutCabinetSizeInput | CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutCabinetSizeInput[]
    createMany?: CabinetSizeModuleSizeCreateManyCabinetSizeInputEnvelope
    set?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    disconnect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    delete?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    connect?: CabinetSizeModuleSizeWhereUniqueInput | CabinetSizeModuleSizeWhereUniqueInput[]
    update?: CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutCabinetSizeInput | CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutCabinetSizeInput[]
    updateMany?: CabinetSizeModuleSizeUpdateManyWithWhereWithoutCabinetSizeInput | CabinetSizeModuleSizeUpdateManyWithWhereWithoutCabinetSizeInput[]
    deleteMany?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
  }

  export type ItemCategorySubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput> | ItemCategorySubcategoryCreateWithoutCategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManyCategoryInputEnvelope
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
  }

  export type ItemCategoryRelationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput> | ItemCategoryRelationCreateWithoutCategoryInput[] | ItemCategoryRelationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutCategoryInput | ItemCategoryRelationCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCategoryRelationCreateManyCategoryInputEnvelope
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
  }

  export type CabinetCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput> | CabinetCategoryCreateWithoutCategoryInput[] | CabinetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCategoryInput | CabinetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CabinetCategoryCreateManyCategoryInputEnvelope
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
  }

  export type ModuleCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput> | ModuleCategoryCreateWithoutCategoryInput[] | ModuleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutCategoryInput | ModuleCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ModuleCategoryCreateManyCategoryInputEnvelope
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
  }

  export type ItemCategorySubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput> | ItemCategorySubcategoryCreateWithoutCategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManyCategoryInputEnvelope
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
  }

  export type ItemCategoryRelationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput> | ItemCategoryRelationCreateWithoutCategoryInput[] | ItemCategoryRelationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutCategoryInput | ItemCategoryRelationCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCategoryRelationCreateManyCategoryInputEnvelope
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
  }

  export type CabinetCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput> | CabinetCategoryCreateWithoutCategoryInput[] | CabinetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCategoryInput | CabinetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CabinetCategoryCreateManyCategoryInputEnvelope
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
  }

  export type ModuleCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput> | ModuleCategoryCreateWithoutCategoryInput[] | ModuleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutCategoryInput | ModuleCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ModuleCategoryCreateManyCategoryInputEnvelope
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
  }

  export type ItemCategorySubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput> | ItemCategorySubcategoryCreateWithoutCategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemCategorySubcategoryUpsertWithWhereUniqueWithoutCategoryInput | ItemCategorySubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManyCategoryInputEnvelope
    set?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    disconnect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    delete?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    update?: ItemCategorySubcategoryUpdateWithWhereUniqueWithoutCategoryInput | ItemCategorySubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemCategorySubcategoryUpdateManyWithWhereWithoutCategoryInput | ItemCategorySubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
  }

  export type ItemCategoryRelationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput> | ItemCategoryRelationCreateWithoutCategoryInput[] | ItemCategoryRelationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutCategoryInput | ItemCategoryRelationCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemCategoryRelationUpsertWithWhereUniqueWithoutCategoryInput | ItemCategoryRelationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCategoryRelationCreateManyCategoryInputEnvelope
    set?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    disconnect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    delete?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    update?: ItemCategoryRelationUpdateWithWhereUniqueWithoutCategoryInput | ItemCategoryRelationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemCategoryRelationUpdateManyWithWhereWithoutCategoryInput | ItemCategoryRelationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
  }

  export type CabinetCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput> | CabinetCategoryCreateWithoutCategoryInput[] | CabinetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCategoryInput | CabinetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CabinetCategoryUpsertWithWhereUniqueWithoutCategoryInput | CabinetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CabinetCategoryCreateManyCategoryInputEnvelope
    set?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    disconnect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    delete?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    update?: CabinetCategoryUpdateWithWhereUniqueWithoutCategoryInput | CabinetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CabinetCategoryUpdateManyWithWhereWithoutCategoryInput | CabinetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
  }

  export type ModuleCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput> | ModuleCategoryCreateWithoutCategoryInput[] | ModuleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutCategoryInput | ModuleCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ModuleCategoryUpsertWithWhereUniqueWithoutCategoryInput | ModuleCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ModuleCategoryCreateManyCategoryInputEnvelope
    set?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    disconnect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    delete?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    update?: ModuleCategoryUpdateWithWhereUniqueWithoutCategoryInput | ModuleCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ModuleCategoryUpdateManyWithWhereWithoutCategoryInput | ModuleCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
  }

  export type ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput> | ItemCategorySubcategoryCreateWithoutCategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemCategorySubcategoryUpsertWithWhereUniqueWithoutCategoryInput | ItemCategorySubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManyCategoryInputEnvelope
    set?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    disconnect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    delete?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    update?: ItemCategorySubcategoryUpdateWithWhereUniqueWithoutCategoryInput | ItemCategorySubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemCategorySubcategoryUpdateManyWithWhereWithoutCategoryInput | ItemCategorySubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
  }

  export type ItemCategoryRelationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput> | ItemCategoryRelationCreateWithoutCategoryInput[] | ItemCategoryRelationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutCategoryInput | ItemCategoryRelationCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemCategoryRelationUpsertWithWhereUniqueWithoutCategoryInput | ItemCategoryRelationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCategoryRelationCreateManyCategoryInputEnvelope
    set?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    disconnect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    delete?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    update?: ItemCategoryRelationUpdateWithWhereUniqueWithoutCategoryInput | ItemCategoryRelationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemCategoryRelationUpdateManyWithWhereWithoutCategoryInput | ItemCategoryRelationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
  }

  export type CabinetCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput> | CabinetCategoryCreateWithoutCategoryInput[] | CabinetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCategoryInput | CabinetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CabinetCategoryUpsertWithWhereUniqueWithoutCategoryInput | CabinetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CabinetCategoryCreateManyCategoryInputEnvelope
    set?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    disconnect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    delete?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    update?: CabinetCategoryUpdateWithWhereUniqueWithoutCategoryInput | CabinetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CabinetCategoryUpdateManyWithWhereWithoutCategoryInput | CabinetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
  }

  export type ModuleCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput> | ModuleCategoryCreateWithoutCategoryInput[] | ModuleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutCategoryInput | ModuleCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ModuleCategoryUpsertWithWhereUniqueWithoutCategoryInput | ModuleCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ModuleCategoryCreateManyCategoryInputEnvelope
    set?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    disconnect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    delete?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    update?: ModuleCategoryUpdateWithWhereUniqueWithoutCategoryInput | ModuleCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ModuleCategoryUpdateManyWithWhereWithoutCategoryInput | ModuleCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
  }

  export type ItemCategorySubcategoryCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput> | ItemCategorySubcategoryCreateWithoutSubcategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManySubcategoryInputEnvelope
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
  }

  export type ItemSubcategoryRelationCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput> | ItemSubcategoryRelationCreateWithoutSubcategoryInput[] | ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput | ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ItemSubcategoryRelationCreateManySubcategoryInputEnvelope
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
  }

  export type CabinetSubcategoryCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput> | CabinetSubcategoryCreateWithoutSubcategoryInput[] | CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput | CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: CabinetSubcategoryCreateManySubcategoryInputEnvelope
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
  }

  export type ModuleSubcategoryCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput> | ModuleSubcategoryCreateWithoutSubcategoryInput[] | ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput | ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ModuleSubcategoryCreateManySubcategoryInputEnvelope
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
  }

  export type ItemCategorySubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput> | ItemCategorySubcategoryCreateWithoutSubcategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManySubcategoryInputEnvelope
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
  }

  export type ItemSubcategoryRelationUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput> | ItemSubcategoryRelationCreateWithoutSubcategoryInput[] | ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput | ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ItemSubcategoryRelationCreateManySubcategoryInputEnvelope
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
  }

  export type CabinetSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput> | CabinetSubcategoryCreateWithoutSubcategoryInput[] | CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput | CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: CabinetSubcategoryCreateManySubcategoryInputEnvelope
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
  }

  export type ModuleSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput> | ModuleSubcategoryCreateWithoutSubcategoryInput[] | ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput | ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ModuleSubcategoryCreateManySubcategoryInputEnvelope
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
  }

  export type ItemCategorySubcategoryUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput> | ItemCategorySubcategoryCreateWithoutSubcategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ItemCategorySubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | ItemCategorySubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManySubcategoryInputEnvelope
    set?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    disconnect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    delete?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    update?: ItemCategorySubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | ItemCategorySubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ItemCategorySubcategoryUpdateManyWithWhereWithoutSubcategoryInput | ItemCategorySubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
  }

  export type ItemSubcategoryRelationUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput> | ItemSubcategoryRelationCreateWithoutSubcategoryInput[] | ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput | ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ItemSubcategoryRelationUpsertWithWhereUniqueWithoutSubcategoryInput | ItemSubcategoryRelationUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ItemSubcategoryRelationCreateManySubcategoryInputEnvelope
    set?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    disconnect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    delete?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    update?: ItemSubcategoryRelationUpdateWithWhereUniqueWithoutSubcategoryInput | ItemSubcategoryRelationUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ItemSubcategoryRelationUpdateManyWithWhereWithoutSubcategoryInput | ItemSubcategoryRelationUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
  }

  export type CabinetSubcategoryUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput> | CabinetSubcategoryCreateWithoutSubcategoryInput[] | CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput | CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: CabinetSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | CabinetSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: CabinetSubcategoryCreateManySubcategoryInputEnvelope
    set?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    disconnect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    delete?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    update?: CabinetSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | CabinetSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: CabinetSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | CabinetSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
  }

  export type ModuleSubcategoryUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput> | ModuleSubcategoryCreateWithoutSubcategoryInput[] | ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput | ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ModuleSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | ModuleSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ModuleSubcategoryCreateManySubcategoryInputEnvelope
    set?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    disconnect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    delete?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    update?: ModuleSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | ModuleSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ModuleSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | ModuleSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
  }

  export type ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput> | ItemCategorySubcategoryCreateWithoutSubcategoryInput[] | ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput | ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ItemCategorySubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | ItemCategorySubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ItemCategorySubcategoryCreateManySubcategoryInputEnvelope
    set?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    disconnect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    delete?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    connect?: ItemCategorySubcategoryWhereUniqueInput | ItemCategorySubcategoryWhereUniqueInput[]
    update?: ItemCategorySubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | ItemCategorySubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ItemCategorySubcategoryUpdateManyWithWhereWithoutSubcategoryInput | ItemCategorySubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
  }

  export type ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput> | ItemSubcategoryRelationCreateWithoutSubcategoryInput[] | ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput | ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ItemSubcategoryRelationUpsertWithWhereUniqueWithoutSubcategoryInput | ItemSubcategoryRelationUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ItemSubcategoryRelationCreateManySubcategoryInputEnvelope
    set?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    disconnect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    delete?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    update?: ItemSubcategoryRelationUpdateWithWhereUniqueWithoutSubcategoryInput | ItemSubcategoryRelationUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ItemSubcategoryRelationUpdateManyWithWhereWithoutSubcategoryInput | ItemSubcategoryRelationUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
  }

  export type CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput> | CabinetSubcategoryCreateWithoutSubcategoryInput[] | CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput | CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: CabinetSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | CabinetSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: CabinetSubcategoryCreateManySubcategoryInputEnvelope
    set?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    disconnect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    delete?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    update?: CabinetSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | CabinetSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: CabinetSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | CabinetSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
  }

  export type ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput> | ModuleSubcategoryCreateWithoutSubcategoryInput[] | ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput | ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ModuleSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | ModuleSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ModuleSubcategoryCreateManySubcategoryInputEnvelope
    set?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    disconnect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    delete?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    update?: ModuleSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | ModuleSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ModuleSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | ModuleSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
  }

  export type CabinetCategoryCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput> | CabinetCategoryCreateWithoutCabinetInput[] | CabinetCategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCabinetInput | CabinetCategoryCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetCategoryCreateManyCabinetInputEnvelope
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
  }

  export type CabinetSubcategoryCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput> | CabinetSubcategoryCreateWithoutCabinetInput[] | CabinetSubcategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutCabinetInput | CabinetSubcategoryCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetSubcategoryCreateManyCabinetInputEnvelope
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
  }

  export type CabinetLocationCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput> | CabinetLocationCreateWithoutCabinetInput[] | CabinetLocationUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutCabinetInput | CabinetLocationCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetLocationCreateManyCabinetInputEnvelope
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
  }

  export type CabinetPlacementCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput> | CabinetPlacementCreateWithoutCabinetInput[] | CabinetPlacementUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutCabinetInput | CabinetPlacementCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPlacementCreateManyCabinetInputEnvelope
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
  }

  export type CabinetMaterialCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput> | CabinetMaterialCreateWithoutCabinetInput[] | CabinetMaterialUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutCabinetInput | CabinetMaterialCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetMaterialCreateManyCabinetInputEnvelope
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
  }

  export type CabinetCabinetSizeCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput> | CabinetCabinetSizeCreateWithoutCabinetInput[] | CabinetCabinetSizeUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutCabinetInput | CabinetCabinetSizeCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetCabinetSizeCreateManyCabinetInputEnvelope
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
  }

  export type CabinetPitchCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput> | CabinetPitchCreateWithoutCabinetInput[] | CabinetPitchUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutCabinetInput | CabinetPitchCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPitchCreateManyCabinetInputEnvelope
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
  }

  export type CabinetManufacturerCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput> | CabinetManufacturerCreateWithoutCabinetInput[] | CabinetManufacturerUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutCabinetInput | CabinetManufacturerCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetManufacturerCreateManyCabinetInputEnvelope
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
  }

  export type CabinetSupplierCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput> | CabinetSupplierCreateWithoutCabinetInput[] | CabinetSupplierUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutCabinetInput | CabinetSupplierCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetSupplierCreateManyCabinetInputEnvelope
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
  }

  export type CabinetItemComponentCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput> | CabinetItemComponentCreateWithoutCabinetInput[] | CabinetItemComponentUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutCabinetInput | CabinetItemComponentCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetItemComponentCreateManyCabinetInputEnvelope
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
  }

  export type CabinetPriceCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput> | CabinetPriceCreateWithoutCabinetInput[] | CabinetPriceUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPriceCreateOrConnectWithoutCabinetInput | CabinetPriceCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPriceCreateManyCabinetInputEnvelope
    connect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
  }

  export type CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput> | CabinetCategoryCreateWithoutCabinetInput[] | CabinetCategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCabinetInput | CabinetCategoryCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetCategoryCreateManyCabinetInputEnvelope
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
  }

  export type CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput> | CabinetSubcategoryCreateWithoutCabinetInput[] | CabinetSubcategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutCabinetInput | CabinetSubcategoryCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetSubcategoryCreateManyCabinetInputEnvelope
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
  }

  export type CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput> | CabinetLocationCreateWithoutCabinetInput[] | CabinetLocationUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutCabinetInput | CabinetLocationCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetLocationCreateManyCabinetInputEnvelope
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
  }

  export type CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput> | CabinetPlacementCreateWithoutCabinetInput[] | CabinetPlacementUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutCabinetInput | CabinetPlacementCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPlacementCreateManyCabinetInputEnvelope
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
  }

  export type CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput> | CabinetMaterialCreateWithoutCabinetInput[] | CabinetMaterialUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutCabinetInput | CabinetMaterialCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetMaterialCreateManyCabinetInputEnvelope
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
  }

  export type CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput> | CabinetCabinetSizeCreateWithoutCabinetInput[] | CabinetCabinetSizeUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutCabinetInput | CabinetCabinetSizeCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetCabinetSizeCreateManyCabinetInputEnvelope
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
  }

  export type CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput> | CabinetPitchCreateWithoutCabinetInput[] | CabinetPitchUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutCabinetInput | CabinetPitchCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPitchCreateManyCabinetInputEnvelope
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
  }

  export type CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput> | CabinetManufacturerCreateWithoutCabinetInput[] | CabinetManufacturerUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutCabinetInput | CabinetManufacturerCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetManufacturerCreateManyCabinetInputEnvelope
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
  }

  export type CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput> | CabinetSupplierCreateWithoutCabinetInput[] | CabinetSupplierUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutCabinetInput | CabinetSupplierCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetSupplierCreateManyCabinetInputEnvelope
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
  }

  export type CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput> | CabinetItemComponentCreateWithoutCabinetInput[] | CabinetItemComponentUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutCabinetInput | CabinetItemComponentCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetItemComponentCreateManyCabinetInputEnvelope
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
  }

  export type CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput = {
    create?: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput> | CabinetPriceCreateWithoutCabinetInput[] | CabinetPriceUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPriceCreateOrConnectWithoutCabinetInput | CabinetPriceCreateOrConnectWithoutCabinetInput[]
    createMany?: CabinetPriceCreateManyCabinetInputEnvelope
    connect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CabinetCategoryUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput> | CabinetCategoryCreateWithoutCabinetInput[] | CabinetCategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCabinetInput | CabinetCategoryCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetCategoryUpsertWithWhereUniqueWithoutCabinetInput | CabinetCategoryUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetCategoryCreateManyCabinetInputEnvelope
    set?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    disconnect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    delete?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    update?: CabinetCategoryUpdateWithWhereUniqueWithoutCabinetInput | CabinetCategoryUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetCategoryUpdateManyWithWhereWithoutCabinetInput | CabinetCategoryUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
  }

  export type CabinetSubcategoryUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput> | CabinetSubcategoryCreateWithoutCabinetInput[] | CabinetSubcategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutCabinetInput | CabinetSubcategoryCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetSubcategoryUpsertWithWhereUniqueWithoutCabinetInput | CabinetSubcategoryUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetSubcategoryCreateManyCabinetInputEnvelope
    set?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    disconnect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    delete?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    update?: CabinetSubcategoryUpdateWithWhereUniqueWithoutCabinetInput | CabinetSubcategoryUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetSubcategoryUpdateManyWithWhereWithoutCabinetInput | CabinetSubcategoryUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
  }

  export type CabinetLocationUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput> | CabinetLocationCreateWithoutCabinetInput[] | CabinetLocationUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutCabinetInput | CabinetLocationCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetLocationUpsertWithWhereUniqueWithoutCabinetInput | CabinetLocationUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetLocationCreateManyCabinetInputEnvelope
    set?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    disconnect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    delete?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    update?: CabinetLocationUpdateWithWhereUniqueWithoutCabinetInput | CabinetLocationUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetLocationUpdateManyWithWhereWithoutCabinetInput | CabinetLocationUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
  }

  export type CabinetPlacementUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput> | CabinetPlacementCreateWithoutCabinetInput[] | CabinetPlacementUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutCabinetInput | CabinetPlacementCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPlacementUpsertWithWhereUniqueWithoutCabinetInput | CabinetPlacementUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPlacementCreateManyCabinetInputEnvelope
    set?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    disconnect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    delete?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    update?: CabinetPlacementUpdateWithWhereUniqueWithoutCabinetInput | CabinetPlacementUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPlacementUpdateManyWithWhereWithoutCabinetInput | CabinetPlacementUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
  }

  export type CabinetMaterialUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput> | CabinetMaterialCreateWithoutCabinetInput[] | CabinetMaterialUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutCabinetInput | CabinetMaterialCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetMaterialUpsertWithWhereUniqueWithoutCabinetInput | CabinetMaterialUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetMaterialCreateManyCabinetInputEnvelope
    set?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    disconnect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    delete?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    update?: CabinetMaterialUpdateWithWhereUniqueWithoutCabinetInput | CabinetMaterialUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetMaterialUpdateManyWithWhereWithoutCabinetInput | CabinetMaterialUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
  }

  export type CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput> | CabinetCabinetSizeCreateWithoutCabinetInput[] | CabinetCabinetSizeUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutCabinetInput | CabinetCabinetSizeCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetCabinetSizeUpsertWithWhereUniqueWithoutCabinetInput | CabinetCabinetSizeUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetCabinetSizeCreateManyCabinetInputEnvelope
    set?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    disconnect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    delete?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    update?: CabinetCabinetSizeUpdateWithWhereUniqueWithoutCabinetInput | CabinetCabinetSizeUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetCabinetSizeUpdateManyWithWhereWithoutCabinetInput | CabinetCabinetSizeUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
  }

  export type CabinetPitchUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput> | CabinetPitchCreateWithoutCabinetInput[] | CabinetPitchUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutCabinetInput | CabinetPitchCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPitchUpsertWithWhereUniqueWithoutCabinetInput | CabinetPitchUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPitchCreateManyCabinetInputEnvelope
    set?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    disconnect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    delete?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    update?: CabinetPitchUpdateWithWhereUniqueWithoutCabinetInput | CabinetPitchUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPitchUpdateManyWithWhereWithoutCabinetInput | CabinetPitchUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
  }

  export type CabinetManufacturerUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput> | CabinetManufacturerCreateWithoutCabinetInput[] | CabinetManufacturerUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutCabinetInput | CabinetManufacturerCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetManufacturerUpsertWithWhereUniqueWithoutCabinetInput | CabinetManufacturerUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetManufacturerCreateManyCabinetInputEnvelope
    set?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    disconnect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    delete?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    update?: CabinetManufacturerUpdateWithWhereUniqueWithoutCabinetInput | CabinetManufacturerUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetManufacturerUpdateManyWithWhereWithoutCabinetInput | CabinetManufacturerUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
  }

  export type CabinetSupplierUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput> | CabinetSupplierCreateWithoutCabinetInput[] | CabinetSupplierUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutCabinetInput | CabinetSupplierCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetSupplierUpsertWithWhereUniqueWithoutCabinetInput | CabinetSupplierUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetSupplierCreateManyCabinetInputEnvelope
    set?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    disconnect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    delete?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    update?: CabinetSupplierUpdateWithWhereUniqueWithoutCabinetInput | CabinetSupplierUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetSupplierUpdateManyWithWhereWithoutCabinetInput | CabinetSupplierUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
  }

  export type CabinetItemComponentUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput> | CabinetItemComponentCreateWithoutCabinetInput[] | CabinetItemComponentUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutCabinetInput | CabinetItemComponentCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetItemComponentUpsertWithWhereUniqueWithoutCabinetInput | CabinetItemComponentUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetItemComponentCreateManyCabinetInputEnvelope
    set?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    disconnect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    delete?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    update?: CabinetItemComponentUpdateWithWhereUniqueWithoutCabinetInput | CabinetItemComponentUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetItemComponentUpdateManyWithWhereWithoutCabinetInput | CabinetItemComponentUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
  }

  export type CabinetPriceUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput> | CabinetPriceCreateWithoutCabinetInput[] | CabinetPriceUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPriceCreateOrConnectWithoutCabinetInput | CabinetPriceCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPriceUpsertWithWhereUniqueWithoutCabinetInput | CabinetPriceUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPriceCreateManyCabinetInputEnvelope
    set?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    disconnect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    delete?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    connect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    update?: CabinetPriceUpdateWithWhereUniqueWithoutCabinetInput | CabinetPriceUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPriceUpdateManyWithWhereWithoutCabinetInput | CabinetPriceUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPriceScalarWhereInput | CabinetPriceScalarWhereInput[]
  }

  export type CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput> | CabinetCategoryCreateWithoutCabinetInput[] | CabinetCategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCategoryCreateOrConnectWithoutCabinetInput | CabinetCategoryCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetCategoryUpsertWithWhereUniqueWithoutCabinetInput | CabinetCategoryUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetCategoryCreateManyCabinetInputEnvelope
    set?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    disconnect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    delete?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    connect?: CabinetCategoryWhereUniqueInput | CabinetCategoryWhereUniqueInput[]
    update?: CabinetCategoryUpdateWithWhereUniqueWithoutCabinetInput | CabinetCategoryUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetCategoryUpdateManyWithWhereWithoutCabinetInput | CabinetCategoryUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
  }

  export type CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput> | CabinetSubcategoryCreateWithoutCabinetInput[] | CabinetSubcategoryUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSubcategoryCreateOrConnectWithoutCabinetInput | CabinetSubcategoryCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetSubcategoryUpsertWithWhereUniqueWithoutCabinetInput | CabinetSubcategoryUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetSubcategoryCreateManyCabinetInputEnvelope
    set?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    disconnect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    delete?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    connect?: CabinetSubcategoryWhereUniqueInput | CabinetSubcategoryWhereUniqueInput[]
    update?: CabinetSubcategoryUpdateWithWhereUniqueWithoutCabinetInput | CabinetSubcategoryUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetSubcategoryUpdateManyWithWhereWithoutCabinetInput | CabinetSubcategoryUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
  }

  export type CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput> | CabinetLocationCreateWithoutCabinetInput[] | CabinetLocationUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetLocationCreateOrConnectWithoutCabinetInput | CabinetLocationCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetLocationUpsertWithWhereUniqueWithoutCabinetInput | CabinetLocationUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetLocationCreateManyCabinetInputEnvelope
    set?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    disconnect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    delete?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    connect?: CabinetLocationWhereUniqueInput | CabinetLocationWhereUniqueInput[]
    update?: CabinetLocationUpdateWithWhereUniqueWithoutCabinetInput | CabinetLocationUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetLocationUpdateManyWithWhereWithoutCabinetInput | CabinetLocationUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
  }

  export type CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput> | CabinetPlacementCreateWithoutCabinetInput[] | CabinetPlacementUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPlacementCreateOrConnectWithoutCabinetInput | CabinetPlacementCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPlacementUpsertWithWhereUniqueWithoutCabinetInput | CabinetPlacementUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPlacementCreateManyCabinetInputEnvelope
    set?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    disconnect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    delete?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    connect?: CabinetPlacementWhereUniqueInput | CabinetPlacementWhereUniqueInput[]
    update?: CabinetPlacementUpdateWithWhereUniqueWithoutCabinetInput | CabinetPlacementUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPlacementUpdateManyWithWhereWithoutCabinetInput | CabinetPlacementUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
  }

  export type CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput> | CabinetMaterialCreateWithoutCabinetInput[] | CabinetMaterialUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetMaterialCreateOrConnectWithoutCabinetInput | CabinetMaterialCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetMaterialUpsertWithWhereUniqueWithoutCabinetInput | CabinetMaterialUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetMaterialCreateManyCabinetInputEnvelope
    set?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    disconnect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    delete?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    connect?: CabinetMaterialWhereUniqueInput | CabinetMaterialWhereUniqueInput[]
    update?: CabinetMaterialUpdateWithWhereUniqueWithoutCabinetInput | CabinetMaterialUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetMaterialUpdateManyWithWhereWithoutCabinetInput | CabinetMaterialUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
  }

  export type CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput> | CabinetCabinetSizeCreateWithoutCabinetInput[] | CabinetCabinetSizeUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetCabinetSizeCreateOrConnectWithoutCabinetInput | CabinetCabinetSizeCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetCabinetSizeUpsertWithWhereUniqueWithoutCabinetInput | CabinetCabinetSizeUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetCabinetSizeCreateManyCabinetInputEnvelope
    set?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    disconnect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    delete?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    connect?: CabinetCabinetSizeWhereUniqueInput | CabinetCabinetSizeWhereUniqueInput[]
    update?: CabinetCabinetSizeUpdateWithWhereUniqueWithoutCabinetInput | CabinetCabinetSizeUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetCabinetSizeUpdateManyWithWhereWithoutCabinetInput | CabinetCabinetSizeUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
  }

  export type CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput> | CabinetPitchCreateWithoutCabinetInput[] | CabinetPitchUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPitchCreateOrConnectWithoutCabinetInput | CabinetPitchCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPitchUpsertWithWhereUniqueWithoutCabinetInput | CabinetPitchUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPitchCreateManyCabinetInputEnvelope
    set?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    disconnect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    delete?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    connect?: CabinetPitchWhereUniqueInput | CabinetPitchWhereUniqueInput[]
    update?: CabinetPitchUpdateWithWhereUniqueWithoutCabinetInput | CabinetPitchUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPitchUpdateManyWithWhereWithoutCabinetInput | CabinetPitchUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
  }

  export type CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput> | CabinetManufacturerCreateWithoutCabinetInput[] | CabinetManufacturerUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetManufacturerCreateOrConnectWithoutCabinetInput | CabinetManufacturerCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetManufacturerUpsertWithWhereUniqueWithoutCabinetInput | CabinetManufacturerUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetManufacturerCreateManyCabinetInputEnvelope
    set?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    disconnect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    delete?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    connect?: CabinetManufacturerWhereUniqueInput | CabinetManufacturerWhereUniqueInput[]
    update?: CabinetManufacturerUpdateWithWhereUniqueWithoutCabinetInput | CabinetManufacturerUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetManufacturerUpdateManyWithWhereWithoutCabinetInput | CabinetManufacturerUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
  }

  export type CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput> | CabinetSupplierCreateWithoutCabinetInput[] | CabinetSupplierUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetSupplierCreateOrConnectWithoutCabinetInput | CabinetSupplierCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetSupplierUpsertWithWhereUniqueWithoutCabinetInput | CabinetSupplierUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetSupplierCreateManyCabinetInputEnvelope
    set?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    disconnect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    delete?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    connect?: CabinetSupplierWhereUniqueInput | CabinetSupplierWhereUniqueInput[]
    update?: CabinetSupplierUpdateWithWhereUniqueWithoutCabinetInput | CabinetSupplierUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetSupplierUpdateManyWithWhereWithoutCabinetInput | CabinetSupplierUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
  }

  export type CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput> | CabinetItemComponentCreateWithoutCabinetInput[] | CabinetItemComponentUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutCabinetInput | CabinetItemComponentCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetItemComponentUpsertWithWhereUniqueWithoutCabinetInput | CabinetItemComponentUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetItemComponentCreateManyCabinetInputEnvelope
    set?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    disconnect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    delete?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    update?: CabinetItemComponentUpdateWithWhereUniqueWithoutCabinetInput | CabinetItemComponentUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetItemComponentUpdateManyWithWhereWithoutCabinetInput | CabinetItemComponentUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
  }

  export type CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput = {
    create?: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput> | CabinetPriceCreateWithoutCabinetInput[] | CabinetPriceUncheckedCreateWithoutCabinetInput[]
    connectOrCreate?: CabinetPriceCreateOrConnectWithoutCabinetInput | CabinetPriceCreateOrConnectWithoutCabinetInput[]
    upsert?: CabinetPriceUpsertWithWhereUniqueWithoutCabinetInput | CabinetPriceUpsertWithWhereUniqueWithoutCabinetInput[]
    createMany?: CabinetPriceCreateManyCabinetInputEnvelope
    set?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    disconnect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    delete?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    connect?: CabinetPriceWhereUniqueInput | CabinetPriceWhereUniqueInput[]
    update?: CabinetPriceUpdateWithWhereUniqueWithoutCabinetInput | CabinetPriceUpdateWithWhereUniqueWithoutCabinetInput[]
    updateMany?: CabinetPriceUpdateManyWithWhereWithoutCabinetInput | CabinetPriceUpdateManyWithWhereWithoutCabinetInput[]
    deleteMany?: CabinetPriceScalarWhereInput | CabinetPriceScalarWhereInput[]
  }

  export type ModuleCategoryCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput> | ModuleCategoryCreateWithoutModuleInput[] | ModuleCategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutModuleInput | ModuleCategoryCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleCategoryCreateManyModuleInputEnvelope
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
  }

  export type ModuleSubcategoryCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput> | ModuleSubcategoryCreateWithoutModuleInput[] | ModuleSubcategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutModuleInput | ModuleSubcategoryCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleSubcategoryCreateManyModuleInputEnvelope
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
  }

  export type ModuleLocationCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput> | ModuleLocationCreateWithoutModuleInput[] | ModuleLocationUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutModuleInput | ModuleLocationCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleLocationCreateManyModuleInputEnvelope
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
  }

  export type ModuleRefreshRateCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput> | ModuleRefreshRateCreateWithoutModuleInput[] | ModuleRefreshRateUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutModuleInput | ModuleRefreshRateCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleRefreshRateCreateManyModuleInputEnvelope
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
  }

  export type ModuleBrightnessCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput> | ModuleBrightnessCreateWithoutModuleInput[] | ModuleBrightnessUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutModuleInput | ModuleBrightnessCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleBrightnessCreateManyModuleInputEnvelope
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
  }

  export type ModuleModuleSizeCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput> | ModuleModuleSizeCreateWithoutModuleInput[] | ModuleModuleSizeUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutModuleInput | ModuleModuleSizeCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleModuleSizeCreateManyModuleInputEnvelope
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
  }

  export type ModulePitchCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput> | ModulePitchCreateWithoutModuleInput[] | ModulePitchUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutModuleInput | ModulePitchCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePitchCreateManyModuleInputEnvelope
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
  }

  export type ModuleManufacturerCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput> | ModuleManufacturerCreateWithoutModuleInput[] | ModuleManufacturerUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutModuleInput | ModuleManufacturerCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleManufacturerCreateManyModuleInputEnvelope
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
  }

  export type ModuleItemComponentCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput> | ModuleItemComponentCreateWithoutModuleInput[] | ModuleItemComponentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutModuleInput | ModuleItemComponentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleItemComponentCreateManyModuleInputEnvelope
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
  }

  export type ModuleOptionCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput> | ModuleOptionCreateWithoutModuleInput[] | ModuleOptionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutModuleInput | ModuleOptionCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleOptionCreateManyModuleInputEnvelope
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
  }

  export type ModulePriceCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput> | ModulePriceCreateWithoutModuleInput[] | ModulePriceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePriceCreateOrConnectWithoutModuleInput | ModulePriceCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePriceCreateManyModuleInputEnvelope
    connect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
  }

  export type ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput> | ModuleCategoryCreateWithoutModuleInput[] | ModuleCategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutModuleInput | ModuleCategoryCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleCategoryCreateManyModuleInputEnvelope
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
  }

  export type ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput> | ModuleSubcategoryCreateWithoutModuleInput[] | ModuleSubcategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutModuleInput | ModuleSubcategoryCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleSubcategoryCreateManyModuleInputEnvelope
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
  }

  export type ModuleLocationUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput> | ModuleLocationCreateWithoutModuleInput[] | ModuleLocationUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutModuleInput | ModuleLocationCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleLocationCreateManyModuleInputEnvelope
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
  }

  export type ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput> | ModuleRefreshRateCreateWithoutModuleInput[] | ModuleRefreshRateUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutModuleInput | ModuleRefreshRateCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleRefreshRateCreateManyModuleInputEnvelope
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
  }

  export type ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput> | ModuleBrightnessCreateWithoutModuleInput[] | ModuleBrightnessUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutModuleInput | ModuleBrightnessCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleBrightnessCreateManyModuleInputEnvelope
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
  }

  export type ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput> | ModuleModuleSizeCreateWithoutModuleInput[] | ModuleModuleSizeUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutModuleInput | ModuleModuleSizeCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleModuleSizeCreateManyModuleInputEnvelope
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
  }

  export type ModulePitchUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput> | ModulePitchCreateWithoutModuleInput[] | ModulePitchUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutModuleInput | ModulePitchCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePitchCreateManyModuleInputEnvelope
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
  }

  export type ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput> | ModuleManufacturerCreateWithoutModuleInput[] | ModuleManufacturerUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutModuleInput | ModuleManufacturerCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleManufacturerCreateManyModuleInputEnvelope
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
  }

  export type ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput> | ModuleItemComponentCreateWithoutModuleInput[] | ModuleItemComponentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutModuleInput | ModuleItemComponentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleItemComponentCreateManyModuleInputEnvelope
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
  }

  export type ModuleOptionUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput> | ModuleOptionCreateWithoutModuleInput[] | ModuleOptionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutModuleInput | ModuleOptionCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleOptionCreateManyModuleInputEnvelope
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
  }

  export type ModulePriceUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput> | ModulePriceCreateWithoutModuleInput[] | ModulePriceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePriceCreateOrConnectWithoutModuleInput | ModulePriceCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePriceCreateManyModuleInputEnvelope
    connect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
  }

  export type ModuleCategoryUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput> | ModuleCategoryCreateWithoutModuleInput[] | ModuleCategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutModuleInput | ModuleCategoryCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleCategoryUpsertWithWhereUniqueWithoutModuleInput | ModuleCategoryUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleCategoryCreateManyModuleInputEnvelope
    set?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    disconnect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    delete?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    update?: ModuleCategoryUpdateWithWhereUniqueWithoutModuleInput | ModuleCategoryUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleCategoryUpdateManyWithWhereWithoutModuleInput | ModuleCategoryUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
  }

  export type ModuleSubcategoryUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput> | ModuleSubcategoryCreateWithoutModuleInput[] | ModuleSubcategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutModuleInput | ModuleSubcategoryCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleSubcategoryUpsertWithWhereUniqueWithoutModuleInput | ModuleSubcategoryUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleSubcategoryCreateManyModuleInputEnvelope
    set?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    disconnect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    delete?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    update?: ModuleSubcategoryUpdateWithWhereUniqueWithoutModuleInput | ModuleSubcategoryUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleSubcategoryUpdateManyWithWhereWithoutModuleInput | ModuleSubcategoryUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
  }

  export type ModuleLocationUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput> | ModuleLocationCreateWithoutModuleInput[] | ModuleLocationUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutModuleInput | ModuleLocationCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleLocationUpsertWithWhereUniqueWithoutModuleInput | ModuleLocationUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleLocationCreateManyModuleInputEnvelope
    set?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    disconnect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    delete?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    update?: ModuleLocationUpdateWithWhereUniqueWithoutModuleInput | ModuleLocationUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleLocationUpdateManyWithWhereWithoutModuleInput | ModuleLocationUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
  }

  export type ModuleRefreshRateUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput> | ModuleRefreshRateCreateWithoutModuleInput[] | ModuleRefreshRateUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutModuleInput | ModuleRefreshRateCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleRefreshRateUpsertWithWhereUniqueWithoutModuleInput | ModuleRefreshRateUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleRefreshRateCreateManyModuleInputEnvelope
    set?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    disconnect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    delete?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    update?: ModuleRefreshRateUpdateWithWhereUniqueWithoutModuleInput | ModuleRefreshRateUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleRefreshRateUpdateManyWithWhereWithoutModuleInput | ModuleRefreshRateUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
  }

  export type ModuleBrightnessUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput> | ModuleBrightnessCreateWithoutModuleInput[] | ModuleBrightnessUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutModuleInput | ModuleBrightnessCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleBrightnessUpsertWithWhereUniqueWithoutModuleInput | ModuleBrightnessUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleBrightnessCreateManyModuleInputEnvelope
    set?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    disconnect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    delete?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    update?: ModuleBrightnessUpdateWithWhereUniqueWithoutModuleInput | ModuleBrightnessUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleBrightnessUpdateManyWithWhereWithoutModuleInput | ModuleBrightnessUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
  }

  export type ModuleModuleSizeUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput> | ModuleModuleSizeCreateWithoutModuleInput[] | ModuleModuleSizeUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutModuleInput | ModuleModuleSizeCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleModuleSizeUpsertWithWhereUniqueWithoutModuleInput | ModuleModuleSizeUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleModuleSizeCreateManyModuleInputEnvelope
    set?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    disconnect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    delete?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    update?: ModuleModuleSizeUpdateWithWhereUniqueWithoutModuleInput | ModuleModuleSizeUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleModuleSizeUpdateManyWithWhereWithoutModuleInput | ModuleModuleSizeUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
  }

  export type ModulePitchUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput> | ModulePitchCreateWithoutModuleInput[] | ModulePitchUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutModuleInput | ModulePitchCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePitchUpsertWithWhereUniqueWithoutModuleInput | ModulePitchUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePitchCreateManyModuleInputEnvelope
    set?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    disconnect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    delete?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    update?: ModulePitchUpdateWithWhereUniqueWithoutModuleInput | ModulePitchUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePitchUpdateManyWithWhereWithoutModuleInput | ModulePitchUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
  }

  export type ModuleManufacturerUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput> | ModuleManufacturerCreateWithoutModuleInput[] | ModuleManufacturerUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutModuleInput | ModuleManufacturerCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleManufacturerUpsertWithWhereUniqueWithoutModuleInput | ModuleManufacturerUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleManufacturerCreateManyModuleInputEnvelope
    set?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    disconnect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    delete?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    update?: ModuleManufacturerUpdateWithWhereUniqueWithoutModuleInput | ModuleManufacturerUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleManufacturerUpdateManyWithWhereWithoutModuleInput | ModuleManufacturerUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
  }

  export type ModuleItemComponentUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput> | ModuleItemComponentCreateWithoutModuleInput[] | ModuleItemComponentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutModuleInput | ModuleItemComponentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleItemComponentUpsertWithWhereUniqueWithoutModuleInput | ModuleItemComponentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleItemComponentCreateManyModuleInputEnvelope
    set?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    disconnect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    delete?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    update?: ModuleItemComponentUpdateWithWhereUniqueWithoutModuleInput | ModuleItemComponentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleItemComponentUpdateManyWithWhereWithoutModuleInput | ModuleItemComponentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
  }

  export type ModuleOptionUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput> | ModuleOptionCreateWithoutModuleInput[] | ModuleOptionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutModuleInput | ModuleOptionCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleOptionUpsertWithWhereUniqueWithoutModuleInput | ModuleOptionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleOptionCreateManyModuleInputEnvelope
    set?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    disconnect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    delete?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    update?: ModuleOptionUpdateWithWhereUniqueWithoutModuleInput | ModuleOptionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleOptionUpdateManyWithWhereWithoutModuleInput | ModuleOptionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
  }

  export type ModulePriceUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput> | ModulePriceCreateWithoutModuleInput[] | ModulePriceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePriceCreateOrConnectWithoutModuleInput | ModulePriceCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePriceUpsertWithWhereUniqueWithoutModuleInput | ModulePriceUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePriceCreateManyModuleInputEnvelope
    set?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    disconnect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    delete?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    connect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    update?: ModulePriceUpdateWithWhereUniqueWithoutModuleInput | ModulePriceUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePriceUpdateManyWithWhereWithoutModuleInput | ModulePriceUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePriceScalarWhereInput | ModulePriceScalarWhereInput[]
  }

  export type ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput> | ModuleCategoryCreateWithoutModuleInput[] | ModuleCategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleCategoryCreateOrConnectWithoutModuleInput | ModuleCategoryCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleCategoryUpsertWithWhereUniqueWithoutModuleInput | ModuleCategoryUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleCategoryCreateManyModuleInputEnvelope
    set?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    disconnect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    delete?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    connect?: ModuleCategoryWhereUniqueInput | ModuleCategoryWhereUniqueInput[]
    update?: ModuleCategoryUpdateWithWhereUniqueWithoutModuleInput | ModuleCategoryUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleCategoryUpdateManyWithWhereWithoutModuleInput | ModuleCategoryUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
  }

  export type ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput> | ModuleSubcategoryCreateWithoutModuleInput[] | ModuleSubcategoryUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleSubcategoryCreateOrConnectWithoutModuleInput | ModuleSubcategoryCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleSubcategoryUpsertWithWhereUniqueWithoutModuleInput | ModuleSubcategoryUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleSubcategoryCreateManyModuleInputEnvelope
    set?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    disconnect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    delete?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    connect?: ModuleSubcategoryWhereUniqueInput | ModuleSubcategoryWhereUniqueInput[]
    update?: ModuleSubcategoryUpdateWithWhereUniqueWithoutModuleInput | ModuleSubcategoryUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleSubcategoryUpdateManyWithWhereWithoutModuleInput | ModuleSubcategoryUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
  }

  export type ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput> | ModuleLocationCreateWithoutModuleInput[] | ModuleLocationUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleLocationCreateOrConnectWithoutModuleInput | ModuleLocationCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleLocationUpsertWithWhereUniqueWithoutModuleInput | ModuleLocationUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleLocationCreateManyModuleInputEnvelope
    set?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    disconnect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    delete?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    connect?: ModuleLocationWhereUniqueInput | ModuleLocationWhereUniqueInput[]
    update?: ModuleLocationUpdateWithWhereUniqueWithoutModuleInput | ModuleLocationUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleLocationUpdateManyWithWhereWithoutModuleInput | ModuleLocationUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
  }

  export type ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput> | ModuleRefreshRateCreateWithoutModuleInput[] | ModuleRefreshRateUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleRefreshRateCreateOrConnectWithoutModuleInput | ModuleRefreshRateCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleRefreshRateUpsertWithWhereUniqueWithoutModuleInput | ModuleRefreshRateUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleRefreshRateCreateManyModuleInputEnvelope
    set?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    disconnect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    delete?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    connect?: ModuleRefreshRateWhereUniqueInput | ModuleRefreshRateWhereUniqueInput[]
    update?: ModuleRefreshRateUpdateWithWhereUniqueWithoutModuleInput | ModuleRefreshRateUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleRefreshRateUpdateManyWithWhereWithoutModuleInput | ModuleRefreshRateUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
  }

  export type ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput> | ModuleBrightnessCreateWithoutModuleInput[] | ModuleBrightnessUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleBrightnessCreateOrConnectWithoutModuleInput | ModuleBrightnessCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleBrightnessUpsertWithWhereUniqueWithoutModuleInput | ModuleBrightnessUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleBrightnessCreateManyModuleInputEnvelope
    set?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    disconnect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    delete?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    connect?: ModuleBrightnessWhereUniqueInput | ModuleBrightnessWhereUniqueInput[]
    update?: ModuleBrightnessUpdateWithWhereUniqueWithoutModuleInput | ModuleBrightnessUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleBrightnessUpdateManyWithWhereWithoutModuleInput | ModuleBrightnessUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
  }

  export type ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput> | ModuleModuleSizeCreateWithoutModuleInput[] | ModuleModuleSizeUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleModuleSizeCreateOrConnectWithoutModuleInput | ModuleModuleSizeCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleModuleSizeUpsertWithWhereUniqueWithoutModuleInput | ModuleModuleSizeUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleModuleSizeCreateManyModuleInputEnvelope
    set?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    disconnect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    delete?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    connect?: ModuleModuleSizeWhereUniqueInput | ModuleModuleSizeWhereUniqueInput[]
    update?: ModuleModuleSizeUpdateWithWhereUniqueWithoutModuleInput | ModuleModuleSizeUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleModuleSizeUpdateManyWithWhereWithoutModuleInput | ModuleModuleSizeUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
  }

  export type ModulePitchUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput> | ModulePitchCreateWithoutModuleInput[] | ModulePitchUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePitchCreateOrConnectWithoutModuleInput | ModulePitchCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePitchUpsertWithWhereUniqueWithoutModuleInput | ModulePitchUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePitchCreateManyModuleInputEnvelope
    set?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    disconnect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    delete?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    connect?: ModulePitchWhereUniqueInput | ModulePitchWhereUniqueInput[]
    update?: ModulePitchUpdateWithWhereUniqueWithoutModuleInput | ModulePitchUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePitchUpdateManyWithWhereWithoutModuleInput | ModulePitchUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
  }

  export type ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput> | ModuleManufacturerCreateWithoutModuleInput[] | ModuleManufacturerUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleManufacturerCreateOrConnectWithoutModuleInput | ModuleManufacturerCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleManufacturerUpsertWithWhereUniqueWithoutModuleInput | ModuleManufacturerUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleManufacturerCreateManyModuleInputEnvelope
    set?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    disconnect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    delete?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    connect?: ModuleManufacturerWhereUniqueInput | ModuleManufacturerWhereUniqueInput[]
    update?: ModuleManufacturerUpdateWithWhereUniqueWithoutModuleInput | ModuleManufacturerUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleManufacturerUpdateManyWithWhereWithoutModuleInput | ModuleManufacturerUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
  }

  export type ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput> | ModuleItemComponentCreateWithoutModuleInput[] | ModuleItemComponentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutModuleInput | ModuleItemComponentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleItemComponentUpsertWithWhereUniqueWithoutModuleInput | ModuleItemComponentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleItemComponentCreateManyModuleInputEnvelope
    set?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    disconnect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    delete?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    update?: ModuleItemComponentUpdateWithWhereUniqueWithoutModuleInput | ModuleItemComponentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleItemComponentUpdateManyWithWhereWithoutModuleInput | ModuleItemComponentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
  }

  export type ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput> | ModuleOptionCreateWithoutModuleInput[] | ModuleOptionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOptionCreateOrConnectWithoutModuleInput | ModuleOptionCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleOptionUpsertWithWhereUniqueWithoutModuleInput | ModuleOptionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleOptionCreateManyModuleInputEnvelope
    set?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    disconnect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    delete?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    connect?: ModuleOptionWhereUniqueInput | ModuleOptionWhereUniqueInput[]
    update?: ModuleOptionUpdateWithWhereUniqueWithoutModuleInput | ModuleOptionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleOptionUpdateManyWithWhereWithoutModuleInput | ModuleOptionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
  }

  export type ModulePriceUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput> | ModulePriceCreateWithoutModuleInput[] | ModulePriceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePriceCreateOrConnectWithoutModuleInput | ModulePriceCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePriceUpsertWithWhereUniqueWithoutModuleInput | ModulePriceUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePriceCreateManyModuleInputEnvelope
    set?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    disconnect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    delete?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    connect?: ModulePriceWhereUniqueInput | ModulePriceWhereUniqueInput[]
    update?: ModulePriceUpdateWithWhereUniqueWithoutModuleInput | ModulePriceUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePriceUpdateManyWithWhereWithoutModuleInput | ModulePriceUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePriceScalarWhereInput | ModulePriceScalarWhereInput[]
  }

  export type ItemCategoryRelationCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput> | ItemCategoryRelationCreateWithoutItemInput[] | ItemCategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutItemInput | ItemCategoryRelationCreateOrConnectWithoutItemInput[]
    createMany?: ItemCategoryRelationCreateManyItemInputEnvelope
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
  }

  export type ItemSubcategoryRelationCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput> | ItemSubcategoryRelationCreateWithoutItemInput[] | ItemSubcategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutItemInput | ItemSubcategoryRelationCreateOrConnectWithoutItemInput[]
    createMany?: ItemSubcategoryRelationCreateManyItemInputEnvelope
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
  }

  export type ItemPriceCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput> | ItemPriceCreateWithoutItemInput[] | ItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutItemInput | ItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: ItemPriceCreateManyItemInputEnvelope
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
  }

  export type ItemSupplierCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type CabinetItemComponentCreateNestedManyWithoutItemInput = {
    create?: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput> | CabinetItemComponentCreateWithoutItemInput[] | CabinetItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutItemInput | CabinetItemComponentCreateOrConnectWithoutItemInput[]
    createMany?: CabinetItemComponentCreateManyItemInputEnvelope
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
  }

  export type ModuleItemComponentCreateNestedManyWithoutItemInput = {
    create?: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput> | ModuleItemComponentCreateWithoutItemInput[] | ModuleItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutItemInput | ModuleItemComponentCreateOrConnectWithoutItemInput[]
    createMany?: ModuleItemComponentCreateManyItemInputEnvelope
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
  }

  export type ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput> | ItemCategoryRelationCreateWithoutItemInput[] | ItemCategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutItemInput | ItemCategoryRelationCreateOrConnectWithoutItemInput[]
    createMany?: ItemCategoryRelationCreateManyItemInputEnvelope
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
  }

  export type ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput> | ItemSubcategoryRelationCreateWithoutItemInput[] | ItemSubcategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutItemInput | ItemSubcategoryRelationCreateOrConnectWithoutItemInput[]
    createMany?: ItemSubcategoryRelationCreateManyItemInputEnvelope
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
  }

  export type ItemPriceUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput> | ItemPriceCreateWithoutItemInput[] | ItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutItemInput | ItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: ItemPriceCreateManyItemInputEnvelope
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
  }

  export type ItemSupplierUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput> | CabinetItemComponentCreateWithoutItemInput[] | CabinetItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutItemInput | CabinetItemComponentCreateOrConnectWithoutItemInput[]
    createMany?: CabinetItemComponentCreateManyItemInputEnvelope
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
  }

  export type ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput> | ModuleItemComponentCreateWithoutItemInput[] | ModuleItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutItemInput | ModuleItemComponentCreateOrConnectWithoutItemInput[]
    createMany?: ModuleItemComponentCreateManyItemInputEnvelope
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
  }

  export type ItemCategoryRelationUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput> | ItemCategoryRelationCreateWithoutItemInput[] | ItemCategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutItemInput | ItemCategoryRelationCreateOrConnectWithoutItemInput[]
    upsert?: ItemCategoryRelationUpsertWithWhereUniqueWithoutItemInput | ItemCategoryRelationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemCategoryRelationCreateManyItemInputEnvelope
    set?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    disconnect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    delete?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    update?: ItemCategoryRelationUpdateWithWhereUniqueWithoutItemInput | ItemCategoryRelationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemCategoryRelationUpdateManyWithWhereWithoutItemInput | ItemCategoryRelationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
  }

  export type ItemSubcategoryRelationUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput> | ItemSubcategoryRelationCreateWithoutItemInput[] | ItemSubcategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutItemInput | ItemSubcategoryRelationCreateOrConnectWithoutItemInput[]
    upsert?: ItemSubcategoryRelationUpsertWithWhereUniqueWithoutItemInput | ItemSubcategoryRelationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSubcategoryRelationCreateManyItemInputEnvelope
    set?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    disconnect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    delete?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    update?: ItemSubcategoryRelationUpdateWithWhereUniqueWithoutItemInput | ItemSubcategoryRelationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSubcategoryRelationUpdateManyWithWhereWithoutItemInput | ItemSubcategoryRelationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
  }

  export type ItemPriceUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput> | ItemPriceCreateWithoutItemInput[] | ItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutItemInput | ItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: ItemPriceUpsertWithWhereUniqueWithoutItemInput | ItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemPriceCreateManyItemInputEnvelope
    set?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    disconnect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    delete?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    update?: ItemPriceUpdateWithWhereUniqueWithoutItemInput | ItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemPriceUpdateManyWithWhereWithoutItemInput | ItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
  }

  export type ItemSupplierUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutItemInput | ItemSupplierUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutItemInput | ItemSupplierUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutItemInput | ItemSupplierUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type CabinetItemComponentUpdateManyWithoutItemNestedInput = {
    create?: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput> | CabinetItemComponentCreateWithoutItemInput[] | CabinetItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutItemInput | CabinetItemComponentCreateOrConnectWithoutItemInput[]
    upsert?: CabinetItemComponentUpsertWithWhereUniqueWithoutItemInput | CabinetItemComponentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CabinetItemComponentCreateManyItemInputEnvelope
    set?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    disconnect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    delete?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    update?: CabinetItemComponentUpdateWithWhereUniqueWithoutItemInput | CabinetItemComponentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CabinetItemComponentUpdateManyWithWhereWithoutItemInput | CabinetItemComponentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
  }

  export type ModuleItemComponentUpdateManyWithoutItemNestedInput = {
    create?: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput> | ModuleItemComponentCreateWithoutItemInput[] | ModuleItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutItemInput | ModuleItemComponentCreateOrConnectWithoutItemInput[]
    upsert?: ModuleItemComponentUpsertWithWhereUniqueWithoutItemInput | ModuleItemComponentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ModuleItemComponentCreateManyItemInputEnvelope
    set?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    disconnect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    delete?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    update?: ModuleItemComponentUpdateWithWhereUniqueWithoutItemInput | ModuleItemComponentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ModuleItemComponentUpdateManyWithWhereWithoutItemInput | ModuleItemComponentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
  }

  export type ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput> | ItemCategoryRelationCreateWithoutItemInput[] | ItemCategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCategoryRelationCreateOrConnectWithoutItemInput | ItemCategoryRelationCreateOrConnectWithoutItemInput[]
    upsert?: ItemCategoryRelationUpsertWithWhereUniqueWithoutItemInput | ItemCategoryRelationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemCategoryRelationCreateManyItemInputEnvelope
    set?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    disconnect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    delete?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    connect?: ItemCategoryRelationWhereUniqueInput | ItemCategoryRelationWhereUniqueInput[]
    update?: ItemCategoryRelationUpdateWithWhereUniqueWithoutItemInput | ItemCategoryRelationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemCategoryRelationUpdateManyWithWhereWithoutItemInput | ItemCategoryRelationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
  }

  export type ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput> | ItemSubcategoryRelationCreateWithoutItemInput[] | ItemSubcategoryRelationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSubcategoryRelationCreateOrConnectWithoutItemInput | ItemSubcategoryRelationCreateOrConnectWithoutItemInput[]
    upsert?: ItemSubcategoryRelationUpsertWithWhereUniqueWithoutItemInput | ItemSubcategoryRelationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSubcategoryRelationCreateManyItemInputEnvelope
    set?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    disconnect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    delete?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    connect?: ItemSubcategoryRelationWhereUniqueInput | ItemSubcategoryRelationWhereUniqueInput[]
    update?: ItemSubcategoryRelationUpdateWithWhereUniqueWithoutItemInput | ItemSubcategoryRelationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSubcategoryRelationUpdateManyWithWhereWithoutItemInput | ItemSubcategoryRelationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
  }

  export type ItemPriceUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput> | ItemPriceCreateWithoutItemInput[] | ItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemPriceCreateOrConnectWithoutItemInput | ItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: ItemPriceUpsertWithWhereUniqueWithoutItemInput | ItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemPriceCreateManyItemInputEnvelope
    set?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    disconnect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    delete?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    connect?: ItemPriceWhereUniqueInput | ItemPriceWhereUniqueInput[]
    update?: ItemPriceUpdateWithWhereUniqueWithoutItemInput | ItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemPriceUpdateManyWithWhereWithoutItemInput | ItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
  }

  export type ItemSupplierUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutItemInput | ItemSupplierUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutItemInput | ItemSupplierUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutItemInput | ItemSupplierUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput> | CabinetItemComponentCreateWithoutItemInput[] | CabinetItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CabinetItemComponentCreateOrConnectWithoutItemInput | CabinetItemComponentCreateOrConnectWithoutItemInput[]
    upsert?: CabinetItemComponentUpsertWithWhereUniqueWithoutItemInput | CabinetItemComponentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CabinetItemComponentCreateManyItemInputEnvelope
    set?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    disconnect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    delete?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    connect?: CabinetItemComponentWhereUniqueInput | CabinetItemComponentWhereUniqueInput[]
    update?: CabinetItemComponentUpdateWithWhereUniqueWithoutItemInput | CabinetItemComponentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CabinetItemComponentUpdateManyWithWhereWithoutItemInput | CabinetItemComponentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
  }

  export type ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput> | ModuleItemComponentCreateWithoutItemInput[] | ModuleItemComponentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ModuleItemComponentCreateOrConnectWithoutItemInput | ModuleItemComponentCreateOrConnectWithoutItemInput[]
    upsert?: ModuleItemComponentUpsertWithWhereUniqueWithoutItemInput | ModuleItemComponentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ModuleItemComponentCreateManyItemInputEnvelope
    set?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    disconnect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    delete?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    connect?: ModuleItemComponentWhereUniqueInput | ModuleItemComponentWhereUniqueInput[]
    update?: ModuleItemComponentUpdateWithWhereUniqueWithoutItemInput | ModuleItemComponentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ModuleItemComponentUpdateManyWithWhereWithoutItemInput | ModuleItemComponentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
  }

  export type ScreenTypeCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ScreenTypeCreateWithoutOptionsInput, ScreenTypeUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutOptionsInput
    connect?: ScreenTypeWhereUniqueInput
  }

  export type OptionCreateNestedOneWithoutScreenTypesInput = {
    create?: XOR<OptionCreateWithoutScreenTypesInput, OptionUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutScreenTypesInput
    connect?: OptionWhereUniqueInput
  }

  export type ScreenTypeUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ScreenTypeCreateWithoutOptionsInput, ScreenTypeUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutOptionsInput
    upsert?: ScreenTypeUpsertWithoutOptionsInput
    connect?: ScreenTypeWhereUniqueInput
    update?: XOR<XOR<ScreenTypeUpdateToOneWithWhereWithoutOptionsInput, ScreenTypeUpdateWithoutOptionsInput>, ScreenTypeUncheckedUpdateWithoutOptionsInput>
  }

  export type OptionUpdateOneRequiredWithoutScreenTypesNestedInput = {
    create?: XOR<OptionCreateWithoutScreenTypesInput, OptionUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutScreenTypesInput
    upsert?: OptionUpsertWithoutScreenTypesInput
    connect?: OptionWhereUniqueInput
    update?: XOR<XOR<OptionUpdateToOneWithWhereWithoutScreenTypesInput, OptionUpdateWithoutScreenTypesInput>, OptionUncheckedUpdateWithoutScreenTypesInput>
  }

  export type ScreenTypeCreateNestedOneWithoutControlTypesInput = {
    create?: XOR<ScreenTypeCreateWithoutControlTypesInput, ScreenTypeUncheckedCreateWithoutControlTypesInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutControlTypesInput
    connect?: ScreenTypeWhereUniqueInput
  }

  export type ControlTypeCreateNestedOneWithoutScreenTypesInput = {
    create?: XOR<ControlTypeCreateWithoutScreenTypesInput, ControlTypeUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: ControlTypeCreateOrConnectWithoutScreenTypesInput
    connect?: ControlTypeWhereUniqueInput
  }

  export type ScreenTypeUpdateOneRequiredWithoutControlTypesNestedInput = {
    create?: XOR<ScreenTypeCreateWithoutControlTypesInput, ScreenTypeUncheckedCreateWithoutControlTypesInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutControlTypesInput
    upsert?: ScreenTypeUpsertWithoutControlTypesInput
    connect?: ScreenTypeWhereUniqueInput
    update?: XOR<XOR<ScreenTypeUpdateToOneWithWhereWithoutControlTypesInput, ScreenTypeUpdateWithoutControlTypesInput>, ScreenTypeUncheckedUpdateWithoutControlTypesInput>
  }

  export type ControlTypeUpdateOneRequiredWithoutScreenTypesNestedInput = {
    create?: XOR<ControlTypeCreateWithoutScreenTypesInput, ControlTypeUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: ControlTypeCreateOrConnectWithoutScreenTypesInput
    upsert?: ControlTypeUpsertWithoutScreenTypesInput
    connect?: ControlTypeWhereUniqueInput
    update?: XOR<XOR<ControlTypeUpdateToOneWithWhereWithoutScreenTypesInput, ControlTypeUpdateWithoutScreenTypesInput>, ControlTypeUncheckedUpdateWithoutScreenTypesInput>
  }

  export type ScreenTypeCreateNestedOneWithoutSensorsInput = {
    create?: XOR<ScreenTypeCreateWithoutSensorsInput, ScreenTypeUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutSensorsInput
    connect?: ScreenTypeWhereUniqueInput
  }

  export type SensorCreateNestedOneWithoutScreenTypesInput = {
    create?: XOR<SensorCreateWithoutScreenTypesInput, SensorUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: SensorCreateOrConnectWithoutScreenTypesInput
    connect?: SensorWhereUniqueInput
  }

  export type ScreenTypeUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<ScreenTypeCreateWithoutSensorsInput, ScreenTypeUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ScreenTypeCreateOrConnectWithoutSensorsInput
    upsert?: ScreenTypeUpsertWithoutSensorsInput
    connect?: ScreenTypeWhereUniqueInput
    update?: XOR<XOR<ScreenTypeUpdateToOneWithWhereWithoutSensorsInput, ScreenTypeUpdateWithoutSensorsInput>, ScreenTypeUncheckedUpdateWithoutSensorsInput>
  }

  export type SensorUpdateOneRequiredWithoutScreenTypesNestedInput = {
    create?: XOR<SensorCreateWithoutScreenTypesInput, SensorUncheckedCreateWithoutScreenTypesInput>
    connectOrCreate?: SensorCreateOrConnectWithoutScreenTypesInput
    upsert?: SensorUpsertWithoutScreenTypesInput
    connect?: SensorWhereUniqueInput
    update?: XOR<XOR<SensorUpdateToOneWithWhereWithoutScreenTypesInput, SensorUpdateWithoutScreenTypesInput>, SensorUncheckedUpdateWithoutScreenTypesInput>
  }

  export type ItemCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ItemCreateWithoutCategoriesInput, ItemUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCategoriesInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ItemCreateWithoutCategoriesInput, ItemUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCategoriesInput
    upsert?: ItemUpsertWithoutCategoriesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCategoriesInput, ItemUpdateWithoutCategoriesInput>, ItemUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemCategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryUpsertWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutItemsInput, ItemCategoryUpdateWithoutItemsInput>, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<ItemCreateWithoutSubcategoriesInput, ItemUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSubcategoriesInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemSubcategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemSubcategoryCreateWithoutItemsInput, ItemSubcategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutItemsInput
    connect?: ItemSubcategoryWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<ItemCreateWithoutSubcategoriesInput, ItemUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSubcategoriesInput
    upsert?: ItemUpsertWithoutSubcategoriesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSubcategoriesInput, ItemUpdateWithoutSubcategoriesInput>, ItemUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemSubcategoryCreateWithoutItemsInput, ItemSubcategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemSubcategoryUpsertWithoutItemsInput
    connect?: ItemSubcategoryWhereUniqueInput
    update?: XOR<XOR<ItemSubcategoryUpdateToOneWithWhereWithoutItemsInput, ItemSubcategoryUpdateWithoutItemsInput>, ItemSubcategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCreateNestedOneWithoutPricesInput = {
    create?: XOR<ItemCreateWithoutPricesInput, ItemUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPricesInput
    connect?: ItemWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ItemUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ItemCreateWithoutPricesInput, ItemUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPricesInput
    upsert?: ItemUpsertWithoutPricesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPricesInput, ItemUpdateWithoutPricesInput>, ItemUncheckedUpdateWithoutPricesInput>
  }

  export type ItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<ItemCreateWithoutSuppliersInput, ItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSuppliersInput
    connect?: ItemWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutItemsInput = {
    create?: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<ItemCreateWithoutSuppliersInput, ItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSuppliersInput
    upsert?: ItemUpsertWithoutSuppliersInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSuppliersInput, ItemUpdateWithoutSuppliersInput>, ItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemsInput
    upsert?: SupplierUpsertWithoutItemsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutItemsInput, SupplierUpdateWithoutItemsInput>, SupplierUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<ItemCategoryCreateWithoutSubcategoriesInput, ItemCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ItemSubcategoryCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ItemSubcategoryCreateWithoutCategoriesInput, ItemSubcategoryUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutCategoriesInput
    connect?: ItemSubcategoryWhereUniqueInput
  }

  export type ItemCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutSubcategoriesInput, ItemCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: ItemCategoryUpsertWithoutSubcategoriesInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutSubcategoriesInput, ItemCategoryUpdateWithoutSubcategoriesInput>, ItemCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ItemSubcategoryCreateWithoutCategoriesInput, ItemSubcategoryUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutCategoriesInput
    upsert?: ItemSubcategoryUpsertWithoutCategoriesInput
    connect?: ItemSubcategoryWhereUniqueInput
    update?: XOR<XOR<ItemSubcategoryUpdateToOneWithWhereWithoutCategoriesInput, ItemSubcategoryUpdateWithoutCategoriesInput>, ItemSubcategoryUncheckedUpdateWithoutCategoriesInput>
  }

  export type CabinetCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<CabinetCreateWithoutCategoriesInput, CabinetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutCategoriesInput
    connect?: CabinetWhereUniqueInput
  }

  export type ItemCategoryCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<ItemCategoryCreateWithoutCabinetsInput, ItemCategoryUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutCabinetsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<CabinetCreateWithoutCategoriesInput, CabinetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutCategoriesInput
    upsert?: CabinetUpsertWithoutCategoriesInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutCategoriesInput, CabinetUpdateWithoutCategoriesInput>, CabinetUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemCategoryUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutCabinetsInput, ItemCategoryUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutCabinetsInput
    upsert?: ItemCategoryUpsertWithoutCabinetsInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutCabinetsInput, ItemCategoryUpdateWithoutCabinetsInput>, ItemCategoryUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CabinetCreateWithoutSubcategoriesInput, CabinetUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSubcategoriesInput
    connect?: CabinetWhereUniqueInput
  }

  export type ItemSubcategoryCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<ItemSubcategoryCreateWithoutCabinetsInput, ItemSubcategoryUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutCabinetsInput
    connect?: ItemSubcategoryWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<CabinetCreateWithoutSubcategoriesInput, CabinetUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSubcategoriesInput
    upsert?: CabinetUpsertWithoutSubcategoriesInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutSubcategoriesInput, CabinetUpdateWithoutSubcategoriesInput>, CabinetUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<ItemSubcategoryCreateWithoutCabinetsInput, ItemSubcategoryUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutCabinetsInput
    upsert?: ItemSubcategoryUpsertWithoutCabinetsInput
    connect?: ItemSubcategoryWhereUniqueInput
    update?: XOR<XOR<ItemSubcategoryUpdateToOneWithWhereWithoutCabinetsInput, ItemSubcategoryUpdateWithoutCabinetsInput>, ItemSubcategoryUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutLocationsInput = {
    create?: XOR<CabinetCreateWithoutLocationsInput, CabinetUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutLocationsInput
    connect?: CabinetWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<LocationCreateWithoutCabinetsInput, LocationUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCabinetsInput
    connect?: LocationWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<CabinetCreateWithoutLocationsInput, CabinetUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutLocationsInput
    upsert?: CabinetUpsertWithoutLocationsInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutLocationsInput, CabinetUpdateWithoutLocationsInput>, CabinetUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<LocationCreateWithoutCabinetsInput, LocationUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCabinetsInput
    upsert?: LocationUpsertWithoutCabinetsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutCabinetsInput, LocationUpdateWithoutCabinetsInput>, LocationUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<CabinetCreateWithoutPlacementsInput, CabinetUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPlacementsInput
    connect?: CabinetWhereUniqueInput
  }

  export type PlacementCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<PlacementCreateWithoutCabinetsInput, PlacementUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: PlacementCreateOrConnectWithoutCabinetsInput
    connect?: PlacementWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<CabinetCreateWithoutPlacementsInput, CabinetUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPlacementsInput
    upsert?: CabinetUpsertWithoutPlacementsInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutPlacementsInput, CabinetUpdateWithoutPlacementsInput>, CabinetUncheckedUpdateWithoutPlacementsInput>
  }

  export type PlacementUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<PlacementCreateWithoutCabinetsInput, PlacementUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: PlacementCreateOrConnectWithoutCabinetsInput
    upsert?: PlacementUpsertWithoutCabinetsInput
    connect?: PlacementWhereUniqueInput
    update?: XOR<XOR<PlacementUpdateToOneWithWhereWithoutCabinetsInput, PlacementUpdateWithoutCabinetsInput>, PlacementUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<CabinetCreateWithoutMaterialsInput, CabinetUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutMaterialsInput
    connect?: CabinetWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<MaterialCreateWithoutCabinetsInput, MaterialUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCabinetsInput
    connect?: MaterialWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<CabinetCreateWithoutMaterialsInput, CabinetUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutMaterialsInput
    upsert?: CabinetUpsertWithoutMaterialsInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutMaterialsInput, CabinetUpdateWithoutMaterialsInput>, CabinetUncheckedUpdateWithoutMaterialsInput>
  }

  export type MaterialUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<MaterialCreateWithoutCabinetsInput, MaterialUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCabinetsInput
    upsert?: MaterialUpsertWithoutCabinetsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutCabinetsInput, MaterialUpdateWithoutCabinetsInput>, MaterialUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutSizesInput = {
    create?: XOR<CabinetCreateWithoutSizesInput, CabinetUncheckedCreateWithoutSizesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSizesInput
    connect?: CabinetWhereUniqueInput
  }

  export type CabinetSizeCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<CabinetSizeCreateWithoutCabinetsInput, CabinetSizeUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: CabinetSizeCreateOrConnectWithoutCabinetsInput
    connect?: CabinetSizeWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutSizesNestedInput = {
    create?: XOR<CabinetCreateWithoutSizesInput, CabinetUncheckedCreateWithoutSizesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSizesInput
    upsert?: CabinetUpsertWithoutSizesInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutSizesInput, CabinetUpdateWithoutSizesInput>, CabinetUncheckedUpdateWithoutSizesInput>
  }

  export type CabinetSizeUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<CabinetSizeCreateWithoutCabinetsInput, CabinetSizeUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: CabinetSizeCreateOrConnectWithoutCabinetsInput
    upsert?: CabinetSizeUpsertWithoutCabinetsInput
    connect?: CabinetSizeWhereUniqueInput
    update?: XOR<XOR<CabinetSizeUpdateToOneWithWhereWithoutCabinetsInput, CabinetSizeUpdateWithoutCabinetsInput>, CabinetSizeUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutPitchesInput = {
    create?: XOR<CabinetCreateWithoutPitchesInput, CabinetUncheckedCreateWithoutPitchesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPitchesInput
    connect?: CabinetWhereUniqueInput
  }

  export type PitchCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<PitchCreateWithoutCabinetsInput, PitchUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: PitchCreateOrConnectWithoutCabinetsInput
    connect?: PitchWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutPitchesNestedInput = {
    create?: XOR<CabinetCreateWithoutPitchesInput, CabinetUncheckedCreateWithoutPitchesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPitchesInput
    upsert?: CabinetUpsertWithoutPitchesInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutPitchesInput, CabinetUpdateWithoutPitchesInput>, CabinetUncheckedUpdateWithoutPitchesInput>
  }

  export type PitchUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<PitchCreateWithoutCabinetsInput, PitchUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: PitchCreateOrConnectWithoutCabinetsInput
    upsert?: PitchUpsertWithoutCabinetsInput
    connect?: PitchWhereUniqueInput
    update?: XOR<XOR<PitchUpdateToOneWithWhereWithoutCabinetsInput, PitchUpdateWithoutCabinetsInput>, PitchUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutManufacturersInput = {
    create?: XOR<CabinetCreateWithoutManufacturersInput, CabinetUncheckedCreateWithoutManufacturersInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutManufacturersInput
    connect?: CabinetWhereUniqueInput
  }

  export type ManufacturerCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<ManufacturerCreateWithoutCabinetsInput, ManufacturerUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutCabinetsInput
    connect?: ManufacturerWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutManufacturersNestedInput = {
    create?: XOR<CabinetCreateWithoutManufacturersInput, CabinetUncheckedCreateWithoutManufacturersInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutManufacturersInput
    upsert?: CabinetUpsertWithoutManufacturersInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutManufacturersInput, CabinetUpdateWithoutManufacturersInput>, CabinetUncheckedUpdateWithoutManufacturersInput>
  }

  export type ManufacturerUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<ManufacturerCreateWithoutCabinetsInput, ManufacturerUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutCabinetsInput
    upsert?: ManufacturerUpsertWithoutCabinetsInput
    connect?: ManufacturerWhereUniqueInput
    update?: XOR<XOR<ManufacturerUpdateToOneWithWhereWithoutCabinetsInput, ManufacturerUpdateWithoutCabinetsInput>, ManufacturerUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<CabinetCreateWithoutSuppliersInput, CabinetUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSuppliersInput
    connect?: CabinetWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<SupplierCreateWithoutCabinetsInput, SupplierUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCabinetsInput
    connect?: SupplierWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<CabinetCreateWithoutSuppliersInput, CabinetUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutSuppliersInput
    upsert?: CabinetUpsertWithoutSuppliersInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutSuppliersInput, CabinetUpdateWithoutSuppliersInput>, CabinetUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<SupplierCreateWithoutCabinetsInput, SupplierUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCabinetsInput
    upsert?: SupplierUpsertWithoutCabinetsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutCabinetsInput, SupplierUpdateWithoutCabinetsInput>, SupplierUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutItemsInput = {
    create?: XOR<CabinetCreateWithoutItemsInput, CabinetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutItemsInput
    connect?: CabinetWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutCabinetsInput = {
    create?: XOR<ItemCreateWithoutCabinetsInput, ItemUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCabinetsInput
    connect?: ItemWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CabinetCreateWithoutItemsInput, CabinetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutItemsInput
    upsert?: CabinetUpsertWithoutItemsInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutItemsInput, CabinetUpdateWithoutItemsInput>, CabinetUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutCabinetsNestedInput = {
    create?: XOR<ItemCreateWithoutCabinetsInput, ItemUncheckedCreateWithoutCabinetsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCabinetsInput
    upsert?: ItemUpsertWithoutCabinetsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCabinetsInput, ItemUpdateWithoutCabinetsInput>, ItemUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetCreateNestedOneWithoutPricesInput = {
    create?: XOR<CabinetCreateWithoutPricesInput, CabinetUncheckedCreateWithoutPricesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPricesInput
    connect?: CabinetWhereUniqueInput
  }

  export type CabinetUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<CabinetCreateWithoutPricesInput, CabinetUncheckedCreateWithoutPricesInput>
    connectOrCreate?: CabinetCreateOrConnectWithoutPricesInput
    upsert?: CabinetUpsertWithoutPricesInput
    connect?: CabinetWhereUniqueInput
    update?: XOR<XOR<CabinetUpdateToOneWithWhereWithoutPricesInput, CabinetUpdateWithoutPricesInput>, CabinetUncheckedUpdateWithoutPricesInput>
  }

  export type ModuleCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ModuleCreateWithoutCategoriesInput, ModuleUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCategoriesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ItemCategoryCreateNestedOneWithoutModulesInput = {
    create?: XOR<ItemCategoryCreateWithoutModulesInput, ItemCategoryUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutModulesInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ModuleCreateWithoutCategoriesInput, ModuleUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCategoriesInput
    upsert?: ModuleUpsertWithoutCategoriesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutCategoriesInput, ModuleUpdateWithoutCategoriesInput>, ModuleUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemCategoryUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutModulesInput, ItemCategoryUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutModulesInput
    upsert?: ItemCategoryUpsertWithoutModulesInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutModulesInput, ItemCategoryUpdateWithoutModulesInput>, ItemCategoryUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<ModuleCreateWithoutSubcategoriesInput, ModuleUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSubcategoriesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ItemSubcategoryCreateNestedOneWithoutModulesInput = {
    create?: XOR<ItemSubcategoryCreateWithoutModulesInput, ItemSubcategoryUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutModulesInput
    connect?: ItemSubcategoryWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<ModuleCreateWithoutSubcategoriesInput, ModuleUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSubcategoriesInput
    upsert?: ModuleUpsertWithoutSubcategoriesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutSubcategoriesInput, ModuleUpdateWithoutSubcategoriesInput>, ModuleUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ItemSubcategoryCreateWithoutModulesInput, ItemSubcategoryUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemSubcategoryCreateOrConnectWithoutModulesInput
    upsert?: ItemSubcategoryUpsertWithoutModulesInput
    connect?: ItemSubcategoryWhereUniqueInput
    update?: XOR<XOR<ItemSubcategoryUpdateToOneWithWhereWithoutModulesInput, ItemSubcategoryUpdateWithoutModulesInput>, ItemSubcategoryUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ModuleCreateWithoutLocationsInput, ModuleUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLocationsInput
    connect?: ModuleWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutModulesInput = {
    create?: XOR<LocationCreateWithoutModulesInput, LocationUncheckedCreateWithoutModulesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutModulesInput
    connect?: LocationWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ModuleCreateWithoutLocationsInput, ModuleUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLocationsInput
    upsert?: ModuleUpsertWithoutLocationsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutLocationsInput, ModuleUpdateWithoutLocationsInput>, ModuleUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<LocationCreateWithoutModulesInput, LocationUncheckedCreateWithoutModulesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutModulesInput
    upsert?: LocationUpsertWithoutModulesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutModulesInput, LocationUpdateWithoutModulesInput>, LocationUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutRefreshRatesInput = {
    create?: XOR<ModuleCreateWithoutRefreshRatesInput, ModuleUncheckedCreateWithoutRefreshRatesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutRefreshRatesInput
    connect?: ModuleWhereUniqueInput
  }

  export type RefreshRateCreateNestedOneWithoutModulesInput = {
    create?: XOR<RefreshRateCreateWithoutModulesInput, RefreshRateUncheckedCreateWithoutModulesInput>
    connectOrCreate?: RefreshRateCreateOrConnectWithoutModulesInput
    connect?: RefreshRateWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutRefreshRatesNestedInput = {
    create?: XOR<ModuleCreateWithoutRefreshRatesInput, ModuleUncheckedCreateWithoutRefreshRatesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutRefreshRatesInput
    upsert?: ModuleUpsertWithoutRefreshRatesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutRefreshRatesInput, ModuleUpdateWithoutRefreshRatesInput>, ModuleUncheckedUpdateWithoutRefreshRatesInput>
  }

  export type RefreshRateUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<RefreshRateCreateWithoutModulesInput, RefreshRateUncheckedCreateWithoutModulesInput>
    connectOrCreate?: RefreshRateCreateOrConnectWithoutModulesInput
    upsert?: RefreshRateUpsertWithoutModulesInput
    connect?: RefreshRateWhereUniqueInput
    update?: XOR<XOR<RefreshRateUpdateToOneWithWhereWithoutModulesInput, RefreshRateUpdateWithoutModulesInput>, RefreshRateUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutBrightnessesInput = {
    create?: XOR<ModuleCreateWithoutBrightnessesInput, ModuleUncheckedCreateWithoutBrightnessesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutBrightnessesInput
    connect?: ModuleWhereUniqueInput
  }

  export type BrightnessCreateNestedOneWithoutModulesInput = {
    create?: XOR<BrightnessCreateWithoutModulesInput, BrightnessUncheckedCreateWithoutModulesInput>
    connectOrCreate?: BrightnessCreateOrConnectWithoutModulesInput
    connect?: BrightnessWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutBrightnessesNestedInput = {
    create?: XOR<ModuleCreateWithoutBrightnessesInput, ModuleUncheckedCreateWithoutBrightnessesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutBrightnessesInput
    upsert?: ModuleUpsertWithoutBrightnessesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutBrightnessesInput, ModuleUpdateWithoutBrightnessesInput>, ModuleUncheckedUpdateWithoutBrightnessesInput>
  }

  export type BrightnessUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<BrightnessCreateWithoutModulesInput, BrightnessUncheckedCreateWithoutModulesInput>
    connectOrCreate?: BrightnessCreateOrConnectWithoutModulesInput
    upsert?: BrightnessUpsertWithoutModulesInput
    connect?: BrightnessWhereUniqueInput
    update?: XOR<XOR<BrightnessUpdateToOneWithWhereWithoutModulesInput, BrightnessUpdateWithoutModulesInput>, BrightnessUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutSizesInput = {
    create?: XOR<ModuleCreateWithoutSizesInput, ModuleUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSizesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleSizeCreateNestedOneWithoutModulesInput = {
    create?: XOR<ModuleSizeCreateWithoutModulesInput, ModuleSizeUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ModuleSizeCreateOrConnectWithoutModulesInput
    connect?: ModuleSizeWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutSizesNestedInput = {
    create?: XOR<ModuleCreateWithoutSizesInput, ModuleUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSizesInput
    upsert?: ModuleUpsertWithoutSizesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutSizesInput, ModuleUpdateWithoutSizesInput>, ModuleUncheckedUpdateWithoutSizesInput>
  }

  export type ModuleSizeUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ModuleSizeCreateWithoutModulesInput, ModuleSizeUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ModuleSizeCreateOrConnectWithoutModulesInput
    upsert?: ModuleSizeUpsertWithoutModulesInput
    connect?: ModuleSizeWhereUniqueInput
    update?: XOR<XOR<ModuleSizeUpdateToOneWithWhereWithoutModulesInput, ModuleSizeUpdateWithoutModulesInput>, ModuleSizeUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutPitchesInput = {
    create?: XOR<ModuleCreateWithoutPitchesInput, ModuleUncheckedCreateWithoutPitchesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPitchesInput
    connect?: ModuleWhereUniqueInput
  }

  export type PitchCreateNestedOneWithoutModulesInput = {
    create?: XOR<PitchCreateWithoutModulesInput, PitchUncheckedCreateWithoutModulesInput>
    connectOrCreate?: PitchCreateOrConnectWithoutModulesInput
    connect?: PitchWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutPitchesNestedInput = {
    create?: XOR<ModuleCreateWithoutPitchesInput, ModuleUncheckedCreateWithoutPitchesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPitchesInput
    upsert?: ModuleUpsertWithoutPitchesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutPitchesInput, ModuleUpdateWithoutPitchesInput>, ModuleUncheckedUpdateWithoutPitchesInput>
  }

  export type PitchUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<PitchCreateWithoutModulesInput, PitchUncheckedCreateWithoutModulesInput>
    connectOrCreate?: PitchCreateOrConnectWithoutModulesInput
    upsert?: PitchUpsertWithoutModulesInput
    connect?: PitchWhereUniqueInput
    update?: XOR<XOR<PitchUpdateToOneWithWhereWithoutModulesInput, PitchUpdateWithoutModulesInput>, PitchUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutManufacturersInput = {
    create?: XOR<ModuleCreateWithoutManufacturersInput, ModuleUncheckedCreateWithoutManufacturersInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutManufacturersInput
    connect?: ModuleWhereUniqueInput
  }

  export type ManufacturerCreateNestedOneWithoutModulesInput = {
    create?: XOR<ManufacturerCreateWithoutModulesInput, ManufacturerUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutModulesInput
    connect?: ManufacturerWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutManufacturersNestedInput = {
    create?: XOR<ModuleCreateWithoutManufacturersInput, ModuleUncheckedCreateWithoutManufacturersInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutManufacturersInput
    upsert?: ModuleUpsertWithoutManufacturersInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutManufacturersInput, ModuleUpdateWithoutManufacturersInput>, ModuleUncheckedUpdateWithoutManufacturersInput>
  }

  export type ManufacturerUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ManufacturerCreateWithoutModulesInput, ManufacturerUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutModulesInput
    upsert?: ManufacturerUpsertWithoutModulesInput
    connect?: ManufacturerWhereUniqueInput
    update?: XOR<XOR<ManufacturerUpdateToOneWithWhereWithoutModulesInput, ManufacturerUpdateWithoutModulesInput>, ManufacturerUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutItemsInput = {
    create?: XOR<ModuleCreateWithoutItemsInput, ModuleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutItemsInput
    connect?: ModuleWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutModulesInput = {
    create?: XOR<ItemCreateWithoutModulesInput, ItemUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutModulesInput
    connect?: ItemWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ModuleCreateWithoutItemsInput, ModuleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutItemsInput
    upsert?: ModuleUpsertWithoutItemsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutItemsInput, ModuleUpdateWithoutItemsInput>, ModuleUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ItemCreateWithoutModulesInput, ItemUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutModulesInput
    upsert?: ItemUpsertWithoutModulesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutModulesInput, ItemUpdateWithoutModulesInput>, ItemUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ModuleCreateWithoutOptionsInput, ModuleUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutOptionsInput
    connect?: ModuleWhereUniqueInput
  }

  export type OptionCreateNestedOneWithoutModulesInput = {
    create?: XOR<OptionCreateWithoutModulesInput, OptionUncheckedCreateWithoutModulesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutModulesInput
    connect?: OptionWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ModuleCreateWithoutOptionsInput, ModuleUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutOptionsInput
    upsert?: ModuleUpsertWithoutOptionsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutOptionsInput, ModuleUpdateWithoutOptionsInput>, ModuleUncheckedUpdateWithoutOptionsInput>
  }

  export type OptionUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<OptionCreateWithoutModulesInput, OptionUncheckedCreateWithoutModulesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutModulesInput
    upsert?: OptionUpsertWithoutModulesInput
    connect?: OptionWhereUniqueInput
    update?: XOR<XOR<OptionUpdateToOneWithWhereWithoutModulesInput, OptionUpdateWithoutModulesInput>, OptionUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleCreateNestedOneWithoutPricesInput = {
    create?: XOR<ModuleCreateWithoutPricesInput, ModuleUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPricesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ModuleCreateWithoutPricesInput, ModuleUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPricesInput
    upsert?: ModuleUpsertWithoutPricesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutPricesInput, ModuleUpdateWithoutPricesInput>, ModuleUncheckedUpdateWithoutPricesInput>
  }

  export type CabinetSizeCreateNestedOneWithoutModuleSizesInput = {
    create?: XOR<CabinetSizeCreateWithoutModuleSizesInput, CabinetSizeUncheckedCreateWithoutModuleSizesInput>
    connectOrCreate?: CabinetSizeCreateOrConnectWithoutModuleSizesInput
    connect?: CabinetSizeWhereUniqueInput
  }

  export type ModuleSizeCreateNestedOneWithoutCabinetSizesInput = {
    create?: XOR<ModuleSizeCreateWithoutCabinetSizesInput, ModuleSizeUncheckedCreateWithoutCabinetSizesInput>
    connectOrCreate?: ModuleSizeCreateOrConnectWithoutCabinetSizesInput
    connect?: ModuleSizeWhereUniqueInput
  }

  export type CabinetSizeUpdateOneRequiredWithoutModuleSizesNestedInput = {
    create?: XOR<CabinetSizeCreateWithoutModuleSizesInput, CabinetSizeUncheckedCreateWithoutModuleSizesInput>
    connectOrCreate?: CabinetSizeCreateOrConnectWithoutModuleSizesInput
    upsert?: CabinetSizeUpsertWithoutModuleSizesInput
    connect?: CabinetSizeWhereUniqueInput
    update?: XOR<XOR<CabinetSizeUpdateToOneWithWhereWithoutModuleSizesInput, CabinetSizeUpdateWithoutModuleSizesInput>, CabinetSizeUncheckedUpdateWithoutModuleSizesInput>
  }

  export type ModuleSizeUpdateOneRequiredWithoutCabinetSizesNestedInput = {
    create?: XOR<ModuleSizeCreateWithoutCabinetSizesInput, ModuleSizeUncheckedCreateWithoutCabinetSizesInput>
    connectOrCreate?: ModuleSizeCreateOrConnectWithoutCabinetSizesInput
    upsert?: ModuleSizeUpsertWithoutCabinetSizesInput
    connect?: ModuleSizeWhereUniqueInput
    update?: XOR<XOR<ModuleSizeUpdateToOneWithWhereWithoutCabinetSizesInput, ModuleSizeUpdateWithoutCabinetSizesInput>, ModuleSizeUncheckedUpdateWithoutCabinetSizesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ScreenTypeOptionCreateWithoutScreenTypeInput = {
    option: OptionCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput = {
    optionCode: string
  }

  export type ScreenTypeOptionCreateOrConnectWithoutScreenTypeInput = {
    where: ScreenTypeOptionWhereUniqueInput
    create: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeOptionCreateManyScreenTypeInputEnvelope = {
    data: ScreenTypeOptionCreateManyScreenTypeInput | ScreenTypeOptionCreateManyScreenTypeInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeControlTypeCreateWithoutScreenTypeInput = {
    controlType: ControlTypeCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput = {
    controlTypeCode: string
  }

  export type ScreenTypeControlTypeCreateOrConnectWithoutScreenTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    create: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeControlTypeCreateManyScreenTypeInputEnvelope = {
    data: ScreenTypeControlTypeCreateManyScreenTypeInput | ScreenTypeControlTypeCreateManyScreenTypeInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeSensorCreateWithoutScreenTypeInput = {
    sensor: SensorCreateNestedOneWithoutScreenTypesInput
  }

  export type ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput = {
    sensorCode: string
  }

  export type ScreenTypeSensorCreateOrConnectWithoutScreenTypeInput = {
    where: ScreenTypeSensorWhereUniqueInput
    create: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeSensorCreateManyScreenTypeInputEnvelope = {
    data: ScreenTypeSensorCreateManyScreenTypeInput | ScreenTypeSensorCreateManyScreenTypeInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeOptionUpsertWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeOptionWhereUniqueInput
    update: XOR<ScreenTypeOptionUpdateWithoutScreenTypeInput, ScreenTypeOptionUncheckedUpdateWithoutScreenTypeInput>
    create: XOR<ScreenTypeOptionCreateWithoutScreenTypeInput, ScreenTypeOptionUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeOptionUpdateWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeOptionWhereUniqueInput
    data: XOR<ScreenTypeOptionUpdateWithoutScreenTypeInput, ScreenTypeOptionUncheckedUpdateWithoutScreenTypeInput>
  }

  export type ScreenTypeOptionUpdateManyWithWhereWithoutScreenTypeInput = {
    where: ScreenTypeOptionScalarWhereInput
    data: XOR<ScreenTypeOptionUpdateManyMutationInput, ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeInput>
  }

  export type ScreenTypeOptionScalarWhereInput = {
    AND?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
    OR?: ScreenTypeOptionScalarWhereInput[]
    NOT?: ScreenTypeOptionScalarWhereInput | ScreenTypeOptionScalarWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeOption"> | string
    optionCode?: StringFilter<"ScreenTypeOption"> | string
  }

  export type ScreenTypeControlTypeUpsertWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    update: XOR<ScreenTypeControlTypeUpdateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedUpdateWithoutScreenTypeInput>
    create: XOR<ScreenTypeControlTypeCreateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeControlTypeUpdateWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    data: XOR<ScreenTypeControlTypeUpdateWithoutScreenTypeInput, ScreenTypeControlTypeUncheckedUpdateWithoutScreenTypeInput>
  }

  export type ScreenTypeControlTypeUpdateManyWithWhereWithoutScreenTypeInput = {
    where: ScreenTypeControlTypeScalarWhereInput
    data: XOR<ScreenTypeControlTypeUpdateManyMutationInput, ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeInput>
  }

  export type ScreenTypeControlTypeScalarWhereInput = {
    AND?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
    OR?: ScreenTypeControlTypeScalarWhereInput[]
    NOT?: ScreenTypeControlTypeScalarWhereInput | ScreenTypeControlTypeScalarWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeControlType"> | string
    controlTypeCode?: StringFilter<"ScreenTypeControlType"> | string
  }

  export type ScreenTypeSensorUpsertWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeSensorWhereUniqueInput
    update: XOR<ScreenTypeSensorUpdateWithoutScreenTypeInput, ScreenTypeSensorUncheckedUpdateWithoutScreenTypeInput>
    create: XOR<ScreenTypeSensorCreateWithoutScreenTypeInput, ScreenTypeSensorUncheckedCreateWithoutScreenTypeInput>
  }

  export type ScreenTypeSensorUpdateWithWhereUniqueWithoutScreenTypeInput = {
    where: ScreenTypeSensorWhereUniqueInput
    data: XOR<ScreenTypeSensorUpdateWithoutScreenTypeInput, ScreenTypeSensorUncheckedUpdateWithoutScreenTypeInput>
  }

  export type ScreenTypeSensorUpdateManyWithWhereWithoutScreenTypeInput = {
    where: ScreenTypeSensorScalarWhereInput
    data: XOR<ScreenTypeSensorUpdateManyMutationInput, ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeInput>
  }

  export type ScreenTypeSensorScalarWhereInput = {
    AND?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
    OR?: ScreenTypeSensorScalarWhereInput[]
    NOT?: ScreenTypeSensorScalarWhereInput | ScreenTypeSensorScalarWhereInput[]
    screenTypeCode?: StringFilter<"ScreenTypeSensor"> | string
    sensorCode?: StringFilter<"ScreenTypeSensor"> | string
  }

  export type CabinetMaterialCreateWithoutMaterialInput = {
    cabinet: CabinetCreateNestedOneWithoutMaterialsInput
  }

  export type CabinetMaterialUncheckedCreateWithoutMaterialInput = {
    cabinetCode: string
  }

  export type CabinetMaterialCreateOrConnectWithoutMaterialInput = {
    where: CabinetMaterialWhereUniqueInput
    create: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type CabinetMaterialCreateManyMaterialInputEnvelope = {
    data: CabinetMaterialCreateManyMaterialInput | CabinetMaterialCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type CabinetMaterialUpsertWithWhereUniqueWithoutMaterialInput = {
    where: CabinetMaterialWhereUniqueInput
    update: XOR<CabinetMaterialUpdateWithoutMaterialInput, CabinetMaterialUncheckedUpdateWithoutMaterialInput>
    create: XOR<CabinetMaterialCreateWithoutMaterialInput, CabinetMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type CabinetMaterialUpdateWithWhereUniqueWithoutMaterialInput = {
    where: CabinetMaterialWhereUniqueInput
    data: XOR<CabinetMaterialUpdateWithoutMaterialInput, CabinetMaterialUncheckedUpdateWithoutMaterialInput>
  }

  export type CabinetMaterialUpdateManyWithWhereWithoutMaterialInput = {
    where: CabinetMaterialScalarWhereInput
    data: XOR<CabinetMaterialUpdateManyMutationInput, CabinetMaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type CabinetMaterialScalarWhereInput = {
    AND?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
    OR?: CabinetMaterialScalarWhereInput[]
    NOT?: CabinetMaterialScalarWhereInput | CabinetMaterialScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetMaterial"> | string
    materialCode?: StringFilter<"CabinetMaterial"> | string
  }

  export type CabinetLocationCreateWithoutLocationInput = {
    cabinet: CabinetCreateNestedOneWithoutLocationsInput
  }

  export type CabinetLocationUncheckedCreateWithoutLocationInput = {
    cabinetCode: string
  }

  export type CabinetLocationCreateOrConnectWithoutLocationInput = {
    where: CabinetLocationWhereUniqueInput
    create: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput>
  }

  export type CabinetLocationCreateManyLocationInputEnvelope = {
    data: CabinetLocationCreateManyLocationInput | CabinetLocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ModuleLocationCreateWithoutLocationInput = {
    module: ModuleCreateNestedOneWithoutLocationsInput
  }

  export type ModuleLocationUncheckedCreateWithoutLocationInput = {
    moduleCode: string
  }

  export type ModuleLocationCreateOrConnectWithoutLocationInput = {
    where: ModuleLocationWhereUniqueInput
    create: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput>
  }

  export type ModuleLocationCreateManyLocationInputEnvelope = {
    data: ModuleLocationCreateManyLocationInput | ModuleLocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type CabinetLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: CabinetLocationWhereUniqueInput
    update: XOR<CabinetLocationUpdateWithoutLocationInput, CabinetLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<CabinetLocationCreateWithoutLocationInput, CabinetLocationUncheckedCreateWithoutLocationInput>
  }

  export type CabinetLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: CabinetLocationWhereUniqueInput
    data: XOR<CabinetLocationUpdateWithoutLocationInput, CabinetLocationUncheckedUpdateWithoutLocationInput>
  }

  export type CabinetLocationUpdateManyWithWhereWithoutLocationInput = {
    where: CabinetLocationScalarWhereInput
    data: XOR<CabinetLocationUpdateManyMutationInput, CabinetLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type CabinetLocationScalarWhereInput = {
    AND?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
    OR?: CabinetLocationScalarWhereInput[]
    NOT?: CabinetLocationScalarWhereInput | CabinetLocationScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetLocation"> | string
    locationCode?: StringFilter<"CabinetLocation"> | string
  }

  export type ModuleLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: ModuleLocationWhereUniqueInput
    update: XOR<ModuleLocationUpdateWithoutLocationInput, ModuleLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<ModuleLocationCreateWithoutLocationInput, ModuleLocationUncheckedCreateWithoutLocationInput>
  }

  export type ModuleLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: ModuleLocationWhereUniqueInput
    data: XOR<ModuleLocationUpdateWithoutLocationInput, ModuleLocationUncheckedUpdateWithoutLocationInput>
  }

  export type ModuleLocationUpdateManyWithWhereWithoutLocationInput = {
    where: ModuleLocationScalarWhereInput
    data: XOR<ModuleLocationUpdateManyMutationInput, ModuleLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type ModuleLocationScalarWhereInput = {
    AND?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
    OR?: ModuleLocationScalarWhereInput[]
    NOT?: ModuleLocationScalarWhereInput | ModuleLocationScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleLocation"> | string
    locationCode?: StringFilter<"ModuleLocation"> | string
  }

  export type CabinetPlacementCreateWithoutPlacementInput = {
    cabinet: CabinetCreateNestedOneWithoutPlacementsInput
  }

  export type CabinetPlacementUncheckedCreateWithoutPlacementInput = {
    cabinetCode: string
  }

  export type CabinetPlacementCreateOrConnectWithoutPlacementInput = {
    where: CabinetPlacementWhereUniqueInput
    create: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput>
  }

  export type CabinetPlacementCreateManyPlacementInputEnvelope = {
    data: CabinetPlacementCreateManyPlacementInput | CabinetPlacementCreateManyPlacementInput[]
    skipDuplicates?: boolean
  }

  export type CabinetPlacementUpsertWithWhereUniqueWithoutPlacementInput = {
    where: CabinetPlacementWhereUniqueInput
    update: XOR<CabinetPlacementUpdateWithoutPlacementInput, CabinetPlacementUncheckedUpdateWithoutPlacementInput>
    create: XOR<CabinetPlacementCreateWithoutPlacementInput, CabinetPlacementUncheckedCreateWithoutPlacementInput>
  }

  export type CabinetPlacementUpdateWithWhereUniqueWithoutPlacementInput = {
    where: CabinetPlacementWhereUniqueInput
    data: XOR<CabinetPlacementUpdateWithoutPlacementInput, CabinetPlacementUncheckedUpdateWithoutPlacementInput>
  }

  export type CabinetPlacementUpdateManyWithWhereWithoutPlacementInput = {
    where: CabinetPlacementScalarWhereInput
    data: XOR<CabinetPlacementUpdateManyMutationInput, CabinetPlacementUncheckedUpdateManyWithoutPlacementInput>
  }

  export type CabinetPlacementScalarWhereInput = {
    AND?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
    OR?: CabinetPlacementScalarWhereInput[]
    NOT?: CabinetPlacementScalarWhereInput | CabinetPlacementScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetPlacement"> | string
    placementCode?: StringFilter<"CabinetPlacement"> | string
  }

  export type ScreenTypeOptionCreateWithoutOptionInput = {
    screenType: ScreenTypeCreateNestedOneWithoutOptionsInput
  }

  export type ScreenTypeOptionUncheckedCreateWithoutOptionInput = {
    screenTypeCode: string
  }

  export type ScreenTypeOptionCreateOrConnectWithoutOptionInput = {
    where: ScreenTypeOptionWhereUniqueInput
    create: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput>
  }

  export type ScreenTypeOptionCreateManyOptionInputEnvelope = {
    data: ScreenTypeOptionCreateManyOptionInput | ScreenTypeOptionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type ModuleOptionCreateWithoutOptionInput = {
    module: ModuleCreateNestedOneWithoutOptionsInput
  }

  export type ModuleOptionUncheckedCreateWithoutOptionInput = {
    moduleCode: string
  }

  export type ModuleOptionCreateOrConnectWithoutOptionInput = {
    where: ModuleOptionWhereUniqueInput
    create: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput>
  }

  export type ModuleOptionCreateManyOptionInputEnvelope = {
    data: ModuleOptionCreateManyOptionInput | ModuleOptionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeOptionUpsertWithWhereUniqueWithoutOptionInput = {
    where: ScreenTypeOptionWhereUniqueInput
    update: XOR<ScreenTypeOptionUpdateWithoutOptionInput, ScreenTypeOptionUncheckedUpdateWithoutOptionInput>
    create: XOR<ScreenTypeOptionCreateWithoutOptionInput, ScreenTypeOptionUncheckedCreateWithoutOptionInput>
  }

  export type ScreenTypeOptionUpdateWithWhereUniqueWithoutOptionInput = {
    where: ScreenTypeOptionWhereUniqueInput
    data: XOR<ScreenTypeOptionUpdateWithoutOptionInput, ScreenTypeOptionUncheckedUpdateWithoutOptionInput>
  }

  export type ScreenTypeOptionUpdateManyWithWhereWithoutOptionInput = {
    where: ScreenTypeOptionScalarWhereInput
    data: XOR<ScreenTypeOptionUpdateManyMutationInput, ScreenTypeOptionUncheckedUpdateManyWithoutOptionInput>
  }

  export type ModuleOptionUpsertWithWhereUniqueWithoutOptionInput = {
    where: ModuleOptionWhereUniqueInput
    update: XOR<ModuleOptionUpdateWithoutOptionInput, ModuleOptionUncheckedUpdateWithoutOptionInput>
    create: XOR<ModuleOptionCreateWithoutOptionInput, ModuleOptionUncheckedCreateWithoutOptionInput>
  }

  export type ModuleOptionUpdateWithWhereUniqueWithoutOptionInput = {
    where: ModuleOptionWhereUniqueInput
    data: XOR<ModuleOptionUpdateWithoutOptionInput, ModuleOptionUncheckedUpdateWithoutOptionInput>
  }

  export type ModuleOptionUpdateManyWithWhereWithoutOptionInput = {
    where: ModuleOptionScalarWhereInput
    data: XOR<ModuleOptionUpdateManyMutationInput, ModuleOptionUncheckedUpdateManyWithoutOptionInput>
  }

  export type ModuleOptionScalarWhereInput = {
    AND?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
    OR?: ModuleOptionScalarWhereInput[]
    NOT?: ModuleOptionScalarWhereInput | ModuleOptionScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleOption"> | string
    optionCode?: StringFilter<"ModuleOption"> | string
  }

  export type ScreenTypeSensorCreateWithoutSensorInput = {
    screenType: ScreenTypeCreateNestedOneWithoutSensorsInput
  }

  export type ScreenTypeSensorUncheckedCreateWithoutSensorInput = {
    screenTypeCode: string
  }

  export type ScreenTypeSensorCreateOrConnectWithoutSensorInput = {
    where: ScreenTypeSensorWhereUniqueInput
    create: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput>
  }

  export type ScreenTypeSensorCreateManySensorInputEnvelope = {
    data: ScreenTypeSensorCreateManySensorInput | ScreenTypeSensorCreateManySensorInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeSensorUpsertWithWhereUniqueWithoutSensorInput = {
    where: ScreenTypeSensorWhereUniqueInput
    update: XOR<ScreenTypeSensorUpdateWithoutSensorInput, ScreenTypeSensorUncheckedUpdateWithoutSensorInput>
    create: XOR<ScreenTypeSensorCreateWithoutSensorInput, ScreenTypeSensorUncheckedCreateWithoutSensorInput>
  }

  export type ScreenTypeSensorUpdateWithWhereUniqueWithoutSensorInput = {
    where: ScreenTypeSensorWhereUniqueInput
    data: XOR<ScreenTypeSensorUpdateWithoutSensorInput, ScreenTypeSensorUncheckedUpdateWithoutSensorInput>
  }

  export type ScreenTypeSensorUpdateManyWithWhereWithoutSensorInput = {
    where: ScreenTypeSensorScalarWhereInput
    data: XOR<ScreenTypeSensorUpdateManyMutationInput, ScreenTypeSensorUncheckedUpdateManyWithoutSensorInput>
  }

  export type ScreenTypeControlTypeCreateWithoutControlTypeInput = {
    screenType: ScreenTypeCreateNestedOneWithoutControlTypesInput
  }

  export type ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput = {
    screenTypeCode: string
  }

  export type ScreenTypeControlTypeCreateOrConnectWithoutControlTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    create: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput>
  }

  export type ScreenTypeControlTypeCreateManyControlTypeInputEnvelope = {
    data: ScreenTypeControlTypeCreateManyControlTypeInput | ScreenTypeControlTypeCreateManyControlTypeInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTypeControlTypeUpsertWithWhereUniqueWithoutControlTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    update: XOR<ScreenTypeControlTypeUpdateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedUpdateWithoutControlTypeInput>
    create: XOR<ScreenTypeControlTypeCreateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedCreateWithoutControlTypeInput>
  }

  export type ScreenTypeControlTypeUpdateWithWhereUniqueWithoutControlTypeInput = {
    where: ScreenTypeControlTypeWhereUniqueInput
    data: XOR<ScreenTypeControlTypeUpdateWithoutControlTypeInput, ScreenTypeControlTypeUncheckedUpdateWithoutControlTypeInput>
  }

  export type ScreenTypeControlTypeUpdateManyWithWhereWithoutControlTypeInput = {
    where: ScreenTypeControlTypeScalarWhereInput
    data: XOR<ScreenTypeControlTypeUpdateManyMutationInput, ScreenTypeControlTypeUncheckedUpdateManyWithoutControlTypeInput>
  }

  export type CabinetPitchCreateWithoutPitchInput = {
    cabinet: CabinetCreateNestedOneWithoutPitchesInput
  }

  export type CabinetPitchUncheckedCreateWithoutPitchInput = {
    cabinetCode: string
  }

  export type CabinetPitchCreateOrConnectWithoutPitchInput = {
    where: CabinetPitchWhereUniqueInput
    create: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput>
  }

  export type CabinetPitchCreateManyPitchInputEnvelope = {
    data: CabinetPitchCreateManyPitchInput | CabinetPitchCreateManyPitchInput[]
    skipDuplicates?: boolean
  }

  export type ModulePitchCreateWithoutPitchInput = {
    module: ModuleCreateNestedOneWithoutPitchesInput
  }

  export type ModulePitchUncheckedCreateWithoutPitchInput = {
    moduleCode: string
  }

  export type ModulePitchCreateOrConnectWithoutPitchInput = {
    where: ModulePitchWhereUniqueInput
    create: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput>
  }

  export type ModulePitchCreateManyPitchInputEnvelope = {
    data: ModulePitchCreateManyPitchInput | ModulePitchCreateManyPitchInput[]
    skipDuplicates?: boolean
  }

  export type CabinetPitchUpsertWithWhereUniqueWithoutPitchInput = {
    where: CabinetPitchWhereUniqueInput
    update: XOR<CabinetPitchUpdateWithoutPitchInput, CabinetPitchUncheckedUpdateWithoutPitchInput>
    create: XOR<CabinetPitchCreateWithoutPitchInput, CabinetPitchUncheckedCreateWithoutPitchInput>
  }

  export type CabinetPitchUpdateWithWhereUniqueWithoutPitchInput = {
    where: CabinetPitchWhereUniqueInput
    data: XOR<CabinetPitchUpdateWithoutPitchInput, CabinetPitchUncheckedUpdateWithoutPitchInput>
  }

  export type CabinetPitchUpdateManyWithWhereWithoutPitchInput = {
    where: CabinetPitchScalarWhereInput
    data: XOR<CabinetPitchUpdateManyMutationInput, CabinetPitchUncheckedUpdateManyWithoutPitchInput>
  }

  export type CabinetPitchScalarWhereInput = {
    AND?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
    OR?: CabinetPitchScalarWhereInput[]
    NOT?: CabinetPitchScalarWhereInput | CabinetPitchScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetPitch"> | string
    pitchCode?: StringFilter<"CabinetPitch"> | string
  }

  export type ModulePitchUpsertWithWhereUniqueWithoutPitchInput = {
    where: ModulePitchWhereUniqueInput
    update: XOR<ModulePitchUpdateWithoutPitchInput, ModulePitchUncheckedUpdateWithoutPitchInput>
    create: XOR<ModulePitchCreateWithoutPitchInput, ModulePitchUncheckedCreateWithoutPitchInput>
  }

  export type ModulePitchUpdateWithWhereUniqueWithoutPitchInput = {
    where: ModulePitchWhereUniqueInput
    data: XOR<ModulePitchUpdateWithoutPitchInput, ModulePitchUncheckedUpdateWithoutPitchInput>
  }

  export type ModulePitchUpdateManyWithWhereWithoutPitchInput = {
    where: ModulePitchScalarWhereInput
    data: XOR<ModulePitchUpdateManyMutationInput, ModulePitchUncheckedUpdateManyWithoutPitchInput>
  }

  export type ModulePitchScalarWhereInput = {
    AND?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
    OR?: ModulePitchScalarWhereInput[]
    NOT?: ModulePitchScalarWhereInput | ModulePitchScalarWhereInput[]
    moduleCode?: StringFilter<"ModulePitch"> | string
    pitchCode?: StringFilter<"ModulePitch"> | string
  }

  export type ModuleRefreshRateCreateWithoutRefreshRateInput = {
    module: ModuleCreateNestedOneWithoutRefreshRatesInput
  }

  export type ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput = {
    moduleCode: string
  }

  export type ModuleRefreshRateCreateOrConnectWithoutRefreshRateInput = {
    where: ModuleRefreshRateWhereUniqueInput
    create: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput>
  }

  export type ModuleRefreshRateCreateManyRefreshRateInputEnvelope = {
    data: ModuleRefreshRateCreateManyRefreshRateInput | ModuleRefreshRateCreateManyRefreshRateInput[]
    skipDuplicates?: boolean
  }

  export type ModuleRefreshRateUpsertWithWhereUniqueWithoutRefreshRateInput = {
    where: ModuleRefreshRateWhereUniqueInput
    update: XOR<ModuleRefreshRateUpdateWithoutRefreshRateInput, ModuleRefreshRateUncheckedUpdateWithoutRefreshRateInput>
    create: XOR<ModuleRefreshRateCreateWithoutRefreshRateInput, ModuleRefreshRateUncheckedCreateWithoutRefreshRateInput>
  }

  export type ModuleRefreshRateUpdateWithWhereUniqueWithoutRefreshRateInput = {
    where: ModuleRefreshRateWhereUniqueInput
    data: XOR<ModuleRefreshRateUpdateWithoutRefreshRateInput, ModuleRefreshRateUncheckedUpdateWithoutRefreshRateInput>
  }

  export type ModuleRefreshRateUpdateManyWithWhereWithoutRefreshRateInput = {
    where: ModuleRefreshRateScalarWhereInput
    data: XOR<ModuleRefreshRateUpdateManyMutationInput, ModuleRefreshRateUncheckedUpdateManyWithoutRefreshRateInput>
  }

  export type ModuleRefreshRateScalarWhereInput = {
    AND?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
    OR?: ModuleRefreshRateScalarWhereInput[]
    NOT?: ModuleRefreshRateScalarWhereInput | ModuleRefreshRateScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleRefreshRate"> | string
    refreshRateCode?: StringFilter<"ModuleRefreshRate"> | string
  }

  export type ModuleBrightnessCreateWithoutBrightnessInput = {
    module: ModuleCreateNestedOneWithoutBrightnessesInput
  }

  export type ModuleBrightnessUncheckedCreateWithoutBrightnessInput = {
    moduleCode: string
  }

  export type ModuleBrightnessCreateOrConnectWithoutBrightnessInput = {
    where: ModuleBrightnessWhereUniqueInput
    create: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput>
  }

  export type ModuleBrightnessCreateManyBrightnessInputEnvelope = {
    data: ModuleBrightnessCreateManyBrightnessInput | ModuleBrightnessCreateManyBrightnessInput[]
    skipDuplicates?: boolean
  }

  export type ModuleBrightnessUpsertWithWhereUniqueWithoutBrightnessInput = {
    where: ModuleBrightnessWhereUniqueInput
    update: XOR<ModuleBrightnessUpdateWithoutBrightnessInput, ModuleBrightnessUncheckedUpdateWithoutBrightnessInput>
    create: XOR<ModuleBrightnessCreateWithoutBrightnessInput, ModuleBrightnessUncheckedCreateWithoutBrightnessInput>
  }

  export type ModuleBrightnessUpdateWithWhereUniqueWithoutBrightnessInput = {
    where: ModuleBrightnessWhereUniqueInput
    data: XOR<ModuleBrightnessUpdateWithoutBrightnessInput, ModuleBrightnessUncheckedUpdateWithoutBrightnessInput>
  }

  export type ModuleBrightnessUpdateManyWithWhereWithoutBrightnessInput = {
    where: ModuleBrightnessScalarWhereInput
    data: XOR<ModuleBrightnessUpdateManyMutationInput, ModuleBrightnessUncheckedUpdateManyWithoutBrightnessInput>
  }

  export type ModuleBrightnessScalarWhereInput = {
    AND?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
    OR?: ModuleBrightnessScalarWhereInput[]
    NOT?: ModuleBrightnessScalarWhereInput | ModuleBrightnessScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleBrightness"> | string
    brightnessCode?: StringFilter<"ModuleBrightness"> | string
  }

  export type CabinetManufacturerCreateWithoutManufacturerInput = {
    cabinet: CabinetCreateNestedOneWithoutManufacturersInput
  }

  export type CabinetManufacturerUncheckedCreateWithoutManufacturerInput = {
    cabinetCode: string
  }

  export type CabinetManufacturerCreateOrConnectWithoutManufacturerInput = {
    where: CabinetManufacturerWhereUniqueInput
    create: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput>
  }

  export type CabinetManufacturerCreateManyManufacturerInputEnvelope = {
    data: CabinetManufacturerCreateManyManufacturerInput | CabinetManufacturerCreateManyManufacturerInput[]
    skipDuplicates?: boolean
  }

  export type ModuleManufacturerCreateWithoutManufacturerInput = {
    module: ModuleCreateNestedOneWithoutManufacturersInput
  }

  export type ModuleManufacturerUncheckedCreateWithoutManufacturerInput = {
    moduleCode: string
  }

  export type ModuleManufacturerCreateOrConnectWithoutManufacturerInput = {
    where: ModuleManufacturerWhereUniqueInput
    create: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput>
  }

  export type ModuleManufacturerCreateManyManufacturerInputEnvelope = {
    data: ModuleManufacturerCreateManyManufacturerInput | ModuleManufacturerCreateManyManufacturerInput[]
    skipDuplicates?: boolean
  }

  export type CabinetManufacturerUpsertWithWhereUniqueWithoutManufacturerInput = {
    where: CabinetManufacturerWhereUniqueInput
    update: XOR<CabinetManufacturerUpdateWithoutManufacturerInput, CabinetManufacturerUncheckedUpdateWithoutManufacturerInput>
    create: XOR<CabinetManufacturerCreateWithoutManufacturerInput, CabinetManufacturerUncheckedCreateWithoutManufacturerInput>
  }

  export type CabinetManufacturerUpdateWithWhereUniqueWithoutManufacturerInput = {
    where: CabinetManufacturerWhereUniqueInput
    data: XOR<CabinetManufacturerUpdateWithoutManufacturerInput, CabinetManufacturerUncheckedUpdateWithoutManufacturerInput>
  }

  export type CabinetManufacturerUpdateManyWithWhereWithoutManufacturerInput = {
    where: CabinetManufacturerScalarWhereInput
    data: XOR<CabinetManufacturerUpdateManyMutationInput, CabinetManufacturerUncheckedUpdateManyWithoutManufacturerInput>
  }

  export type CabinetManufacturerScalarWhereInput = {
    AND?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
    OR?: CabinetManufacturerScalarWhereInput[]
    NOT?: CabinetManufacturerScalarWhereInput | CabinetManufacturerScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetManufacturer"> | string
    manufacturerCode?: StringFilter<"CabinetManufacturer"> | string
  }

  export type ModuleManufacturerUpsertWithWhereUniqueWithoutManufacturerInput = {
    where: ModuleManufacturerWhereUniqueInput
    update: XOR<ModuleManufacturerUpdateWithoutManufacturerInput, ModuleManufacturerUncheckedUpdateWithoutManufacturerInput>
    create: XOR<ModuleManufacturerCreateWithoutManufacturerInput, ModuleManufacturerUncheckedCreateWithoutManufacturerInput>
  }

  export type ModuleManufacturerUpdateWithWhereUniqueWithoutManufacturerInput = {
    where: ModuleManufacturerWhereUniqueInput
    data: XOR<ModuleManufacturerUpdateWithoutManufacturerInput, ModuleManufacturerUncheckedUpdateWithoutManufacturerInput>
  }

  export type ModuleManufacturerUpdateManyWithWhereWithoutManufacturerInput = {
    where: ModuleManufacturerScalarWhereInput
    data: XOR<ModuleManufacturerUpdateManyMutationInput, ModuleManufacturerUncheckedUpdateManyWithoutManufacturerInput>
  }

  export type ModuleManufacturerScalarWhereInput = {
    AND?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
    OR?: ModuleManufacturerScalarWhereInput[]
    NOT?: ModuleManufacturerScalarWhereInput | ModuleManufacturerScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleManufacturer"> | string
    manufacturerCode?: StringFilter<"ModuleManufacturer"> | string
  }

  export type CabinetSupplierCreateWithoutSupplierInput = {
    cabinet: CabinetCreateNestedOneWithoutSuppliersInput
  }

  export type CabinetSupplierUncheckedCreateWithoutSupplierInput = {
    cabinetCode: string
  }

  export type CabinetSupplierCreateOrConnectWithoutSupplierInput = {
    where: CabinetSupplierWhereUniqueInput
    create: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type CabinetSupplierCreateManySupplierInputEnvelope = {
    data: CabinetSupplierCreateManySupplierInput | CabinetSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ItemSupplierCreateWithoutSupplierInput = {
    item: ItemCreateNestedOneWithoutSuppliersInput
  }

  export type ItemSupplierUncheckedCreateWithoutSupplierInput = {
    itemCode: string
  }

  export type ItemSupplierCreateOrConnectWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    create: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type ItemSupplierCreateManySupplierInputEnvelope = {
    data: ItemSupplierCreateManySupplierInput | ItemSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CabinetSupplierWhereUniqueInput
    update: XOR<CabinetSupplierUpdateWithoutSupplierInput, CabinetSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<CabinetSupplierCreateWithoutSupplierInput, CabinetSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type CabinetSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CabinetSupplierWhereUniqueInput
    data: XOR<CabinetSupplierUpdateWithoutSupplierInput, CabinetSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type CabinetSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: CabinetSupplierScalarWhereInput
    data: XOR<CabinetSupplierUpdateManyMutationInput, CabinetSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CabinetSupplierScalarWhereInput = {
    AND?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
    OR?: CabinetSupplierScalarWhereInput[]
    NOT?: CabinetSupplierScalarWhereInput | CabinetSupplierScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetSupplier"> | string
    supplierCode?: StringFilter<"CabinetSupplier"> | string
  }

  export type ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    update: XOR<ItemSupplierUpdateWithoutSupplierInput, ItemSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    data: XOR<ItemSupplierUpdateWithoutSupplierInput, ItemSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type ItemSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: ItemSupplierScalarWhereInput
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ItemSupplierScalarWhereInput = {
    AND?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
    OR?: ItemSupplierScalarWhereInput[]
    NOT?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
    itemCode?: StringFilter<"ItemSupplier"> | string
    supplierCode?: StringFilter<"ItemSupplier"> | string
  }

  export type ModuleModuleSizeCreateWithoutSizeInput = {
    module: ModuleCreateNestedOneWithoutSizesInput
  }

  export type ModuleModuleSizeUncheckedCreateWithoutSizeInput = {
    moduleCode: string
  }

  export type ModuleModuleSizeCreateOrConnectWithoutSizeInput = {
    where: ModuleModuleSizeWhereUniqueInput
    create: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput>
  }

  export type ModuleModuleSizeCreateManySizeInputEnvelope = {
    data: ModuleModuleSizeCreateManySizeInput | ModuleModuleSizeCreateManySizeInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSizeModuleSizeCreateWithoutModuleSizeInput = {
    cabinetSize: CabinetSizeCreateNestedOneWithoutModuleSizesInput
  }

  export type CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput = {
    cabinetSizeCode: string
  }

  export type CabinetSizeModuleSizeCreateOrConnectWithoutModuleSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    create: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput>
  }

  export type CabinetSizeModuleSizeCreateManyModuleSizeInputEnvelope = {
    data: CabinetSizeModuleSizeCreateManyModuleSizeInput | CabinetSizeModuleSizeCreateManyModuleSizeInput[]
    skipDuplicates?: boolean
  }

  export type ModuleModuleSizeUpsertWithWhereUniqueWithoutSizeInput = {
    where: ModuleModuleSizeWhereUniqueInput
    update: XOR<ModuleModuleSizeUpdateWithoutSizeInput, ModuleModuleSizeUncheckedUpdateWithoutSizeInput>
    create: XOR<ModuleModuleSizeCreateWithoutSizeInput, ModuleModuleSizeUncheckedCreateWithoutSizeInput>
  }

  export type ModuleModuleSizeUpdateWithWhereUniqueWithoutSizeInput = {
    where: ModuleModuleSizeWhereUniqueInput
    data: XOR<ModuleModuleSizeUpdateWithoutSizeInput, ModuleModuleSizeUncheckedUpdateWithoutSizeInput>
  }

  export type ModuleModuleSizeUpdateManyWithWhereWithoutSizeInput = {
    where: ModuleModuleSizeScalarWhereInput
    data: XOR<ModuleModuleSizeUpdateManyMutationInput, ModuleModuleSizeUncheckedUpdateManyWithoutSizeInput>
  }

  export type ModuleModuleSizeScalarWhereInput = {
    AND?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
    OR?: ModuleModuleSizeScalarWhereInput[]
    NOT?: ModuleModuleSizeScalarWhereInput | ModuleModuleSizeScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleModuleSize"> | string
    moduleSizeCode?: StringFilter<"ModuleModuleSize"> | string
  }

  export type CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutModuleSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    update: XOR<CabinetSizeModuleSizeUpdateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedUpdateWithoutModuleSizeInput>
    create: XOR<CabinetSizeModuleSizeCreateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutModuleSizeInput>
  }

  export type CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutModuleSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    data: XOR<CabinetSizeModuleSizeUpdateWithoutModuleSizeInput, CabinetSizeModuleSizeUncheckedUpdateWithoutModuleSizeInput>
  }

  export type CabinetSizeModuleSizeUpdateManyWithWhereWithoutModuleSizeInput = {
    where: CabinetSizeModuleSizeScalarWhereInput
    data: XOR<CabinetSizeModuleSizeUpdateManyMutationInput, CabinetSizeModuleSizeUncheckedUpdateManyWithoutModuleSizeInput>
  }

  export type CabinetSizeModuleSizeScalarWhereInput = {
    AND?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
    OR?: CabinetSizeModuleSizeScalarWhereInput[]
    NOT?: CabinetSizeModuleSizeScalarWhereInput | CabinetSizeModuleSizeScalarWhereInput[]
    cabinetSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
    moduleSizeCode?: StringFilter<"CabinetSizeModuleSize"> | string
  }

  export type CabinetCabinetSizeCreateWithoutSizeInput = {
    cabinet: CabinetCreateNestedOneWithoutSizesInput
  }

  export type CabinetCabinetSizeUncheckedCreateWithoutSizeInput = {
    cabinetCode: string
  }

  export type CabinetCabinetSizeCreateOrConnectWithoutSizeInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    create: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput>
  }

  export type CabinetCabinetSizeCreateManySizeInputEnvelope = {
    data: CabinetCabinetSizeCreateManySizeInput | CabinetCabinetSizeCreateManySizeInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSizeModuleSizeCreateWithoutCabinetSizeInput = {
    moduleSize: ModuleSizeCreateNestedOneWithoutCabinetSizesInput
  }

  export type CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput = {
    moduleSizeCode: string
  }

  export type CabinetSizeModuleSizeCreateOrConnectWithoutCabinetSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    create: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput>
  }

  export type CabinetSizeModuleSizeCreateManyCabinetSizeInputEnvelope = {
    data: CabinetSizeModuleSizeCreateManyCabinetSizeInput | CabinetSizeModuleSizeCreateManyCabinetSizeInput[]
    skipDuplicates?: boolean
  }

  export type CabinetCabinetSizeUpsertWithWhereUniqueWithoutSizeInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    update: XOR<CabinetCabinetSizeUpdateWithoutSizeInput, CabinetCabinetSizeUncheckedUpdateWithoutSizeInput>
    create: XOR<CabinetCabinetSizeCreateWithoutSizeInput, CabinetCabinetSizeUncheckedCreateWithoutSizeInput>
  }

  export type CabinetCabinetSizeUpdateWithWhereUniqueWithoutSizeInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    data: XOR<CabinetCabinetSizeUpdateWithoutSizeInput, CabinetCabinetSizeUncheckedUpdateWithoutSizeInput>
  }

  export type CabinetCabinetSizeUpdateManyWithWhereWithoutSizeInput = {
    where: CabinetCabinetSizeScalarWhereInput
    data: XOR<CabinetCabinetSizeUpdateManyMutationInput, CabinetCabinetSizeUncheckedUpdateManyWithoutSizeInput>
  }

  export type CabinetCabinetSizeScalarWhereInput = {
    AND?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
    OR?: CabinetCabinetSizeScalarWhereInput[]
    NOT?: CabinetCabinetSizeScalarWhereInput | CabinetCabinetSizeScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetCabinetSize"> | string
    cabinetSizeCode?: StringFilter<"CabinetCabinetSize"> | string
  }

  export type CabinetSizeModuleSizeUpsertWithWhereUniqueWithoutCabinetSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    update: XOR<CabinetSizeModuleSizeUpdateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedUpdateWithoutCabinetSizeInput>
    create: XOR<CabinetSizeModuleSizeCreateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedCreateWithoutCabinetSizeInput>
  }

  export type CabinetSizeModuleSizeUpdateWithWhereUniqueWithoutCabinetSizeInput = {
    where: CabinetSizeModuleSizeWhereUniqueInput
    data: XOR<CabinetSizeModuleSizeUpdateWithoutCabinetSizeInput, CabinetSizeModuleSizeUncheckedUpdateWithoutCabinetSizeInput>
  }

  export type CabinetSizeModuleSizeUpdateManyWithWhereWithoutCabinetSizeInput = {
    where: CabinetSizeModuleSizeScalarWhereInput
    data: XOR<CabinetSizeModuleSizeUpdateManyMutationInput, CabinetSizeModuleSizeUncheckedUpdateManyWithoutCabinetSizeInput>
  }

  export type ItemCategorySubcategoryCreateWithoutCategoryInput = {
    subcategory: ItemSubcategoryCreateNestedOneWithoutCategoriesInput
  }

  export type ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput = {
    subcategoryCode: string
  }

  export type ItemCategorySubcategoryCreateOrConnectWithoutCategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    create: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCategorySubcategoryCreateManyCategoryInputEnvelope = {
    data: ItemCategorySubcategoryCreateManyCategoryInput | ItemCategorySubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryRelationCreateWithoutCategoryInput = {
    item: ItemCreateNestedOneWithoutCategoriesInput
  }

  export type ItemCategoryRelationUncheckedCreateWithoutCategoryInput = {
    itemCode: string
  }

  export type ItemCategoryRelationCreateOrConnectWithoutCategoryInput = {
    where: ItemCategoryRelationWhereUniqueInput
    create: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCategoryRelationCreateManyCategoryInputEnvelope = {
    data: ItemCategoryRelationCreateManyCategoryInput | ItemCategoryRelationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CabinetCategoryCreateWithoutCategoryInput = {
    cabinet: CabinetCreateNestedOneWithoutCategoriesInput
  }

  export type CabinetCategoryUncheckedCreateWithoutCategoryInput = {
    cabinetCode: string
  }

  export type CabinetCategoryCreateOrConnectWithoutCategoryInput = {
    where: CabinetCategoryWhereUniqueInput
    create: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CabinetCategoryCreateManyCategoryInputEnvelope = {
    data: CabinetCategoryCreateManyCategoryInput | CabinetCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCategoryCreateWithoutCategoryInput = {
    module: ModuleCreateNestedOneWithoutCategoriesInput
  }

  export type ModuleCategoryUncheckedCreateWithoutCategoryInput = {
    moduleCode: string
  }

  export type ModuleCategoryCreateOrConnectWithoutCategoryInput = {
    where: ModuleCategoryWhereUniqueInput
    create: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ModuleCategoryCreateManyCategoryInputEnvelope = {
    data: ModuleCategoryCreateManyCategoryInput | ModuleCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategorySubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    update: XOR<ItemCategorySubcategoryUpdateWithoutCategoryInput, ItemCategorySubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCategorySubcategoryCreateWithoutCategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCategorySubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    data: XOR<ItemCategorySubcategoryUpdateWithoutCategoryInput, ItemCategorySubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemCategorySubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemCategorySubcategoryScalarWhereInput
    data: XOR<ItemCategorySubcategoryUpdateManyMutationInput, ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemCategorySubcategoryScalarWhereInput = {
    AND?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
    OR?: ItemCategorySubcategoryScalarWhereInput[]
    NOT?: ItemCategorySubcategoryScalarWhereInput | ItemCategorySubcategoryScalarWhereInput[]
    categoryCode?: StringFilter<"ItemCategorySubcategory"> | string
    subcategoryCode?: StringFilter<"ItemCategorySubcategory"> | string
  }

  export type ItemCategoryRelationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemCategoryRelationWhereUniqueInput
    update: XOR<ItemCategoryRelationUpdateWithoutCategoryInput, ItemCategoryRelationUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCategoryRelationCreateWithoutCategoryInput, ItemCategoryRelationUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCategoryRelationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemCategoryRelationWhereUniqueInput
    data: XOR<ItemCategoryRelationUpdateWithoutCategoryInput, ItemCategoryRelationUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemCategoryRelationUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemCategoryRelationScalarWhereInput
    data: XOR<ItemCategoryRelationUpdateManyMutationInput, ItemCategoryRelationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemCategoryRelationScalarWhereInput = {
    AND?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
    OR?: ItemCategoryRelationScalarWhereInput[]
    NOT?: ItemCategoryRelationScalarWhereInput | ItemCategoryRelationScalarWhereInput[]
    itemCode?: StringFilter<"ItemCategoryRelation"> | string
    categoryCode?: StringFilter<"ItemCategoryRelation"> | string
  }

  export type CabinetCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CabinetCategoryWhereUniqueInput
    update: XOR<CabinetCategoryUpdateWithoutCategoryInput, CabinetCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<CabinetCategoryCreateWithoutCategoryInput, CabinetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CabinetCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CabinetCategoryWhereUniqueInput
    data: XOR<CabinetCategoryUpdateWithoutCategoryInput, CabinetCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type CabinetCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CabinetCategoryScalarWhereInput
    data: XOR<CabinetCategoryUpdateManyMutationInput, CabinetCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CabinetCategoryScalarWhereInput = {
    AND?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
    OR?: CabinetCategoryScalarWhereInput[]
    NOT?: CabinetCategoryScalarWhereInput | CabinetCategoryScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetCategory"> | string
    categoryCode?: StringFilter<"CabinetCategory"> | string
  }

  export type ModuleCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ModuleCategoryWhereUniqueInput
    update: XOR<ModuleCategoryUpdateWithoutCategoryInput, ModuleCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ModuleCategoryCreateWithoutCategoryInput, ModuleCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ModuleCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ModuleCategoryWhereUniqueInput
    data: XOR<ModuleCategoryUpdateWithoutCategoryInput, ModuleCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ModuleCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ModuleCategoryScalarWhereInput
    data: XOR<ModuleCategoryUpdateManyMutationInput, ModuleCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ModuleCategoryScalarWhereInput = {
    AND?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
    OR?: ModuleCategoryScalarWhereInput[]
    NOT?: ModuleCategoryScalarWhereInput | ModuleCategoryScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleCategory"> | string
    categoryCode?: StringFilter<"ModuleCategory"> | string
  }

  export type ItemCategorySubcategoryCreateWithoutSubcategoryInput = {
    category: ItemCategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput = {
    categoryCode: string
  }

  export type ItemCategorySubcategoryCreateOrConnectWithoutSubcategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    create: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ItemCategorySubcategoryCreateManySubcategoryInputEnvelope = {
    data: ItemCategorySubcategoryCreateManySubcategoryInput | ItemCategorySubcategoryCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemSubcategoryRelationCreateWithoutSubcategoryInput = {
    item: ItemCreateNestedOneWithoutSubcategoriesInput
  }

  export type ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput = {
    itemCode: string
  }

  export type ItemSubcategoryRelationCreateOrConnectWithoutSubcategoryInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    create: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput>
  }

  export type ItemSubcategoryRelationCreateManySubcategoryInputEnvelope = {
    data: ItemSubcategoryRelationCreateManySubcategoryInput | ItemSubcategoryRelationCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSubcategoryCreateWithoutSubcategoryInput = {
    cabinet: CabinetCreateNestedOneWithoutSubcategoriesInput
  }

  export type CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput = {
    cabinetCode: string
  }

  export type CabinetSubcategoryCreateOrConnectWithoutSubcategoryInput = {
    where: CabinetSubcategoryWhereUniqueInput
    create: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type CabinetSubcategoryCreateManySubcategoryInputEnvelope = {
    data: CabinetSubcategoryCreateManySubcategoryInput | CabinetSubcategoryCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type ModuleSubcategoryCreateWithoutSubcategoryInput = {
    module: ModuleCreateNestedOneWithoutSubcategoriesInput
  }

  export type ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput = {
    moduleCode: string
  }

  export type ModuleSubcategoryCreateOrConnectWithoutSubcategoryInput = {
    where: ModuleSubcategoryWhereUniqueInput
    create: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ModuleSubcategoryCreateManySubcategoryInputEnvelope = {
    data: ModuleSubcategoryCreateManySubcategoryInput | ModuleSubcategoryCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategorySubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    update: XOR<ItemCategorySubcategoryUpdateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ItemCategorySubcategoryCreateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ItemCategorySubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ItemCategorySubcategoryWhereUniqueInput
    data: XOR<ItemCategorySubcategoryUpdateWithoutSubcategoryInput, ItemCategorySubcategoryUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ItemCategorySubcategoryUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ItemCategorySubcategoryScalarWhereInput
    data: XOR<ItemCategorySubcategoryUpdateManyMutationInput, ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type ItemSubcategoryRelationUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    update: XOR<ItemSubcategoryRelationUpdateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ItemSubcategoryRelationCreateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedCreateWithoutSubcategoryInput>
  }

  export type ItemSubcategoryRelationUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    data: XOR<ItemSubcategoryRelationUpdateWithoutSubcategoryInput, ItemSubcategoryRelationUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ItemSubcategoryRelationUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ItemSubcategoryRelationScalarWhereInput
    data: XOR<ItemSubcategoryRelationUpdateManyMutationInput, ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type ItemSubcategoryRelationScalarWhereInput = {
    AND?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
    OR?: ItemSubcategoryRelationScalarWhereInput[]
    NOT?: ItemSubcategoryRelationScalarWhereInput | ItemSubcategoryRelationScalarWhereInput[]
    itemCode?: StringFilter<"ItemSubcategoryRelation"> | string
    subcategoryCode?: StringFilter<"ItemSubcategoryRelation"> | string
  }

  export type CabinetSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: CabinetSubcategoryWhereUniqueInput
    update: XOR<CabinetSubcategoryUpdateWithoutSubcategoryInput, CabinetSubcategoryUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<CabinetSubcategoryCreateWithoutSubcategoryInput, CabinetSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type CabinetSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: CabinetSubcategoryWhereUniqueInput
    data: XOR<CabinetSubcategoryUpdateWithoutSubcategoryInput, CabinetSubcategoryUncheckedUpdateWithoutSubcategoryInput>
  }

  export type CabinetSubcategoryUpdateManyWithWhereWithoutSubcategoryInput = {
    where: CabinetSubcategoryScalarWhereInput
    data: XOR<CabinetSubcategoryUpdateManyMutationInput, CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type CabinetSubcategoryScalarWhereInput = {
    AND?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
    OR?: CabinetSubcategoryScalarWhereInput[]
    NOT?: CabinetSubcategoryScalarWhereInput | CabinetSubcategoryScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetSubcategory"> | string
    subcategoryCode?: StringFilter<"CabinetSubcategory"> | string
  }

  export type ModuleSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ModuleSubcategoryWhereUniqueInput
    update: XOR<ModuleSubcategoryUpdateWithoutSubcategoryInput, ModuleSubcategoryUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ModuleSubcategoryCreateWithoutSubcategoryInput, ModuleSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ModuleSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ModuleSubcategoryWhereUniqueInput
    data: XOR<ModuleSubcategoryUpdateWithoutSubcategoryInput, ModuleSubcategoryUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ModuleSubcategoryUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ModuleSubcategoryScalarWhereInput
    data: XOR<ModuleSubcategoryUpdateManyMutationInput, ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type ModuleSubcategoryScalarWhereInput = {
    AND?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
    OR?: ModuleSubcategoryScalarWhereInput[]
    NOT?: ModuleSubcategoryScalarWhereInput | ModuleSubcategoryScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleSubcategory"> | string
    subcategoryCode?: StringFilter<"ModuleSubcategory"> | string
  }

  export type CabinetCategoryCreateWithoutCabinetInput = {
    category: ItemCategoryCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetCategoryUncheckedCreateWithoutCabinetInput = {
    categoryCode: string
  }

  export type CabinetCategoryCreateOrConnectWithoutCabinetInput = {
    where: CabinetCategoryWhereUniqueInput
    create: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetCategoryCreateManyCabinetInputEnvelope = {
    data: CabinetCategoryCreateManyCabinetInput | CabinetCategoryCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSubcategoryCreateWithoutCabinetInput = {
    subcategory: ItemSubcategoryCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetSubcategoryUncheckedCreateWithoutCabinetInput = {
    subcategoryCode: string
  }

  export type CabinetSubcategoryCreateOrConnectWithoutCabinetInput = {
    where: CabinetSubcategoryWhereUniqueInput
    create: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetSubcategoryCreateManyCabinetInputEnvelope = {
    data: CabinetSubcategoryCreateManyCabinetInput | CabinetSubcategoryCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetLocationCreateWithoutCabinetInput = {
    location: LocationCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetLocationUncheckedCreateWithoutCabinetInput = {
    locationCode: string
  }

  export type CabinetLocationCreateOrConnectWithoutCabinetInput = {
    where: CabinetLocationWhereUniqueInput
    create: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetLocationCreateManyCabinetInputEnvelope = {
    data: CabinetLocationCreateManyCabinetInput | CabinetLocationCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetPlacementCreateWithoutCabinetInput = {
    placement: PlacementCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetPlacementUncheckedCreateWithoutCabinetInput = {
    placementCode: string
  }

  export type CabinetPlacementCreateOrConnectWithoutCabinetInput = {
    where: CabinetPlacementWhereUniqueInput
    create: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPlacementCreateManyCabinetInputEnvelope = {
    data: CabinetPlacementCreateManyCabinetInput | CabinetPlacementCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetMaterialCreateWithoutCabinetInput = {
    material: MaterialCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetMaterialUncheckedCreateWithoutCabinetInput = {
    materialCode: string
  }

  export type CabinetMaterialCreateOrConnectWithoutCabinetInput = {
    where: CabinetMaterialWhereUniqueInput
    create: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetMaterialCreateManyCabinetInputEnvelope = {
    data: CabinetMaterialCreateManyCabinetInput | CabinetMaterialCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetCabinetSizeCreateWithoutCabinetInput = {
    size: CabinetSizeCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetCabinetSizeUncheckedCreateWithoutCabinetInput = {
    cabinetSizeCode: string
  }

  export type CabinetCabinetSizeCreateOrConnectWithoutCabinetInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    create: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetCabinetSizeCreateManyCabinetInputEnvelope = {
    data: CabinetCabinetSizeCreateManyCabinetInput | CabinetCabinetSizeCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetPitchCreateWithoutCabinetInput = {
    pitch: PitchCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetPitchUncheckedCreateWithoutCabinetInput = {
    pitchCode: string
  }

  export type CabinetPitchCreateOrConnectWithoutCabinetInput = {
    where: CabinetPitchWhereUniqueInput
    create: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPitchCreateManyCabinetInputEnvelope = {
    data: CabinetPitchCreateManyCabinetInput | CabinetPitchCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetManufacturerCreateWithoutCabinetInput = {
    manufacturer: ManufacturerCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetManufacturerUncheckedCreateWithoutCabinetInput = {
    manufacturerCode: string
  }

  export type CabinetManufacturerCreateOrConnectWithoutCabinetInput = {
    where: CabinetManufacturerWhereUniqueInput
    create: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetManufacturerCreateManyCabinetInputEnvelope = {
    data: CabinetManufacturerCreateManyCabinetInput | CabinetManufacturerCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetSupplierCreateWithoutCabinetInput = {
    supplier: SupplierCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetSupplierUncheckedCreateWithoutCabinetInput = {
    supplierCode: string
  }

  export type CabinetSupplierCreateOrConnectWithoutCabinetInput = {
    where: CabinetSupplierWhereUniqueInput
    create: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetSupplierCreateManyCabinetInputEnvelope = {
    data: CabinetSupplierCreateManyCabinetInput | CabinetSupplierCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetItemComponentCreateWithoutCabinetInput = {
    quantity: number
    item: ItemCreateNestedOneWithoutCabinetsInput
  }

  export type CabinetItemComponentUncheckedCreateWithoutCabinetInput = {
    itemCode: string
    quantity: number
  }

  export type CabinetItemComponentCreateOrConnectWithoutCabinetInput = {
    where: CabinetItemComponentWhereUniqueInput
    create: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetItemComponentCreateManyCabinetInputEnvelope = {
    data: CabinetItemComponentCreateManyCabinetInput | CabinetItemComponentCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetPriceCreateWithoutCabinetInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUncheckedCreateWithoutCabinetInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceCreateOrConnectWithoutCabinetInput = {
    where: CabinetPriceWhereUniqueInput
    create: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPriceCreateManyCabinetInputEnvelope = {
    data: CabinetPriceCreateManyCabinetInput | CabinetPriceCreateManyCabinetInput[]
    skipDuplicates?: boolean
  }

  export type CabinetCategoryUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetCategoryWhereUniqueInput
    update: XOR<CabinetCategoryUpdateWithoutCabinetInput, CabinetCategoryUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetCategoryCreateWithoutCabinetInput, CabinetCategoryUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetCategoryUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetCategoryWhereUniqueInput
    data: XOR<CabinetCategoryUpdateWithoutCabinetInput, CabinetCategoryUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetCategoryUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetCategoryScalarWhereInput
    data: XOR<CabinetCategoryUpdateManyMutationInput, CabinetCategoryUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetSubcategoryUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetSubcategoryWhereUniqueInput
    update: XOR<CabinetSubcategoryUpdateWithoutCabinetInput, CabinetSubcategoryUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetSubcategoryCreateWithoutCabinetInput, CabinetSubcategoryUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetSubcategoryUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetSubcategoryWhereUniqueInput
    data: XOR<CabinetSubcategoryUpdateWithoutCabinetInput, CabinetSubcategoryUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetSubcategoryUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetSubcategoryScalarWhereInput
    data: XOR<CabinetSubcategoryUpdateManyMutationInput, CabinetSubcategoryUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetLocationUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetLocationWhereUniqueInput
    update: XOR<CabinetLocationUpdateWithoutCabinetInput, CabinetLocationUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetLocationCreateWithoutCabinetInput, CabinetLocationUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetLocationUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetLocationWhereUniqueInput
    data: XOR<CabinetLocationUpdateWithoutCabinetInput, CabinetLocationUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetLocationUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetLocationScalarWhereInput
    data: XOR<CabinetLocationUpdateManyMutationInput, CabinetLocationUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetPlacementUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPlacementWhereUniqueInput
    update: XOR<CabinetPlacementUpdateWithoutCabinetInput, CabinetPlacementUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetPlacementCreateWithoutCabinetInput, CabinetPlacementUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPlacementUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPlacementWhereUniqueInput
    data: XOR<CabinetPlacementUpdateWithoutCabinetInput, CabinetPlacementUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetPlacementUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetPlacementScalarWhereInput
    data: XOR<CabinetPlacementUpdateManyMutationInput, CabinetPlacementUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetMaterialUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetMaterialWhereUniqueInput
    update: XOR<CabinetMaterialUpdateWithoutCabinetInput, CabinetMaterialUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetMaterialCreateWithoutCabinetInput, CabinetMaterialUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetMaterialUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetMaterialWhereUniqueInput
    data: XOR<CabinetMaterialUpdateWithoutCabinetInput, CabinetMaterialUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetMaterialUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetMaterialScalarWhereInput
    data: XOR<CabinetMaterialUpdateManyMutationInput, CabinetMaterialUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetCabinetSizeUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    update: XOR<CabinetCabinetSizeUpdateWithoutCabinetInput, CabinetCabinetSizeUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetCabinetSizeCreateWithoutCabinetInput, CabinetCabinetSizeUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetCabinetSizeUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetCabinetSizeWhereUniqueInput
    data: XOR<CabinetCabinetSizeUpdateWithoutCabinetInput, CabinetCabinetSizeUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetCabinetSizeUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetCabinetSizeScalarWhereInput
    data: XOR<CabinetCabinetSizeUpdateManyMutationInput, CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetPitchUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPitchWhereUniqueInput
    update: XOR<CabinetPitchUpdateWithoutCabinetInput, CabinetPitchUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetPitchCreateWithoutCabinetInput, CabinetPitchUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPitchUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPitchWhereUniqueInput
    data: XOR<CabinetPitchUpdateWithoutCabinetInput, CabinetPitchUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetPitchUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetPitchScalarWhereInput
    data: XOR<CabinetPitchUpdateManyMutationInput, CabinetPitchUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetManufacturerUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetManufacturerWhereUniqueInput
    update: XOR<CabinetManufacturerUpdateWithoutCabinetInput, CabinetManufacturerUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetManufacturerCreateWithoutCabinetInput, CabinetManufacturerUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetManufacturerUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetManufacturerWhereUniqueInput
    data: XOR<CabinetManufacturerUpdateWithoutCabinetInput, CabinetManufacturerUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetManufacturerUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetManufacturerScalarWhereInput
    data: XOR<CabinetManufacturerUpdateManyMutationInput, CabinetManufacturerUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetSupplierUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetSupplierWhereUniqueInput
    update: XOR<CabinetSupplierUpdateWithoutCabinetInput, CabinetSupplierUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetSupplierCreateWithoutCabinetInput, CabinetSupplierUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetSupplierUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetSupplierWhereUniqueInput
    data: XOR<CabinetSupplierUpdateWithoutCabinetInput, CabinetSupplierUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetSupplierUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetSupplierScalarWhereInput
    data: XOR<CabinetSupplierUpdateManyMutationInput, CabinetSupplierUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetItemComponentUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetItemComponentWhereUniqueInput
    update: XOR<CabinetItemComponentUpdateWithoutCabinetInput, CabinetItemComponentUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetItemComponentCreateWithoutCabinetInput, CabinetItemComponentUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetItemComponentUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetItemComponentWhereUniqueInput
    data: XOR<CabinetItemComponentUpdateWithoutCabinetInput, CabinetItemComponentUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetItemComponentUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetItemComponentScalarWhereInput
    data: XOR<CabinetItemComponentUpdateManyMutationInput, CabinetItemComponentUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetItemComponentScalarWhereInput = {
    AND?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
    OR?: CabinetItemComponentScalarWhereInput[]
    NOT?: CabinetItemComponentScalarWhereInput | CabinetItemComponentScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetItemComponent"> | string
    itemCode?: StringFilter<"CabinetItemComponent"> | string
    quantity?: IntFilter<"CabinetItemComponent"> | number
  }

  export type CabinetPriceUpsertWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPriceWhereUniqueInput
    update: XOR<CabinetPriceUpdateWithoutCabinetInput, CabinetPriceUncheckedUpdateWithoutCabinetInput>
    create: XOR<CabinetPriceCreateWithoutCabinetInput, CabinetPriceUncheckedCreateWithoutCabinetInput>
  }

  export type CabinetPriceUpdateWithWhereUniqueWithoutCabinetInput = {
    where: CabinetPriceWhereUniqueInput
    data: XOR<CabinetPriceUpdateWithoutCabinetInput, CabinetPriceUncheckedUpdateWithoutCabinetInput>
  }

  export type CabinetPriceUpdateManyWithWhereWithoutCabinetInput = {
    where: CabinetPriceScalarWhereInput
    data: XOR<CabinetPriceUpdateManyMutationInput, CabinetPriceUncheckedUpdateManyWithoutCabinetInput>
  }

  export type CabinetPriceScalarWhereInput = {
    AND?: CabinetPriceScalarWhereInput | CabinetPriceScalarWhereInput[]
    OR?: CabinetPriceScalarWhereInput[]
    NOT?: CabinetPriceScalarWhereInput | CabinetPriceScalarWhereInput[]
    cabinetCode?: StringFilter<"CabinetPrice"> | string
    priceUsd?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"CabinetPrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ModuleCategoryCreateWithoutModuleInput = {
    category: ItemCategoryCreateNestedOneWithoutModulesInput
  }

  export type ModuleCategoryUncheckedCreateWithoutModuleInput = {
    categoryCode: string
  }

  export type ModuleCategoryCreateOrConnectWithoutModuleInput = {
    where: ModuleCategoryWhereUniqueInput
    create: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput>
  }

  export type ModuleCategoryCreateManyModuleInputEnvelope = {
    data: ModuleCategoryCreateManyModuleInput | ModuleCategoryCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleSubcategoryCreateWithoutModuleInput = {
    subcategory: ItemSubcategoryCreateNestedOneWithoutModulesInput
  }

  export type ModuleSubcategoryUncheckedCreateWithoutModuleInput = {
    subcategoryCode: string
  }

  export type ModuleSubcategoryCreateOrConnectWithoutModuleInput = {
    where: ModuleSubcategoryWhereUniqueInput
    create: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput>
  }

  export type ModuleSubcategoryCreateManyModuleInputEnvelope = {
    data: ModuleSubcategoryCreateManyModuleInput | ModuleSubcategoryCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleLocationCreateWithoutModuleInput = {
    location: LocationCreateNestedOneWithoutModulesInput
  }

  export type ModuleLocationUncheckedCreateWithoutModuleInput = {
    locationCode: string
  }

  export type ModuleLocationCreateOrConnectWithoutModuleInput = {
    where: ModuleLocationWhereUniqueInput
    create: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput>
  }

  export type ModuleLocationCreateManyModuleInputEnvelope = {
    data: ModuleLocationCreateManyModuleInput | ModuleLocationCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleRefreshRateCreateWithoutModuleInput = {
    refreshRate: RefreshRateCreateNestedOneWithoutModulesInput
  }

  export type ModuleRefreshRateUncheckedCreateWithoutModuleInput = {
    refreshRateCode: string
  }

  export type ModuleRefreshRateCreateOrConnectWithoutModuleInput = {
    where: ModuleRefreshRateWhereUniqueInput
    create: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput>
  }

  export type ModuleRefreshRateCreateManyModuleInputEnvelope = {
    data: ModuleRefreshRateCreateManyModuleInput | ModuleRefreshRateCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleBrightnessCreateWithoutModuleInput = {
    brightness: BrightnessCreateNestedOneWithoutModulesInput
  }

  export type ModuleBrightnessUncheckedCreateWithoutModuleInput = {
    brightnessCode: string
  }

  export type ModuleBrightnessCreateOrConnectWithoutModuleInput = {
    where: ModuleBrightnessWhereUniqueInput
    create: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput>
  }

  export type ModuleBrightnessCreateManyModuleInputEnvelope = {
    data: ModuleBrightnessCreateManyModuleInput | ModuleBrightnessCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleModuleSizeCreateWithoutModuleInput = {
    size: ModuleSizeCreateNestedOneWithoutModulesInput
  }

  export type ModuleModuleSizeUncheckedCreateWithoutModuleInput = {
    moduleSizeCode: string
  }

  export type ModuleModuleSizeCreateOrConnectWithoutModuleInput = {
    where: ModuleModuleSizeWhereUniqueInput
    create: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput>
  }

  export type ModuleModuleSizeCreateManyModuleInputEnvelope = {
    data: ModuleModuleSizeCreateManyModuleInput | ModuleModuleSizeCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModulePitchCreateWithoutModuleInput = {
    pitch: PitchCreateNestedOneWithoutModulesInput
  }

  export type ModulePitchUncheckedCreateWithoutModuleInput = {
    pitchCode: string
  }

  export type ModulePitchCreateOrConnectWithoutModuleInput = {
    where: ModulePitchWhereUniqueInput
    create: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput>
  }

  export type ModulePitchCreateManyModuleInputEnvelope = {
    data: ModulePitchCreateManyModuleInput | ModulePitchCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleManufacturerCreateWithoutModuleInput = {
    manufacturer: ManufacturerCreateNestedOneWithoutModulesInput
  }

  export type ModuleManufacturerUncheckedCreateWithoutModuleInput = {
    manufacturerCode: string
  }

  export type ModuleManufacturerCreateOrConnectWithoutModuleInput = {
    where: ModuleManufacturerWhereUniqueInput
    create: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput>
  }

  export type ModuleManufacturerCreateManyModuleInputEnvelope = {
    data: ModuleManufacturerCreateManyModuleInput | ModuleManufacturerCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleItemComponentCreateWithoutModuleInput = {
    quantity: number
    item: ItemCreateNestedOneWithoutModulesInput
  }

  export type ModuleItemComponentUncheckedCreateWithoutModuleInput = {
    itemCode: string
    quantity: number
  }

  export type ModuleItemComponentCreateOrConnectWithoutModuleInput = {
    where: ModuleItemComponentWhereUniqueInput
    create: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleItemComponentCreateManyModuleInputEnvelope = {
    data: ModuleItemComponentCreateManyModuleInput | ModuleItemComponentCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleOptionCreateWithoutModuleInput = {
    option: OptionCreateNestedOneWithoutModulesInput
  }

  export type ModuleOptionUncheckedCreateWithoutModuleInput = {
    optionCode: string
  }

  export type ModuleOptionCreateOrConnectWithoutModuleInput = {
    where: ModuleOptionWhereUniqueInput
    create: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput>
  }

  export type ModuleOptionCreateManyModuleInputEnvelope = {
    data: ModuleOptionCreateManyModuleInput | ModuleOptionCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModulePriceCreateWithoutModuleInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUncheckedCreateWithoutModuleInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceCreateOrConnectWithoutModuleInput = {
    where: ModulePriceWhereUniqueInput
    create: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput>
  }

  export type ModulePriceCreateManyModuleInputEnvelope = {
    data: ModulePriceCreateManyModuleInput | ModulePriceCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCategoryUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleCategoryWhereUniqueInput
    update: XOR<ModuleCategoryUpdateWithoutModuleInput, ModuleCategoryUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleCategoryCreateWithoutModuleInput, ModuleCategoryUncheckedCreateWithoutModuleInput>
  }

  export type ModuleCategoryUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleCategoryWhereUniqueInput
    data: XOR<ModuleCategoryUpdateWithoutModuleInput, ModuleCategoryUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleCategoryUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleCategoryScalarWhereInput
    data: XOR<ModuleCategoryUpdateManyMutationInput, ModuleCategoryUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleSubcategoryUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleSubcategoryWhereUniqueInput
    update: XOR<ModuleSubcategoryUpdateWithoutModuleInput, ModuleSubcategoryUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleSubcategoryCreateWithoutModuleInput, ModuleSubcategoryUncheckedCreateWithoutModuleInput>
  }

  export type ModuleSubcategoryUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleSubcategoryWhereUniqueInput
    data: XOR<ModuleSubcategoryUpdateWithoutModuleInput, ModuleSubcategoryUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleSubcategoryUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleSubcategoryScalarWhereInput
    data: XOR<ModuleSubcategoryUpdateManyMutationInput, ModuleSubcategoryUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleLocationUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleLocationWhereUniqueInput
    update: XOR<ModuleLocationUpdateWithoutModuleInput, ModuleLocationUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleLocationCreateWithoutModuleInput, ModuleLocationUncheckedCreateWithoutModuleInput>
  }

  export type ModuleLocationUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleLocationWhereUniqueInput
    data: XOR<ModuleLocationUpdateWithoutModuleInput, ModuleLocationUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleLocationUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleLocationScalarWhereInput
    data: XOR<ModuleLocationUpdateManyMutationInput, ModuleLocationUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleRefreshRateUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleRefreshRateWhereUniqueInput
    update: XOR<ModuleRefreshRateUpdateWithoutModuleInput, ModuleRefreshRateUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleRefreshRateCreateWithoutModuleInput, ModuleRefreshRateUncheckedCreateWithoutModuleInput>
  }

  export type ModuleRefreshRateUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleRefreshRateWhereUniqueInput
    data: XOR<ModuleRefreshRateUpdateWithoutModuleInput, ModuleRefreshRateUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleRefreshRateUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleRefreshRateScalarWhereInput
    data: XOR<ModuleRefreshRateUpdateManyMutationInput, ModuleRefreshRateUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleBrightnessUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleBrightnessWhereUniqueInput
    update: XOR<ModuleBrightnessUpdateWithoutModuleInput, ModuleBrightnessUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleBrightnessCreateWithoutModuleInput, ModuleBrightnessUncheckedCreateWithoutModuleInput>
  }

  export type ModuleBrightnessUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleBrightnessWhereUniqueInput
    data: XOR<ModuleBrightnessUpdateWithoutModuleInput, ModuleBrightnessUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleBrightnessUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleBrightnessScalarWhereInput
    data: XOR<ModuleBrightnessUpdateManyMutationInput, ModuleBrightnessUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleModuleSizeUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleModuleSizeWhereUniqueInput
    update: XOR<ModuleModuleSizeUpdateWithoutModuleInput, ModuleModuleSizeUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleModuleSizeCreateWithoutModuleInput, ModuleModuleSizeUncheckedCreateWithoutModuleInput>
  }

  export type ModuleModuleSizeUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleModuleSizeWhereUniqueInput
    data: XOR<ModuleModuleSizeUpdateWithoutModuleInput, ModuleModuleSizeUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleModuleSizeUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleModuleSizeScalarWhereInput
    data: XOR<ModuleModuleSizeUpdateManyMutationInput, ModuleModuleSizeUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModulePitchUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModulePitchWhereUniqueInput
    update: XOR<ModulePitchUpdateWithoutModuleInput, ModulePitchUncheckedUpdateWithoutModuleInput>
    create: XOR<ModulePitchCreateWithoutModuleInput, ModulePitchUncheckedCreateWithoutModuleInput>
  }

  export type ModulePitchUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModulePitchWhereUniqueInput
    data: XOR<ModulePitchUpdateWithoutModuleInput, ModulePitchUncheckedUpdateWithoutModuleInput>
  }

  export type ModulePitchUpdateManyWithWhereWithoutModuleInput = {
    where: ModulePitchScalarWhereInput
    data: XOR<ModulePitchUpdateManyMutationInput, ModulePitchUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleManufacturerUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleManufacturerWhereUniqueInput
    update: XOR<ModuleManufacturerUpdateWithoutModuleInput, ModuleManufacturerUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleManufacturerCreateWithoutModuleInput, ModuleManufacturerUncheckedCreateWithoutModuleInput>
  }

  export type ModuleManufacturerUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleManufacturerWhereUniqueInput
    data: XOR<ModuleManufacturerUpdateWithoutModuleInput, ModuleManufacturerUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleManufacturerUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleManufacturerScalarWhereInput
    data: XOR<ModuleManufacturerUpdateManyMutationInput, ModuleManufacturerUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleItemComponentUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleItemComponentWhereUniqueInput
    update: XOR<ModuleItemComponentUpdateWithoutModuleInput, ModuleItemComponentUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleItemComponentCreateWithoutModuleInput, ModuleItemComponentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleItemComponentUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleItemComponentWhereUniqueInput
    data: XOR<ModuleItemComponentUpdateWithoutModuleInput, ModuleItemComponentUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleItemComponentUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleItemComponentScalarWhereInput
    data: XOR<ModuleItemComponentUpdateManyMutationInput, ModuleItemComponentUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleItemComponentScalarWhereInput = {
    AND?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
    OR?: ModuleItemComponentScalarWhereInput[]
    NOT?: ModuleItemComponentScalarWhereInput | ModuleItemComponentScalarWhereInput[]
    moduleCode?: StringFilter<"ModuleItemComponent"> | string
    itemCode?: StringFilter<"ModuleItemComponent"> | string
    quantity?: IntFilter<"ModuleItemComponent"> | number
  }

  export type ModuleOptionUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleOptionWhereUniqueInput
    update: XOR<ModuleOptionUpdateWithoutModuleInput, ModuleOptionUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleOptionCreateWithoutModuleInput, ModuleOptionUncheckedCreateWithoutModuleInput>
  }

  export type ModuleOptionUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleOptionWhereUniqueInput
    data: XOR<ModuleOptionUpdateWithoutModuleInput, ModuleOptionUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleOptionUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleOptionScalarWhereInput
    data: XOR<ModuleOptionUpdateManyMutationInput, ModuleOptionUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModulePriceUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModulePriceWhereUniqueInput
    update: XOR<ModulePriceUpdateWithoutModuleInput, ModulePriceUncheckedUpdateWithoutModuleInput>
    create: XOR<ModulePriceCreateWithoutModuleInput, ModulePriceUncheckedCreateWithoutModuleInput>
  }

  export type ModulePriceUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModulePriceWhereUniqueInput
    data: XOR<ModulePriceUpdateWithoutModuleInput, ModulePriceUncheckedUpdateWithoutModuleInput>
  }

  export type ModulePriceUpdateManyWithWhereWithoutModuleInput = {
    where: ModulePriceScalarWhereInput
    data: XOR<ModulePriceUpdateManyMutationInput, ModulePriceUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModulePriceScalarWhereInput = {
    AND?: ModulePriceScalarWhereInput | ModulePriceScalarWhereInput[]
    OR?: ModulePriceScalarWhereInput[]
    NOT?: ModulePriceScalarWhereInput | ModulePriceScalarWhereInput[]
    moduleCode?: StringFilter<"ModulePrice"> | string
    priceUsd?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ModulePrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemCategoryRelationCreateWithoutItemInput = {
    category: ItemCategoryCreateNestedOneWithoutItemsInput
  }

  export type ItemCategoryRelationUncheckedCreateWithoutItemInput = {
    categoryCode: string
  }

  export type ItemCategoryRelationCreateOrConnectWithoutItemInput = {
    where: ItemCategoryRelationWhereUniqueInput
    create: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput>
  }

  export type ItemCategoryRelationCreateManyItemInputEnvelope = {
    data: ItemCategoryRelationCreateManyItemInput | ItemCategoryRelationCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemSubcategoryRelationCreateWithoutItemInput = {
    subcategory: ItemSubcategoryCreateNestedOneWithoutItemsInput
  }

  export type ItemSubcategoryRelationUncheckedCreateWithoutItemInput = {
    subcategoryCode: string
  }

  export type ItemSubcategoryRelationCreateOrConnectWithoutItemInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    create: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput>
  }

  export type ItemSubcategoryRelationCreateManyItemInputEnvelope = {
    data: ItemSubcategoryRelationCreateManyItemInput | ItemSubcategoryRelationCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemPriceCreateWithoutItemInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUncheckedCreateWithoutItemInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceCreateOrConnectWithoutItemInput = {
    where: ItemPriceWhereUniqueInput
    create: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput>
  }

  export type ItemPriceCreateManyItemInputEnvelope = {
    data: ItemPriceCreateManyItemInput | ItemPriceCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemSupplierCreateWithoutItemInput = {
    supplier: SupplierCreateNestedOneWithoutItemsInput
  }

  export type ItemSupplierUncheckedCreateWithoutItemInput = {
    supplierCode: string
  }

  export type ItemSupplierCreateOrConnectWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    create: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput>
  }

  export type ItemSupplierCreateManyItemInputEnvelope = {
    data: ItemSupplierCreateManyItemInput | ItemSupplierCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CabinetItemComponentCreateWithoutItemInput = {
    quantity: number
    cabinet: CabinetCreateNestedOneWithoutItemsInput
  }

  export type CabinetItemComponentUncheckedCreateWithoutItemInput = {
    cabinetCode: string
    quantity: number
  }

  export type CabinetItemComponentCreateOrConnectWithoutItemInput = {
    where: CabinetItemComponentWhereUniqueInput
    create: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput>
  }

  export type CabinetItemComponentCreateManyItemInputEnvelope = {
    data: CabinetItemComponentCreateManyItemInput | CabinetItemComponentCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ModuleItemComponentCreateWithoutItemInput = {
    quantity: number
    module: ModuleCreateNestedOneWithoutItemsInput
  }

  export type ModuleItemComponentUncheckedCreateWithoutItemInput = {
    moduleCode: string
    quantity: number
  }

  export type ModuleItemComponentCreateOrConnectWithoutItemInput = {
    where: ModuleItemComponentWhereUniqueInput
    create: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput>
  }

  export type ModuleItemComponentCreateManyItemInputEnvelope = {
    data: ModuleItemComponentCreateManyItemInput | ModuleItemComponentCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryRelationUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemCategoryRelationWhereUniqueInput
    update: XOR<ItemCategoryRelationUpdateWithoutItemInput, ItemCategoryRelationUncheckedUpdateWithoutItemInput>
    create: XOR<ItemCategoryRelationCreateWithoutItemInput, ItemCategoryRelationUncheckedCreateWithoutItemInput>
  }

  export type ItemCategoryRelationUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemCategoryRelationWhereUniqueInput
    data: XOR<ItemCategoryRelationUpdateWithoutItemInput, ItemCategoryRelationUncheckedUpdateWithoutItemInput>
  }

  export type ItemCategoryRelationUpdateManyWithWhereWithoutItemInput = {
    where: ItemCategoryRelationScalarWhereInput
    data: XOR<ItemCategoryRelationUpdateManyMutationInput, ItemCategoryRelationUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemSubcategoryRelationUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    update: XOR<ItemSubcategoryRelationUpdateWithoutItemInput, ItemSubcategoryRelationUncheckedUpdateWithoutItemInput>
    create: XOR<ItemSubcategoryRelationCreateWithoutItemInput, ItemSubcategoryRelationUncheckedCreateWithoutItemInput>
  }

  export type ItemSubcategoryRelationUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemSubcategoryRelationWhereUniqueInput
    data: XOR<ItemSubcategoryRelationUpdateWithoutItemInput, ItemSubcategoryRelationUncheckedUpdateWithoutItemInput>
  }

  export type ItemSubcategoryRelationUpdateManyWithWhereWithoutItemInput = {
    where: ItemSubcategoryRelationScalarWhereInput
    data: XOR<ItemSubcategoryRelationUpdateManyMutationInput, ItemSubcategoryRelationUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemPriceUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemPriceWhereUniqueInput
    update: XOR<ItemPriceUpdateWithoutItemInput, ItemPriceUncheckedUpdateWithoutItemInput>
    create: XOR<ItemPriceCreateWithoutItemInput, ItemPriceUncheckedCreateWithoutItemInput>
  }

  export type ItemPriceUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemPriceWhereUniqueInput
    data: XOR<ItemPriceUpdateWithoutItemInput, ItemPriceUncheckedUpdateWithoutItemInput>
  }

  export type ItemPriceUpdateManyWithWhereWithoutItemInput = {
    where: ItemPriceScalarWhereInput
    data: XOR<ItemPriceUpdateManyMutationInput, ItemPriceUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemPriceScalarWhereInput = {
    AND?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
    OR?: ItemPriceScalarWhereInput[]
    NOT?: ItemPriceScalarWhereInput | ItemPriceScalarWhereInput[]
    itemCode?: StringFilter<"ItemPrice"> | string
    priceUsd?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
    priceRub?: DecimalNullableFilter<"ItemPrice"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemSupplierUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    update: XOR<ItemSupplierUpdateWithoutItemInput, ItemSupplierUncheckedUpdateWithoutItemInput>
    create: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput>
  }

  export type ItemSupplierUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    data: XOR<ItemSupplierUpdateWithoutItemInput, ItemSupplierUncheckedUpdateWithoutItemInput>
  }

  export type ItemSupplierUpdateManyWithWhereWithoutItemInput = {
    where: ItemSupplierScalarWhereInput
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyWithoutItemInput>
  }

  export type CabinetItemComponentUpsertWithWhereUniqueWithoutItemInput = {
    where: CabinetItemComponentWhereUniqueInput
    update: XOR<CabinetItemComponentUpdateWithoutItemInput, CabinetItemComponentUncheckedUpdateWithoutItemInput>
    create: XOR<CabinetItemComponentCreateWithoutItemInput, CabinetItemComponentUncheckedCreateWithoutItemInput>
  }

  export type CabinetItemComponentUpdateWithWhereUniqueWithoutItemInput = {
    where: CabinetItemComponentWhereUniqueInput
    data: XOR<CabinetItemComponentUpdateWithoutItemInput, CabinetItemComponentUncheckedUpdateWithoutItemInput>
  }

  export type CabinetItemComponentUpdateManyWithWhereWithoutItemInput = {
    where: CabinetItemComponentScalarWhereInput
    data: XOR<CabinetItemComponentUpdateManyMutationInput, CabinetItemComponentUncheckedUpdateManyWithoutItemInput>
  }

  export type ModuleItemComponentUpsertWithWhereUniqueWithoutItemInput = {
    where: ModuleItemComponentWhereUniqueInput
    update: XOR<ModuleItemComponentUpdateWithoutItemInput, ModuleItemComponentUncheckedUpdateWithoutItemInput>
    create: XOR<ModuleItemComponentCreateWithoutItemInput, ModuleItemComponentUncheckedCreateWithoutItemInput>
  }

  export type ModuleItemComponentUpdateWithWhereUniqueWithoutItemInput = {
    where: ModuleItemComponentWhereUniqueInput
    data: XOR<ModuleItemComponentUpdateWithoutItemInput, ModuleItemComponentUncheckedUpdateWithoutItemInput>
  }

  export type ModuleItemComponentUpdateManyWithWhereWithoutItemInput = {
    where: ModuleItemComponentScalarWhereInput
    data: XOR<ModuleItemComponentUpdateManyMutationInput, ModuleItemComponentUncheckedUpdateManyWithoutItemInput>
  }

  export type ScreenTypeCreateWithoutOptionsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    controlTypes?: ScreenTypeControlTypeCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeUncheckedCreateWithoutOptionsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    controlTypes?: ScreenTypeControlTypeUncheckedCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorUncheckedCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeCreateOrConnectWithoutOptionsInput = {
    where: ScreenTypeWhereUniqueInput
    create: XOR<ScreenTypeCreateWithoutOptionsInput, ScreenTypeUncheckedCreateWithoutOptionsInput>
  }

  export type OptionCreateWithoutScreenTypesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOptionCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutScreenTypesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutScreenTypesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutScreenTypesInput, OptionUncheckedCreateWithoutScreenTypesInput>
  }

  export type ScreenTypeUpsertWithoutOptionsInput = {
    update: XOR<ScreenTypeUpdateWithoutOptionsInput, ScreenTypeUncheckedUpdateWithoutOptionsInput>
    create: XOR<ScreenTypeCreateWithoutOptionsInput, ScreenTypeUncheckedCreateWithoutOptionsInput>
    where?: ScreenTypeWhereInput
  }

  export type ScreenTypeUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ScreenTypeWhereInput
    data: XOR<ScreenTypeUpdateWithoutOptionsInput, ScreenTypeUncheckedUpdateWithoutOptionsInput>
  }

  export type ScreenTypeUpdateWithoutOptionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    controlTypes?: ScreenTypeControlTypeUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUpdateManyWithoutScreenTypeNestedInput
  }

  export type ScreenTypeUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    controlTypes?: ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeNestedInput
  }

  export type OptionUpsertWithoutScreenTypesInput = {
    update: XOR<OptionUpdateWithoutScreenTypesInput, OptionUncheckedUpdateWithoutScreenTypesInput>
    create: XOR<OptionCreateWithoutScreenTypesInput, OptionUncheckedCreateWithoutScreenTypesInput>
    where?: OptionWhereInput
  }

  export type OptionUpdateToOneWithWhereWithoutScreenTypesInput = {
    where?: OptionWhereInput
    data: XOR<OptionUpdateWithoutScreenTypesInput, OptionUncheckedUpdateWithoutScreenTypesInput>
  }

  export type OptionUpdateWithoutScreenTypesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOptionUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutScreenTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type ScreenTypeCreateWithoutControlTypesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeUncheckedCreateWithoutControlTypesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionUncheckedCreateNestedManyWithoutScreenTypeInput
    sensors?: ScreenTypeSensorUncheckedCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeCreateOrConnectWithoutControlTypesInput = {
    where: ScreenTypeWhereUniqueInput
    create: XOR<ScreenTypeCreateWithoutControlTypesInput, ScreenTypeUncheckedCreateWithoutControlTypesInput>
  }

  export type ControlTypeCreateWithoutScreenTypesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlTypeUncheckedCreateWithoutScreenTypesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlTypeCreateOrConnectWithoutScreenTypesInput = {
    where: ControlTypeWhereUniqueInput
    create: XOR<ControlTypeCreateWithoutScreenTypesInput, ControlTypeUncheckedCreateWithoutScreenTypesInput>
  }

  export type ScreenTypeUpsertWithoutControlTypesInput = {
    update: XOR<ScreenTypeUpdateWithoutControlTypesInput, ScreenTypeUncheckedUpdateWithoutControlTypesInput>
    create: XOR<ScreenTypeCreateWithoutControlTypesInput, ScreenTypeUncheckedCreateWithoutControlTypesInput>
    where?: ScreenTypeWhereInput
  }

  export type ScreenTypeUpdateToOneWithWhereWithoutControlTypesInput = {
    where?: ScreenTypeWhereInput
    data: XOR<ScreenTypeUpdateWithoutControlTypesInput, ScreenTypeUncheckedUpdateWithoutControlTypesInput>
  }

  export type ScreenTypeUpdateWithoutControlTypesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUpdateManyWithoutScreenTypeNestedInput
  }

  export type ScreenTypeUncheckedUpdateWithoutControlTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeNestedInput
    sensors?: ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeNestedInput
  }

  export type ControlTypeUpsertWithoutScreenTypesInput = {
    update: XOR<ControlTypeUpdateWithoutScreenTypesInput, ControlTypeUncheckedUpdateWithoutScreenTypesInput>
    create: XOR<ControlTypeCreateWithoutScreenTypesInput, ControlTypeUncheckedCreateWithoutScreenTypesInput>
    where?: ControlTypeWhereInput
  }

  export type ControlTypeUpdateToOneWithWhereWithoutScreenTypesInput = {
    where?: ControlTypeWhereInput
    data: XOR<ControlTypeUpdateWithoutScreenTypesInput, ControlTypeUncheckedUpdateWithoutScreenTypesInput>
  }

  export type ControlTypeUpdateWithoutScreenTypesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlTypeUncheckedUpdateWithoutScreenTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenTypeCreateWithoutSensorsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionCreateNestedManyWithoutScreenTypeInput
    controlTypes?: ScreenTypeControlTypeCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeUncheckedCreateWithoutSensorsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ScreenTypeOptionUncheckedCreateNestedManyWithoutScreenTypeInput
    controlTypes?: ScreenTypeControlTypeUncheckedCreateNestedManyWithoutScreenTypeInput
  }

  export type ScreenTypeCreateOrConnectWithoutSensorsInput = {
    where: ScreenTypeWhereUniqueInput
    create: XOR<ScreenTypeCreateWithoutSensorsInput, ScreenTypeUncheckedCreateWithoutSensorsInput>
  }

  export type SensorCreateWithoutScreenTypesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SensorUncheckedCreateWithoutScreenTypesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SensorCreateOrConnectWithoutScreenTypesInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutScreenTypesInput, SensorUncheckedCreateWithoutScreenTypesInput>
  }

  export type ScreenTypeUpsertWithoutSensorsInput = {
    update: XOR<ScreenTypeUpdateWithoutSensorsInput, ScreenTypeUncheckedUpdateWithoutSensorsInput>
    create: XOR<ScreenTypeCreateWithoutSensorsInput, ScreenTypeUncheckedCreateWithoutSensorsInput>
    where?: ScreenTypeWhereInput
  }

  export type ScreenTypeUpdateToOneWithWhereWithoutSensorsInput = {
    where?: ScreenTypeWhereInput
    data: XOR<ScreenTypeUpdateWithoutSensorsInput, ScreenTypeUncheckedUpdateWithoutSensorsInput>
  }

  export type ScreenTypeUpdateWithoutSensorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUpdateManyWithoutScreenTypeNestedInput
    controlTypes?: ScreenTypeControlTypeUpdateManyWithoutScreenTypeNestedInput
  }

  export type ScreenTypeUncheckedUpdateWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeNestedInput
    controlTypes?: ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeNestedInput
  }

  export type SensorUpsertWithoutScreenTypesInput = {
    update: XOR<SensorUpdateWithoutScreenTypesInput, SensorUncheckedUpdateWithoutScreenTypesInput>
    create: XOR<SensorCreateWithoutScreenTypesInput, SensorUncheckedCreateWithoutScreenTypesInput>
    where?: SensorWhereInput
  }

  export type SensorUpdateToOneWithWhereWithoutScreenTypesInput = {
    where?: SensorWhereInput
    data: XOR<SensorUpdateWithoutScreenTypesInput, SensorUncheckedUpdateWithoutScreenTypesInput>
  }

  export type SensorUpdateWithoutScreenTypesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorUncheckedUpdateWithoutScreenTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateWithoutCategoriesInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoriesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoriesInput, ItemUncheckedCreateWithoutCategoriesInput>
  }

  export type ItemCategoryCreateWithoutItemsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutCategoriesInput = {
    update: XOR<ItemUpdateWithoutCategoriesInput, ItemUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ItemCreateWithoutCategoriesInput, ItemUncheckedCreateWithoutCategoriesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCategoriesInput, ItemUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemUpdateWithoutCategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCategoryUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCreateWithoutSubcategoriesInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSubcategoriesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSubcategoriesInput, ItemUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryCreateWithoutItemsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryCreateOrConnectWithoutItemsInput = {
    where: ItemSubcategoryWhereUniqueInput
    create: XOR<ItemSubcategoryCreateWithoutItemsInput, ItemSubcategoryUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutSubcategoriesInput = {
    update: XOR<ItemUpdateWithoutSubcategoriesInput, ItemUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<ItemCreateWithoutSubcategoriesInput, ItemUncheckedCreateWithoutSubcategoriesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSubcategoriesInput, ItemUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemUpdateWithoutSubcategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemSubcategoryUpsertWithoutItemsInput = {
    update: XOR<ItemSubcategoryUpdateWithoutItemsInput, ItemSubcategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemSubcategoryCreateWithoutItemsInput, ItemSubcategoryUncheckedCreateWithoutItemsInput>
    where?: ItemSubcategoryWhereInput
  }

  export type ItemSubcategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemSubcategoryWhereInput
    data: XOR<ItemSubcategoryUpdateWithoutItemsInput, ItemSubcategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemSubcategoryUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemCreateWithoutPricesInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPricesInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPricesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPricesInput, ItemUncheckedCreateWithoutPricesInput>
  }

  export type ItemUpsertWithoutPricesInput = {
    update: XOR<ItemUpdateWithoutPricesInput, ItemUncheckedUpdateWithoutPricesInput>
    create: XOR<ItemCreateWithoutPricesInput, ItemUncheckedCreateWithoutPricesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPricesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPricesInput, ItemUncheckedUpdateWithoutPricesInput>
  }

  export type ItemUpdateWithoutPricesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateWithoutSuppliersInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSuppliersInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSuppliersInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSuppliersInput, ItemUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutItemsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutItemsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutSuppliersInput = {
    update: XOR<ItemUpdateWithoutSuppliersInput, ItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<ItemCreateWithoutSuppliersInput, ItemUncheckedCreateWithoutSuppliersInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSuppliersInput, ItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type ItemUpdateWithoutSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierUpsertWithoutItemsInput = {
    update: XOR<SupplierUpdateWithoutItemsInput, SupplierUncheckedUpdateWithoutItemsInput>
    create: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutItemsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutItemsInput, SupplierUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ItemCategoryCreateWithoutSubcategoriesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCategoryRelationCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCategoryRelationUncheckedCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutSubcategoriesInput, ItemCategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryCreateWithoutCategoriesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemSubcategoryRelationCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUncheckedCreateWithoutCategoriesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryCreateOrConnectWithoutCategoriesInput = {
    where: ItemSubcategoryWhereUniqueInput
    create: XOR<ItemSubcategoryCreateWithoutCategoriesInput, ItemSubcategoryUncheckedCreateWithoutCategoriesInput>
  }

  export type ItemCategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<ItemCategoryUpdateWithoutSubcategoriesInput, ItemCategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<ItemCategoryCreateWithoutSubcategoriesInput, ItemCategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutSubcategoriesInput, ItemCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ItemCategoryUpdateWithoutSubcategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemCategoryRelationUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemCategoryRelationUncheckedUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemSubcategoryUpsertWithoutCategoriesInput = {
    update: XOR<ItemSubcategoryUpdateWithoutCategoriesInput, ItemSubcategoryUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ItemSubcategoryCreateWithoutCategoriesInput, ItemSubcategoryUncheckedCreateWithoutCategoriesInput>
    where?: ItemSubcategoryWhereInput
  }

  export type ItemSubcategoryUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ItemSubcategoryWhereInput
    data: XOR<ItemSubcategoryUpdateWithoutCategoriesInput, ItemSubcategoryUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemSubcategoryUpdateWithoutCategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemSubcategoryRelationUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type CabinetCreateWithoutCategoriesInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutCategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutCategoriesInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutCategoriesInput, CabinetUncheckedCreateWithoutCategoriesInput>
  }

  export type ItemCategoryCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationUncheckedCreateNestedManyWithoutCategoryInput
    modules?: ModuleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutCabinetsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutCabinetsInput, ItemCategoryUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutCategoriesInput = {
    update: XOR<CabinetUpdateWithoutCategoriesInput, CabinetUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CabinetCreateWithoutCategoriesInput, CabinetUncheckedCreateWithoutCategoriesInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutCategoriesInput, CabinetUncheckedUpdateWithoutCategoriesInput>
  }

  export type CabinetUpdateWithoutCategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ItemCategoryUpsertWithoutCabinetsInput = {
    update: XOR<ItemCategoryUpdateWithoutCabinetsInput, ItemCategoryUncheckedUpdateWithoutCabinetsInput>
    create: XOR<ItemCategoryCreateWithoutCabinetsInput, ItemCategoryUncheckedCreateWithoutCabinetsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutCabinetsInput, ItemCategoryUncheckedUpdateWithoutCabinetsInput>
  }

  export type ItemCategoryUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUncheckedUpdateManyWithoutCategoryNestedInput
    modules?: ModuleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CabinetCreateWithoutSubcategoriesInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutSubcategoriesInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutSubcategoriesInput, CabinetUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutSubcategoryInput
    modules?: ModuleSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryCreateOrConnectWithoutCabinetsInput = {
    where: ItemSubcategoryWhereUniqueInput
    create: XOR<ItemSubcategoryCreateWithoutCabinetsInput, ItemSubcategoryUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutSubcategoriesInput = {
    update: XOR<CabinetUpdateWithoutSubcategoriesInput, CabinetUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CabinetCreateWithoutSubcategoriesInput, CabinetUncheckedCreateWithoutSubcategoriesInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutSubcategoriesInput, CabinetUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CabinetUpdateWithoutSubcategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ItemSubcategoryUpsertWithoutCabinetsInput = {
    update: XOR<ItemSubcategoryUpdateWithoutCabinetsInput, ItemSubcategoryUncheckedUpdateWithoutCabinetsInput>
    create: XOR<ItemSubcategoryCreateWithoutCabinetsInput, ItemSubcategoryUncheckedCreateWithoutCabinetsInput>
    where?: ItemSubcategoryWhereInput
  }

  export type ItemSubcategoryUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: ItemSubcategoryWhereInput
    data: XOR<ItemSubcategoryUpdateWithoutCabinetsInput, ItemSubcategoryUncheckedUpdateWithoutCabinetsInput>
  }

  export type ItemSubcategoryUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryNestedInput
    modules?: ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type CabinetCreateWithoutLocationsInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutLocationsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutLocationsInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutLocationsInput, CabinetUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCabinetsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCabinetsInput, LocationUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutLocationsInput = {
    update: XOR<CabinetUpdateWithoutLocationsInput, CabinetUncheckedUpdateWithoutLocationsInput>
    create: XOR<CabinetCreateWithoutLocationsInput, CabinetUncheckedCreateWithoutLocationsInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutLocationsInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutLocationsInput, CabinetUncheckedUpdateWithoutLocationsInput>
  }

  export type CabinetUpdateWithoutLocationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type LocationUpsertWithoutCabinetsInput = {
    update: XOR<LocationUpdateWithoutCabinetsInput, LocationUncheckedUpdateWithoutCabinetsInput>
    create: XOR<LocationCreateWithoutCabinetsInput, LocationUncheckedCreateWithoutCabinetsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutCabinetsInput, LocationUncheckedUpdateWithoutCabinetsInput>
  }

  export type LocationUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CabinetCreateWithoutPlacementsInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutPlacementsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutPlacementsInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutPlacementsInput, CabinetUncheckedCreateWithoutPlacementsInput>
  }

  export type PlacementCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlacementUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlacementCreateOrConnectWithoutCabinetsInput = {
    where: PlacementWhereUniqueInput
    create: XOR<PlacementCreateWithoutCabinetsInput, PlacementUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutPlacementsInput = {
    update: XOR<CabinetUpdateWithoutPlacementsInput, CabinetUncheckedUpdateWithoutPlacementsInput>
    create: XOR<CabinetCreateWithoutPlacementsInput, CabinetUncheckedCreateWithoutPlacementsInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutPlacementsInput, CabinetUncheckedUpdateWithoutPlacementsInput>
  }

  export type CabinetUpdateWithoutPlacementsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutPlacementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type PlacementUpsertWithoutCabinetsInput = {
    update: XOR<PlacementUpdateWithoutCabinetsInput, PlacementUncheckedUpdateWithoutCabinetsInput>
    create: XOR<PlacementCreateWithoutCabinetsInput, PlacementUncheckedCreateWithoutCabinetsInput>
    where?: PlacementWhereInput
  }

  export type PlacementUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: PlacementWhereInput
    data: XOR<PlacementUpdateWithoutCabinetsInput, PlacementUncheckedUpdateWithoutCabinetsInput>
  }

  export type PlacementUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetCreateWithoutMaterialsInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutMaterialsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutMaterialsInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutMaterialsInput, CabinetUncheckedCreateWithoutMaterialsInput>
  }

  export type MaterialCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutCabinetsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCabinetsInput, MaterialUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutMaterialsInput = {
    update: XOR<CabinetUpdateWithoutMaterialsInput, CabinetUncheckedUpdateWithoutMaterialsInput>
    create: XOR<CabinetCreateWithoutMaterialsInput, CabinetUncheckedCreateWithoutMaterialsInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutMaterialsInput, CabinetUncheckedUpdateWithoutMaterialsInput>
  }

  export type CabinetUpdateWithoutMaterialsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type MaterialUpsertWithoutCabinetsInput = {
    update: XOR<MaterialUpdateWithoutCabinetsInput, MaterialUncheckedUpdateWithoutCabinetsInput>
    create: XOR<MaterialCreateWithoutCabinetsInput, MaterialUncheckedCreateWithoutCabinetsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutCabinetsInput, MaterialUncheckedUpdateWithoutCabinetsInput>
  }

  export type MaterialUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetCreateWithoutSizesInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutSizesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutSizesInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutSizesInput, CabinetUncheckedCreateWithoutSizesInput>
  }

  export type CabinetSizeCreateWithoutCabinetsInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    moduleSizes?: CabinetSizeModuleSizeCreateNestedManyWithoutCabinetSizeInput
  }

  export type CabinetSizeUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    moduleSizes?: CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutCabinetSizeInput
  }

  export type CabinetSizeCreateOrConnectWithoutCabinetsInput = {
    where: CabinetSizeWhereUniqueInput
    create: XOR<CabinetSizeCreateWithoutCabinetsInput, CabinetSizeUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutSizesInput = {
    update: XOR<CabinetUpdateWithoutSizesInput, CabinetUncheckedUpdateWithoutSizesInput>
    create: XOR<CabinetCreateWithoutSizesInput, CabinetUncheckedCreateWithoutSizesInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutSizesInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutSizesInput, CabinetUncheckedUpdateWithoutSizesInput>
  }

  export type CabinetUpdateWithoutSizesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetSizeUpsertWithoutCabinetsInput = {
    update: XOR<CabinetSizeUpdateWithoutCabinetsInput, CabinetSizeUncheckedUpdateWithoutCabinetsInput>
    create: XOR<CabinetSizeCreateWithoutCabinetsInput, CabinetSizeUncheckedCreateWithoutCabinetsInput>
    where?: CabinetSizeWhereInput
  }

  export type CabinetSizeUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: CabinetSizeWhereInput
    data: XOR<CabinetSizeUpdateWithoutCabinetsInput, CabinetSizeUncheckedUpdateWithoutCabinetsInput>
  }

  export type CabinetSizeUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moduleSizes?: CabinetSizeModuleSizeUpdateManyWithoutCabinetSizeNestedInput
  }

  export type CabinetSizeUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moduleSizes?: CabinetSizeModuleSizeUncheckedUpdateManyWithoutCabinetSizeNestedInput
  }

  export type CabinetCreateWithoutPitchesInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutPitchesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutPitchesInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutPitchesInput, CabinetUncheckedCreateWithoutPitchesInput>
  }

  export type PitchCreateWithoutCabinetsInput = {
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModulePitchCreateNestedManyWithoutPitchInput
  }

  export type PitchUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModulePitchUncheckedCreateNestedManyWithoutPitchInput
  }

  export type PitchCreateOrConnectWithoutCabinetsInput = {
    where: PitchWhereUniqueInput
    create: XOR<PitchCreateWithoutCabinetsInput, PitchUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutPitchesInput = {
    update: XOR<CabinetUpdateWithoutPitchesInput, CabinetUncheckedUpdateWithoutPitchesInput>
    create: XOR<CabinetCreateWithoutPitchesInput, CabinetUncheckedCreateWithoutPitchesInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutPitchesInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutPitchesInput, CabinetUncheckedUpdateWithoutPitchesInput>
  }

  export type CabinetUpdateWithoutPitchesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutPitchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type PitchUpsertWithoutCabinetsInput = {
    update: XOR<PitchUpdateWithoutCabinetsInput, PitchUncheckedUpdateWithoutCabinetsInput>
    create: XOR<PitchCreateWithoutCabinetsInput, PitchUncheckedCreateWithoutCabinetsInput>
    where?: PitchWhereInput
  }

  export type PitchUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: PitchWhereInput
    data: XOR<PitchUpdateWithoutCabinetsInput, PitchUncheckedUpdateWithoutCabinetsInput>
  }

  export type PitchUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModulePitchUpdateManyWithoutPitchNestedInput
  }

  export type PitchUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModulePitchUncheckedUpdateManyWithoutPitchNestedInput
  }

  export type CabinetCreateWithoutManufacturersInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutManufacturersInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutManufacturersInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutManufacturersInput, CabinetUncheckedCreateWithoutManufacturersInput>
  }

  export type ManufacturerCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleManufacturerCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleManufacturerUncheckedCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerCreateOrConnectWithoutCabinetsInput = {
    where: ManufacturerWhereUniqueInput
    create: XOR<ManufacturerCreateWithoutCabinetsInput, ManufacturerUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutManufacturersInput = {
    update: XOR<CabinetUpdateWithoutManufacturersInput, CabinetUncheckedUpdateWithoutManufacturersInput>
    create: XOR<CabinetCreateWithoutManufacturersInput, CabinetUncheckedCreateWithoutManufacturersInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutManufacturersInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutManufacturersInput, CabinetUncheckedUpdateWithoutManufacturersInput>
  }

  export type CabinetUpdateWithoutManufacturersInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutManufacturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ManufacturerUpsertWithoutCabinetsInput = {
    update: XOR<ManufacturerUpdateWithoutCabinetsInput, ManufacturerUncheckedUpdateWithoutCabinetsInput>
    create: XOR<ManufacturerCreateWithoutCabinetsInput, ManufacturerUncheckedCreateWithoutCabinetsInput>
    where?: ManufacturerWhereInput
  }

  export type ManufacturerUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: ManufacturerWhereInput
    data: XOR<ManufacturerUpdateWithoutCabinetsInput, ManufacturerUncheckedUpdateWithoutCabinetsInput>
  }

  export type ManufacturerUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleManufacturerUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput
  }

  export type CabinetCreateWithoutSuppliersInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutSuppliersInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutSuppliersInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutSuppliersInput, CabinetUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutCabinetsInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCabinetsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCabinetsInput, SupplierUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutSuppliersInput = {
    update: XOR<CabinetUpdateWithoutSuppliersInput, CabinetUncheckedUpdateWithoutSuppliersInput>
    create: XOR<CabinetCreateWithoutSuppliersInput, CabinetUncheckedCreateWithoutSuppliersInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutSuppliersInput, CabinetUncheckedUpdateWithoutSuppliersInput>
  }

  export type CabinetUpdateWithoutSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type SupplierUpsertWithoutCabinetsInput = {
    update: XOR<SupplierUpdateWithoutCabinetsInput, SupplierUncheckedUpdateWithoutCabinetsInput>
    create: XOR<SupplierCreateWithoutCabinetsInput, SupplierUncheckedCreateWithoutCabinetsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutCabinetsInput, SupplierUncheckedUpdateWithoutCabinetsInput>
  }

  export type SupplierUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CabinetCreateWithoutItemsInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    prices?: CabinetPriceUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutItemsInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutItemsInput, CabinetUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutCabinetsInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCabinetsInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    modules?: ModuleItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCabinetsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCabinetsInput, ItemUncheckedCreateWithoutCabinetsInput>
  }

  export type CabinetUpsertWithoutItemsInput = {
    update: XOR<CabinetUpdateWithoutItemsInput, CabinetUncheckedUpdateWithoutItemsInput>
    create: XOR<CabinetCreateWithoutItemsInput, CabinetUncheckedCreateWithoutItemsInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutItemsInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutItemsInput, CabinetUncheckedUpdateWithoutItemsInput>
  }

  export type CabinetUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    prices?: CabinetPriceUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ItemUpsertWithoutCabinetsInput = {
    update: XOR<ItemUpdateWithoutCabinetsInput, ItemUncheckedUpdateWithoutCabinetsInput>
    create: XOR<ItemCreateWithoutCabinetsInput, ItemUncheckedCreateWithoutCabinetsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCabinetsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCabinetsInput, ItemUncheckedUpdateWithoutCabinetsInput>
  }

  export type ItemUpdateWithoutCabinetsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCabinetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    modules?: ModuleItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CabinetCreateWithoutPricesInput = {
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentCreateNestedManyWithoutCabinetInput
  }

  export type CabinetUncheckedCreateWithoutPricesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CabinetCategoryUncheckedCreateNestedManyWithoutCabinetInput
    subcategories?: CabinetSubcategoryUncheckedCreateNestedManyWithoutCabinetInput
    locations?: CabinetLocationUncheckedCreateNestedManyWithoutCabinetInput
    placements?: CabinetPlacementUncheckedCreateNestedManyWithoutCabinetInput
    materials?: CabinetMaterialUncheckedCreateNestedManyWithoutCabinetInput
    sizes?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutCabinetInput
    pitches?: CabinetPitchUncheckedCreateNestedManyWithoutCabinetInput
    manufacturers?: CabinetManufacturerUncheckedCreateNestedManyWithoutCabinetInput
    suppliers?: CabinetSupplierUncheckedCreateNestedManyWithoutCabinetInput
    items?: CabinetItemComponentUncheckedCreateNestedManyWithoutCabinetInput
  }

  export type CabinetCreateOrConnectWithoutPricesInput = {
    where: CabinetWhereUniqueInput
    create: XOR<CabinetCreateWithoutPricesInput, CabinetUncheckedCreateWithoutPricesInput>
  }

  export type CabinetUpsertWithoutPricesInput = {
    update: XOR<CabinetUpdateWithoutPricesInput, CabinetUncheckedUpdateWithoutPricesInput>
    create: XOR<CabinetCreateWithoutPricesInput, CabinetUncheckedCreateWithoutPricesInput>
    where?: CabinetWhereInput
  }

  export type CabinetUpdateToOneWithWhereWithoutPricesInput = {
    where?: CabinetWhereInput
    data: XOR<CabinetUpdateWithoutPricesInput, CabinetUncheckedUpdateWithoutPricesInput>
  }

  export type CabinetUpdateWithoutPricesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUpdateManyWithoutCabinetNestedInput
  }

  export type CabinetUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CabinetCategoryUncheckedUpdateManyWithoutCabinetNestedInput
    subcategories?: CabinetSubcategoryUncheckedUpdateManyWithoutCabinetNestedInput
    locations?: CabinetLocationUncheckedUpdateManyWithoutCabinetNestedInput
    placements?: CabinetPlacementUncheckedUpdateManyWithoutCabinetNestedInput
    materials?: CabinetMaterialUncheckedUpdateManyWithoutCabinetNestedInput
    sizes?: CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetNestedInput
    pitches?: CabinetPitchUncheckedUpdateManyWithoutCabinetNestedInput
    manufacturers?: CabinetManufacturerUncheckedUpdateManyWithoutCabinetNestedInput
    suppliers?: CabinetSupplierUncheckedUpdateManyWithoutCabinetNestedInput
    items?: CabinetItemComponentUncheckedUpdateManyWithoutCabinetNestedInput
  }

  export type ModuleCreateWithoutCategoriesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCategoriesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCategoriesInput, ModuleUncheckedCreateWithoutCategoriesInput>
  }

  export type ItemCategoryCreateWithoutModulesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    items?: ItemCategoryRelationUncheckedCreateNestedManyWithoutCategoryInput
    cabinets?: CabinetCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutModulesInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutModulesInput, ItemCategoryUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutCategoriesInput = {
    update: XOR<ModuleUpdateWithoutCategoriesInput, ModuleUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ModuleCreateWithoutCategoriesInput, ModuleUncheckedCreateWithoutCategoriesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutCategoriesInput, ModuleUncheckedUpdateWithoutCategoriesInput>
  }

  export type ModuleUpdateWithoutCategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ItemCategoryUpsertWithoutModulesInput = {
    update: XOR<ItemCategoryUpdateWithoutModulesInput, ItemCategoryUncheckedUpdateWithoutModulesInput>
    create: XOR<ItemCategoryCreateWithoutModulesInput, ItemCategoryUncheckedCreateWithoutModulesInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutModulesInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutModulesInput, ItemCategoryUncheckedUpdateWithoutModulesInput>
  }

  export type ItemCategoryUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    items?: ItemCategoryRelationUncheckedUpdateManyWithoutCategoryNestedInput
    cabinets?: CabinetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ModuleCreateWithoutSubcategoriesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutSubcategoriesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutSubcategoriesInput, ModuleUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ItemSubcategoryCreateWithoutModulesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategorySubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
    items?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutSubcategoryInput
    cabinets?: CabinetSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ItemSubcategoryCreateOrConnectWithoutModulesInput = {
    where: ItemSubcategoryWhereUniqueInput
    create: XOR<ItemSubcategoryCreateWithoutModulesInput, ItemSubcategoryUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutSubcategoriesInput = {
    update: XOR<ModuleUpdateWithoutSubcategoriesInput, ModuleUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<ModuleCreateWithoutSubcategoriesInput, ModuleUncheckedCreateWithoutSubcategoriesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutSubcategoriesInput, ModuleUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ModuleUpdateWithoutSubcategoriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ItemSubcategoryUpsertWithoutModulesInput = {
    update: XOR<ItemSubcategoryUpdateWithoutModulesInput, ItemSubcategoryUncheckedUpdateWithoutModulesInput>
    create: XOR<ItemSubcategoryCreateWithoutModulesInput, ItemSubcategoryUncheckedCreateWithoutModulesInput>
    where?: ItemSubcategoryWhereInput
  }

  export type ItemSubcategoryUpdateToOneWithWhereWithoutModulesInput = {
    where?: ItemSubcategoryWhereInput
    data: XOR<ItemSubcategoryUpdateWithoutModulesInput, ItemSubcategoryUncheckedUpdateWithoutModulesInput>
  }

  export type ItemSubcategoryUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ItemSubcategoryUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
    items?: ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryNestedInput
    cabinets?: CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ModuleCreateWithoutLocationsInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutLocationsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutLocationsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutLocationsInput, ModuleUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutModulesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutModulesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutModulesInput, LocationUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutLocationsInput = {
    update: XOR<ModuleUpdateWithoutLocationsInput, ModuleUncheckedUpdateWithoutLocationsInput>
    create: XOR<ModuleCreateWithoutLocationsInput, ModuleUncheckedCreateWithoutLocationsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutLocationsInput, ModuleUncheckedUpdateWithoutLocationsInput>
  }

  export type ModuleUpdateWithoutLocationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type LocationUpsertWithoutModulesInput = {
    update: XOR<LocationUpdateWithoutModulesInput, LocationUncheckedUpdateWithoutModulesInput>
    create: XOR<LocationCreateWithoutModulesInput, LocationUncheckedCreateWithoutModulesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutModulesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutModulesInput, LocationUncheckedUpdateWithoutModulesInput>
  }

  export type LocationUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ModuleCreateWithoutRefreshRatesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutRefreshRatesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutRefreshRatesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutRefreshRatesInput, ModuleUncheckedCreateWithoutRefreshRatesInput>
  }

  export type RefreshRateCreateWithoutModulesInput = {
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshRateUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshRateCreateOrConnectWithoutModulesInput = {
    where: RefreshRateWhereUniqueInput
    create: XOR<RefreshRateCreateWithoutModulesInput, RefreshRateUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutRefreshRatesInput = {
    update: XOR<ModuleUpdateWithoutRefreshRatesInput, ModuleUncheckedUpdateWithoutRefreshRatesInput>
    create: XOR<ModuleCreateWithoutRefreshRatesInput, ModuleUncheckedCreateWithoutRefreshRatesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutRefreshRatesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutRefreshRatesInput, ModuleUncheckedUpdateWithoutRefreshRatesInput>
  }

  export type ModuleUpdateWithoutRefreshRatesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutRefreshRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type RefreshRateUpsertWithoutModulesInput = {
    update: XOR<RefreshRateUpdateWithoutModulesInput, RefreshRateUncheckedUpdateWithoutModulesInput>
    create: XOR<RefreshRateCreateWithoutModulesInput, RefreshRateUncheckedCreateWithoutModulesInput>
    where?: RefreshRateWhereInput
  }

  export type RefreshRateUpdateToOneWithWhereWithoutModulesInput = {
    where?: RefreshRateWhereInput
    data: XOR<RefreshRateUpdateWithoutModulesInput, RefreshRateUncheckedUpdateWithoutModulesInput>
  }

  export type RefreshRateUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshRateUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateWithoutBrightnessesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutBrightnessesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutBrightnessesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutBrightnessesInput, ModuleUncheckedCreateWithoutBrightnessesInput>
  }

  export type BrightnessCreateWithoutModulesInput = {
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrightnessUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    value: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrightnessCreateOrConnectWithoutModulesInput = {
    where: BrightnessWhereUniqueInput
    create: XOR<BrightnessCreateWithoutModulesInput, BrightnessUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutBrightnessesInput = {
    update: XOR<ModuleUpdateWithoutBrightnessesInput, ModuleUncheckedUpdateWithoutBrightnessesInput>
    create: XOR<ModuleCreateWithoutBrightnessesInput, ModuleUncheckedCreateWithoutBrightnessesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutBrightnessesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutBrightnessesInput, ModuleUncheckedUpdateWithoutBrightnessesInput>
  }

  export type ModuleUpdateWithoutBrightnessesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutBrightnessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type BrightnessUpsertWithoutModulesInput = {
    update: XOR<BrightnessUpdateWithoutModulesInput, BrightnessUncheckedUpdateWithoutModulesInput>
    create: XOR<BrightnessCreateWithoutModulesInput, BrightnessUncheckedCreateWithoutModulesInput>
    where?: BrightnessWhereInput
  }

  export type BrightnessUpdateToOneWithWhereWithoutModulesInput = {
    where?: BrightnessWhereInput
    data: XOR<BrightnessUpdateWithoutModulesInput, BrightnessUncheckedUpdateWithoutModulesInput>
  }

  export type BrightnessUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrightnessUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateWithoutSizesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutSizesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutSizesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutSizesInput, ModuleUncheckedCreateWithoutSizesInput>
  }

  export type ModuleSizeCreateWithoutModulesInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinetSizes?: CabinetSizeModuleSizeCreateNestedManyWithoutModuleSizeInput
  }

  export type ModuleSizeUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinetSizes?: CabinetSizeModuleSizeUncheckedCreateNestedManyWithoutModuleSizeInput
  }

  export type ModuleSizeCreateOrConnectWithoutModulesInput = {
    where: ModuleSizeWhereUniqueInput
    create: XOR<ModuleSizeCreateWithoutModulesInput, ModuleSizeUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutSizesInput = {
    update: XOR<ModuleUpdateWithoutSizesInput, ModuleUncheckedUpdateWithoutSizesInput>
    create: XOR<ModuleCreateWithoutSizesInput, ModuleUncheckedCreateWithoutSizesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutSizesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutSizesInput, ModuleUncheckedUpdateWithoutSizesInput>
  }

  export type ModuleUpdateWithoutSizesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleSizeUpsertWithoutModulesInput = {
    update: XOR<ModuleSizeUpdateWithoutModulesInput, ModuleSizeUncheckedUpdateWithoutModulesInput>
    create: XOR<ModuleSizeCreateWithoutModulesInput, ModuleSizeUncheckedCreateWithoutModulesInput>
    where?: ModuleSizeWhereInput
  }

  export type ModuleSizeUpdateToOneWithWhereWithoutModulesInput = {
    where?: ModuleSizeWhereInput
    data: XOR<ModuleSizeUpdateWithoutModulesInput, ModuleSizeUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleSizeUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinetSizes?: CabinetSizeModuleSizeUpdateManyWithoutModuleSizeNestedInput
  }

  export type ModuleSizeUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinetSizes?: CabinetSizeModuleSizeUncheckedUpdateManyWithoutModuleSizeNestedInput
  }

  export type ModuleCreateWithoutPitchesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutPitchesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutPitchesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPitchesInput, ModuleUncheckedCreateWithoutPitchesInput>
  }

  export type PitchCreateWithoutModulesInput = {
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPitchCreateNestedManyWithoutPitchInput
  }

  export type PitchUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    pitchValue: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetPitchUncheckedCreateNestedManyWithoutPitchInput
  }

  export type PitchCreateOrConnectWithoutModulesInput = {
    where: PitchWhereUniqueInput
    create: XOR<PitchCreateWithoutModulesInput, PitchUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutPitchesInput = {
    update: XOR<ModuleUpdateWithoutPitchesInput, ModuleUncheckedUpdateWithoutPitchesInput>
    create: XOR<ModuleCreateWithoutPitchesInput, ModuleUncheckedCreateWithoutPitchesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutPitchesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutPitchesInput, ModuleUncheckedUpdateWithoutPitchesInput>
  }

  export type ModuleUpdateWithoutPitchesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutPitchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type PitchUpsertWithoutModulesInput = {
    update: XOR<PitchUpdateWithoutModulesInput, PitchUncheckedUpdateWithoutModulesInput>
    create: XOR<PitchCreateWithoutModulesInput, PitchUncheckedCreateWithoutModulesInput>
    where?: PitchWhereInput
  }

  export type PitchUpdateToOneWithWhereWithoutModulesInput = {
    where?: PitchWhereInput
    data: XOR<PitchUpdateWithoutModulesInput, PitchUncheckedUpdateWithoutModulesInput>
  }

  export type PitchUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPitchUpdateManyWithoutPitchNestedInput
  }

  export type PitchUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    pitchValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetPitchUncheckedUpdateManyWithoutPitchNestedInput
  }

  export type ModuleCreateWithoutManufacturersInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutManufacturersInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutManufacturersInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutManufacturersInput, ModuleUncheckedCreateWithoutManufacturersInput>
  }

  export type ManufacturerCreateWithoutModulesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetManufacturerCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetManufacturerUncheckedCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerCreateOrConnectWithoutModulesInput = {
    where: ManufacturerWhereUniqueInput
    create: XOR<ManufacturerCreateWithoutModulesInput, ManufacturerUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutManufacturersInput = {
    update: XOR<ModuleUpdateWithoutManufacturersInput, ModuleUncheckedUpdateWithoutManufacturersInput>
    create: XOR<ModuleCreateWithoutManufacturersInput, ModuleUncheckedCreateWithoutManufacturersInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutManufacturersInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutManufacturersInput, ModuleUncheckedUpdateWithoutManufacturersInput>
  }

  export type ModuleUpdateWithoutManufacturersInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutManufacturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ManufacturerUpsertWithoutModulesInput = {
    update: XOR<ManufacturerUpdateWithoutModulesInput, ManufacturerUncheckedUpdateWithoutModulesInput>
    create: XOR<ManufacturerCreateWithoutModulesInput, ManufacturerUncheckedCreateWithoutModulesInput>
    where?: ManufacturerWhereInput
  }

  export type ManufacturerUpdateToOneWithWhereWithoutModulesInput = {
    where?: ManufacturerWhereInput
    data: XOR<ManufacturerUpdateWithoutModulesInput, ManufacturerUncheckedUpdateWithoutModulesInput>
  }

  export type ManufacturerUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetManufacturerUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetManufacturerUncheckedUpdateManyWithoutManufacturerNestedInput
  }

  export type ModuleCreateWithoutItemsInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutItemsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutItemsInput, ModuleUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutModulesInput = {
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationCreateNestedManyWithoutItemInput
    prices?: ItemPriceCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    sku?: string | null
    name: string
    active?: boolean
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ItemCategoryRelationUncheckedCreateNestedManyWithoutItemInput
    subcategories?: ItemSubcategoryRelationUncheckedCreateNestedManyWithoutItemInput
    prices?: ItemPriceUncheckedCreateNestedManyWithoutItemInput
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    cabinets?: CabinetItemComponentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutModulesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutModulesInput, ItemUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutItemsInput = {
    update: XOR<ModuleUpdateWithoutItemsInput, ModuleUncheckedUpdateWithoutItemsInput>
    create: XOR<ModuleCreateWithoutItemsInput, ModuleUncheckedCreateWithoutItemsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutItemsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutItemsInput, ModuleUncheckedUpdateWithoutItemsInput>
  }

  export type ModuleUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ItemUpsertWithoutModulesInput = {
    update: XOR<ItemUpdateWithoutModulesInput, ItemUncheckedUpdateWithoutModulesInput>
    create: XOR<ItemCreateWithoutModulesInput, ItemUncheckedCreateWithoutModulesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutModulesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutModulesInput, ItemUncheckedUpdateWithoutModulesInput>
  }

  export type ItemUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ItemCategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    subcategories?: ItemSubcategoryRelationUncheckedUpdateManyWithoutItemNestedInput
    prices?: ItemPriceUncheckedUpdateManyWithoutItemNestedInput
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    cabinets?: CabinetItemComponentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ModuleCreateWithoutOptionsInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    prices?: ModulePriceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutOptionsInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    prices?: ModulePriceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutOptionsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutOptionsInput, ModuleUncheckedCreateWithoutOptionsInput>
  }

  export type OptionCreateWithoutModulesInput = {
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeOptionCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutModulesInput = {
    id?: number
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    screenTypes?: ScreenTypeOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutModulesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutModulesInput, OptionUncheckedCreateWithoutModulesInput>
  }

  export type ModuleUpsertWithoutOptionsInput = {
    update: XOR<ModuleUpdateWithoutOptionsInput, ModuleUncheckedUpdateWithoutOptionsInput>
    create: XOR<ModuleCreateWithoutOptionsInput, ModuleUncheckedCreateWithoutOptionsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutOptionsInput, ModuleUncheckedUpdateWithoutOptionsInput>
  }

  export type ModuleUpdateWithoutOptionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    prices?: ModulePriceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type OptionUpsertWithoutModulesInput = {
    update: XOR<OptionUpdateWithoutModulesInput, OptionUncheckedUpdateWithoutModulesInput>
    create: XOR<OptionCreateWithoutModulesInput, OptionUncheckedCreateWithoutModulesInput>
    where?: OptionWhereInput
  }

  export type OptionUpdateToOneWithWhereWithoutModulesInput = {
    where?: OptionWhereInput
    data: XOR<OptionUpdateWithoutModulesInput, OptionUncheckedUpdateWithoutModulesInput>
  }

  export type OptionUpdateWithoutModulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeOptionUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenTypes?: ScreenTypeOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type ModuleCreateWithoutPricesInput = {
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentCreateNestedManyWithoutModuleInput
    options?: ModuleOptionCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutPricesInput = {
    id?: number
    code: string
    sku?: string | null
    name?: string | null
    moduleOption?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ModuleCategoryUncheckedCreateNestedManyWithoutModuleInput
    subcategories?: ModuleSubcategoryUncheckedCreateNestedManyWithoutModuleInput
    locations?: ModuleLocationUncheckedCreateNestedManyWithoutModuleInput
    refreshRates?: ModuleRefreshRateUncheckedCreateNestedManyWithoutModuleInput
    brightnesses?: ModuleBrightnessUncheckedCreateNestedManyWithoutModuleInput
    sizes?: ModuleModuleSizeUncheckedCreateNestedManyWithoutModuleInput
    pitches?: ModulePitchUncheckedCreateNestedManyWithoutModuleInput
    manufacturers?: ModuleManufacturerUncheckedCreateNestedManyWithoutModuleInput
    items?: ModuleItemComponentUncheckedCreateNestedManyWithoutModuleInput
    options?: ModuleOptionUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutPricesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPricesInput, ModuleUncheckedCreateWithoutPricesInput>
  }

  export type ModuleUpsertWithoutPricesInput = {
    update: XOR<ModuleUpdateWithoutPricesInput, ModuleUncheckedUpdateWithoutPricesInput>
    create: XOR<ModuleCreateWithoutPricesInput, ModuleUncheckedCreateWithoutPricesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutPricesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutPricesInput, ModuleUncheckedUpdateWithoutPricesInput>
  }

  export type ModuleUpdateWithoutPricesInput = {
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    moduleOption?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ModuleCategoryUncheckedUpdateManyWithoutModuleNestedInput
    subcategories?: ModuleSubcategoryUncheckedUpdateManyWithoutModuleNestedInput
    locations?: ModuleLocationUncheckedUpdateManyWithoutModuleNestedInput
    refreshRates?: ModuleRefreshRateUncheckedUpdateManyWithoutModuleNestedInput
    brightnesses?: ModuleBrightnessUncheckedUpdateManyWithoutModuleNestedInput
    sizes?: ModuleModuleSizeUncheckedUpdateManyWithoutModuleNestedInput
    pitches?: ModulePitchUncheckedUpdateManyWithoutModuleNestedInput
    manufacturers?: ModuleManufacturerUncheckedUpdateManyWithoutModuleNestedInput
    items?: ModuleItemComponentUncheckedUpdateManyWithoutModuleNestedInput
    options?: ModuleOptionUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CabinetSizeCreateWithoutModuleSizesInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetCabinetSizeCreateNestedManyWithoutSizeInput
  }

  export type CabinetSizeUncheckedCreateWithoutModuleSizesInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cabinets?: CabinetCabinetSizeUncheckedCreateNestedManyWithoutSizeInput
  }

  export type CabinetSizeCreateOrConnectWithoutModuleSizesInput = {
    where: CabinetSizeWhereUniqueInput
    create: XOR<CabinetSizeCreateWithoutModuleSizesInput, CabinetSizeUncheckedCreateWithoutModuleSizesInput>
  }

  export type ModuleSizeCreateWithoutCabinetSizesInput = {
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleModuleSizeCreateNestedManyWithoutSizeInput
  }

  export type ModuleSizeUncheckedCreateWithoutCabinetSizesInput = {
    id?: number
    code: string
    size: string
    width: number
    height: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleModuleSizeUncheckedCreateNestedManyWithoutSizeInput
  }

  export type ModuleSizeCreateOrConnectWithoutCabinetSizesInput = {
    where: ModuleSizeWhereUniqueInput
    create: XOR<ModuleSizeCreateWithoutCabinetSizesInput, ModuleSizeUncheckedCreateWithoutCabinetSizesInput>
  }

  export type CabinetSizeUpsertWithoutModuleSizesInput = {
    update: XOR<CabinetSizeUpdateWithoutModuleSizesInput, CabinetSizeUncheckedUpdateWithoutModuleSizesInput>
    create: XOR<CabinetSizeCreateWithoutModuleSizesInput, CabinetSizeUncheckedCreateWithoutModuleSizesInput>
    where?: CabinetSizeWhereInput
  }

  export type CabinetSizeUpdateToOneWithWhereWithoutModuleSizesInput = {
    where?: CabinetSizeWhereInput
    data: XOR<CabinetSizeUpdateWithoutModuleSizesInput, CabinetSizeUncheckedUpdateWithoutModuleSizesInput>
  }

  export type CabinetSizeUpdateWithoutModuleSizesInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetCabinetSizeUpdateManyWithoutSizeNestedInput
  }

  export type CabinetSizeUncheckedUpdateWithoutModuleSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cabinets?: CabinetCabinetSizeUncheckedUpdateManyWithoutSizeNestedInput
  }

  export type ModuleSizeUpsertWithoutCabinetSizesInput = {
    update: XOR<ModuleSizeUpdateWithoutCabinetSizesInput, ModuleSizeUncheckedUpdateWithoutCabinetSizesInput>
    create: XOR<ModuleSizeCreateWithoutCabinetSizesInput, ModuleSizeUncheckedCreateWithoutCabinetSizesInput>
    where?: ModuleSizeWhereInput
  }

  export type ModuleSizeUpdateToOneWithWhereWithoutCabinetSizesInput = {
    where?: ModuleSizeWhereInput
    data: XOR<ModuleSizeUpdateWithoutCabinetSizesInput, ModuleSizeUncheckedUpdateWithoutCabinetSizesInput>
  }

  export type ModuleSizeUpdateWithoutCabinetSizesInput = {
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleModuleSizeUpdateManyWithoutSizeNestedInput
  }

  export type ModuleSizeUncheckedUpdateWithoutCabinetSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleModuleSizeUncheckedUpdateManyWithoutSizeNestedInput
  }

  export type ScreenTypeOptionCreateManyScreenTypeInput = {
    optionCode: string
  }

  export type ScreenTypeControlTypeCreateManyScreenTypeInput = {
    controlTypeCode: string
  }

  export type ScreenTypeSensorCreateManyScreenTypeInput = {
    sensorCode: string
  }

  export type ScreenTypeOptionUpdateWithoutScreenTypeInput = {
    option?: OptionUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeOptionUncheckedUpdateWithoutScreenTypeInput = {
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeOptionUncheckedUpdateManyWithoutScreenTypeInput = {
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeUpdateWithoutScreenTypeInput = {
    controlType?: ControlTypeUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeControlTypeUncheckedUpdateWithoutScreenTypeInput = {
    controlTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeUncheckedUpdateManyWithoutScreenTypeInput = {
    controlTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorUpdateWithoutScreenTypeInput = {
    sensor?: SensorUpdateOneRequiredWithoutScreenTypesNestedInput
  }

  export type ScreenTypeSensorUncheckedUpdateWithoutScreenTypeInput = {
    sensorCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorUncheckedUpdateManyWithoutScreenTypeInput = {
    sensorCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialCreateManyMaterialInput = {
    cabinetCode: string
  }

  export type CabinetMaterialUpdateWithoutMaterialInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type CabinetMaterialUncheckedUpdateWithoutMaterialInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialUncheckedUpdateManyWithoutMaterialInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationCreateManyLocationInput = {
    cabinetCode: string
  }

  export type ModuleLocationCreateManyLocationInput = {
    moduleCode: string
  }

  export type CabinetLocationUpdateWithoutLocationInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type CabinetLocationUncheckedUpdateWithoutLocationInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationUncheckedUpdateManyWithoutLocationInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationUpdateWithoutLocationInput = {
    module?: ModuleUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type ModuleLocationUncheckedUpdateWithoutLocationInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationUncheckedUpdateManyWithoutLocationInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementCreateManyPlacementInput = {
    cabinetCode: string
  }

  export type CabinetPlacementUpdateWithoutPlacementInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type CabinetPlacementUncheckedUpdateWithoutPlacementInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementUncheckedUpdateManyWithoutPlacementInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeOptionCreateManyOptionInput = {
    screenTypeCode: string
  }

  export type ModuleOptionCreateManyOptionInput = {
    moduleCode: string
  }

  export type ScreenTypeOptionUpdateWithoutOptionInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ScreenTypeOptionUncheckedUpdateWithoutOptionInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeOptionUncheckedUpdateManyWithoutOptionInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleOptionUpdateWithoutOptionInput = {
    module?: ModuleUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ModuleOptionUncheckedUpdateWithoutOptionInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleOptionUncheckedUpdateManyWithoutOptionInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorCreateManySensorInput = {
    screenTypeCode: string
  }

  export type ScreenTypeSensorUpdateWithoutSensorInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type ScreenTypeSensorUncheckedUpdateWithoutSensorInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeSensorUncheckedUpdateManyWithoutSensorInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeCreateManyControlTypeInput = {
    screenTypeCode: string
  }

  export type ScreenTypeControlTypeUpdateWithoutControlTypeInput = {
    screenType?: ScreenTypeUpdateOneRequiredWithoutControlTypesNestedInput
  }

  export type ScreenTypeControlTypeUncheckedUpdateWithoutControlTypeInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTypeControlTypeUncheckedUpdateManyWithoutControlTypeInput = {
    screenTypeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchCreateManyPitchInput = {
    cabinetCode: string
  }

  export type ModulePitchCreateManyPitchInput = {
    moduleCode: string
  }

  export type CabinetPitchUpdateWithoutPitchInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutPitchesNestedInput
  }

  export type CabinetPitchUncheckedUpdateWithoutPitchInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchUncheckedUpdateManyWithoutPitchInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchUpdateWithoutPitchInput = {
    module?: ModuleUpdateOneRequiredWithoutPitchesNestedInput
  }

  export type ModulePitchUncheckedUpdateWithoutPitchInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchUncheckedUpdateManyWithoutPitchInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateCreateManyRefreshRateInput = {
    moduleCode: string
  }

  export type ModuleRefreshRateUpdateWithoutRefreshRateInput = {
    module?: ModuleUpdateOneRequiredWithoutRefreshRatesNestedInput
  }

  export type ModuleRefreshRateUncheckedUpdateWithoutRefreshRateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateUncheckedUpdateManyWithoutRefreshRateInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessCreateManyBrightnessInput = {
    moduleCode: string
  }

  export type ModuleBrightnessUpdateWithoutBrightnessInput = {
    module?: ModuleUpdateOneRequiredWithoutBrightnessesNestedInput
  }

  export type ModuleBrightnessUncheckedUpdateWithoutBrightnessInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessUncheckedUpdateManyWithoutBrightnessInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerCreateManyManufacturerInput = {
    cabinetCode: string
  }

  export type ModuleManufacturerCreateManyManufacturerInput = {
    moduleCode: string
  }

  export type CabinetManufacturerUpdateWithoutManufacturerInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutManufacturersNestedInput
  }

  export type CabinetManufacturerUncheckedUpdateWithoutManufacturerInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerUncheckedUpdateManyWithoutManufacturerInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerUpdateWithoutManufacturerInput = {
    module?: ModuleUpdateOneRequiredWithoutManufacturersNestedInput
  }

  export type ModuleManufacturerUncheckedUpdateWithoutManufacturerInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerUncheckedUpdateManyWithoutManufacturerInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierCreateManySupplierInput = {
    cabinetCode: string
  }

  export type ItemSupplierCreateManySupplierInput = {
    itemCode: string
  }

  export type CabinetSupplierUpdateWithoutSupplierInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type CabinetSupplierUncheckedUpdateWithoutSupplierInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierUncheckedUpdateManyWithoutSupplierInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSupplierUpdateWithoutSupplierInput = {
    item?: ItemUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type ItemSupplierUncheckedUpdateWithoutSupplierInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSupplierUncheckedUpdateManyWithoutSupplierInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeCreateManySizeInput = {
    moduleCode: string
  }

  export type CabinetSizeModuleSizeCreateManyModuleSizeInput = {
    cabinetSizeCode: string
  }

  export type ModuleModuleSizeUpdateWithoutSizeInput = {
    module?: ModuleUpdateOneRequiredWithoutSizesNestedInput
  }

  export type ModuleModuleSizeUncheckedUpdateWithoutSizeInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeUncheckedUpdateManyWithoutSizeInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSizeModuleSizeUpdateWithoutModuleSizeInput = {
    cabinetSize?: CabinetSizeUpdateOneRequiredWithoutModuleSizesNestedInput
  }

  export type CabinetSizeModuleSizeUncheckedUpdateWithoutModuleSizeInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSizeModuleSizeUncheckedUpdateManyWithoutModuleSizeInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeCreateManySizeInput = {
    cabinetCode: string
  }

  export type CabinetSizeModuleSizeCreateManyCabinetSizeInput = {
    moduleSizeCode: string
  }

  export type CabinetCabinetSizeUpdateWithoutSizeInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSizesNestedInput
  }

  export type CabinetCabinetSizeUncheckedUpdateWithoutSizeInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeUncheckedUpdateManyWithoutSizeInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSizeModuleSizeUpdateWithoutCabinetSizeInput = {
    moduleSize?: ModuleSizeUpdateOneRequiredWithoutCabinetSizesNestedInput
  }

  export type CabinetSizeModuleSizeUncheckedUpdateWithoutCabinetSizeInput = {
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSizeModuleSizeUncheckedUpdateManyWithoutCabinetSizeInput = {
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryCreateManyCategoryInput = {
    subcategoryCode: string
  }

  export type ItemCategoryRelationCreateManyCategoryInput = {
    itemCode: string
  }

  export type CabinetCategoryCreateManyCategoryInput = {
    cabinetCode: string
  }

  export type ModuleCategoryCreateManyCategoryInput = {
    moduleCode: string
  }

  export type ItemCategorySubcategoryUpdateWithoutCategoryInput = {
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ItemCategorySubcategoryUncheckedUpdateWithoutCategoryInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryRelationUpdateWithoutCategoryInput = {
    item?: ItemUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ItemCategoryRelationUncheckedUpdateWithoutCategoryInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryRelationUncheckedUpdateManyWithoutCategoryInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryUpdateWithoutCategoryInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CabinetCategoryUncheckedUpdateWithoutCategoryInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryUncheckedUpdateManyWithoutCategoryInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleCategoryUpdateWithoutCategoryInput = {
    module?: ModuleUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ModuleCategoryUncheckedUpdateWithoutCategoryInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleCategoryUncheckedUpdateManyWithoutCategoryInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryCreateManySubcategoryInput = {
    categoryCode: string
  }

  export type ItemSubcategoryRelationCreateManySubcategoryInput = {
    itemCode: string
  }

  export type CabinetSubcategoryCreateManySubcategoryInput = {
    cabinetCode: string
  }

  export type ModuleSubcategoryCreateManySubcategoryInput = {
    moduleCode: string
  }

  export type ItemCategorySubcategoryUpdateWithoutSubcategoryInput = {
    category?: ItemCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type ItemCategorySubcategoryUncheckedUpdateWithoutSubcategoryInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategorySubcategoryUncheckedUpdateManyWithoutSubcategoryInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationUpdateWithoutSubcategoryInput = {
    item?: ItemUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type ItemSubcategoryRelationUncheckedUpdateWithoutSubcategoryInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationUncheckedUpdateManyWithoutSubcategoryInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryUpdateWithoutSubcategoryInput = {
    cabinet?: CabinetUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type CabinetSubcategoryUncheckedUpdateWithoutSubcategoryInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryUncheckedUpdateManyWithoutSubcategoryInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryUpdateWithoutSubcategoryInput = {
    module?: ModuleUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type ModuleSubcategoryUncheckedUpdateWithoutSubcategoryInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryUncheckedUpdateManyWithoutSubcategoryInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryCreateManyCabinetInput = {
    categoryCode: string
  }

  export type CabinetSubcategoryCreateManyCabinetInput = {
    subcategoryCode: string
  }

  export type CabinetLocationCreateManyCabinetInput = {
    locationCode: string
  }

  export type CabinetPlacementCreateManyCabinetInput = {
    placementCode: string
  }

  export type CabinetMaterialCreateManyCabinetInput = {
    materialCode: string
  }

  export type CabinetCabinetSizeCreateManyCabinetInput = {
    cabinetSizeCode: string
  }

  export type CabinetPitchCreateManyCabinetInput = {
    pitchCode: string
  }

  export type CabinetManufacturerCreateManyCabinetInput = {
    manufacturerCode: string
  }

  export type CabinetSupplierCreateManyCabinetInput = {
    supplierCode: string
  }

  export type CabinetItemComponentCreateManyCabinetInput = {
    itemCode: string
    quantity: number
  }

  export type CabinetPriceCreateManyCabinetInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetCategoryUpdateWithoutCabinetInput = {
    category?: ItemCategoryUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetCategoryUncheckedUpdateWithoutCabinetInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCategoryUncheckedUpdateManyWithoutCabinetInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryUpdateWithoutCabinetInput = {
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetSubcategoryUncheckedUpdateWithoutCabinetInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSubcategoryUncheckedUpdateManyWithoutCabinetInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationUpdateWithoutCabinetInput = {
    location?: LocationUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetLocationUncheckedUpdateWithoutCabinetInput = {
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetLocationUncheckedUpdateManyWithoutCabinetInput = {
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementUpdateWithoutCabinetInput = {
    placement?: PlacementUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetPlacementUncheckedUpdateWithoutCabinetInput = {
    placementCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPlacementUncheckedUpdateManyWithoutCabinetInput = {
    placementCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialUpdateWithoutCabinetInput = {
    material?: MaterialUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetMaterialUncheckedUpdateWithoutCabinetInput = {
    materialCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetMaterialUncheckedUpdateManyWithoutCabinetInput = {
    materialCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeUpdateWithoutCabinetInput = {
    size?: CabinetSizeUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetCabinetSizeUncheckedUpdateWithoutCabinetInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetCabinetSizeUncheckedUpdateManyWithoutCabinetInput = {
    cabinetSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchUpdateWithoutCabinetInput = {
    pitch?: PitchUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetPitchUncheckedUpdateWithoutCabinetInput = {
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetPitchUncheckedUpdateManyWithoutCabinetInput = {
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerUpdateWithoutCabinetInput = {
    manufacturer?: ManufacturerUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetManufacturerUncheckedUpdateWithoutCabinetInput = {
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetManufacturerUncheckedUpdateManyWithoutCabinetInput = {
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierUpdateWithoutCabinetInput = {
    supplier?: SupplierUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetSupplierUncheckedUpdateWithoutCabinetInput = {
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetSupplierUncheckedUpdateManyWithoutCabinetInput = {
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetItemComponentUpdateWithoutCabinetInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutCabinetsNestedInput
  }

  export type CabinetItemComponentUncheckedUpdateWithoutCabinetInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetItemComponentUncheckedUpdateManyWithoutCabinetInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetPriceUpdateWithoutCabinetInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUncheckedUpdateWithoutCabinetInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CabinetPriceUncheckedUpdateManyWithoutCabinetInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModuleCategoryCreateManyModuleInput = {
    categoryCode: string
  }

  export type ModuleSubcategoryCreateManyModuleInput = {
    subcategoryCode: string
  }

  export type ModuleLocationCreateManyModuleInput = {
    locationCode: string
  }

  export type ModuleRefreshRateCreateManyModuleInput = {
    refreshRateCode: string
  }

  export type ModuleBrightnessCreateManyModuleInput = {
    brightnessCode: string
  }

  export type ModuleModuleSizeCreateManyModuleInput = {
    moduleSizeCode: string
  }

  export type ModulePitchCreateManyModuleInput = {
    pitchCode: string
  }

  export type ModuleManufacturerCreateManyModuleInput = {
    manufacturerCode: string
  }

  export type ModuleItemComponentCreateManyModuleInput = {
    itemCode: string
    quantity: number
  }

  export type ModuleOptionCreateManyModuleInput = {
    optionCode: string
  }

  export type ModulePriceCreateManyModuleInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ModuleCategoryUpdateWithoutModuleInput = {
    category?: ItemCategoryUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleCategoryUncheckedUpdateWithoutModuleInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleCategoryUncheckedUpdateManyWithoutModuleInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryUpdateWithoutModuleInput = {
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleSubcategoryUncheckedUpdateWithoutModuleInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleSubcategoryUncheckedUpdateManyWithoutModuleInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationUpdateWithoutModuleInput = {
    location?: LocationUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleLocationUncheckedUpdateWithoutModuleInput = {
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleLocationUncheckedUpdateManyWithoutModuleInput = {
    locationCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateUpdateWithoutModuleInput = {
    refreshRate?: RefreshRateUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleRefreshRateUncheckedUpdateWithoutModuleInput = {
    refreshRateCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleRefreshRateUncheckedUpdateManyWithoutModuleInput = {
    refreshRateCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessUpdateWithoutModuleInput = {
    brightness?: BrightnessUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleBrightnessUncheckedUpdateWithoutModuleInput = {
    brightnessCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleBrightnessUncheckedUpdateManyWithoutModuleInput = {
    brightnessCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeUpdateWithoutModuleInput = {
    size?: ModuleSizeUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleModuleSizeUncheckedUpdateWithoutModuleInput = {
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleModuleSizeUncheckedUpdateManyWithoutModuleInput = {
    moduleSizeCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchUpdateWithoutModuleInput = {
    pitch?: PitchUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModulePitchUncheckedUpdateWithoutModuleInput = {
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePitchUncheckedUpdateManyWithoutModuleInput = {
    pitchCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerUpdateWithoutModuleInput = {
    manufacturer?: ManufacturerUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleManufacturerUncheckedUpdateWithoutModuleInput = {
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleManufacturerUncheckedUpdateManyWithoutModuleInput = {
    manufacturerCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleItemComponentUpdateWithoutModuleInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleItemComponentUncheckedUpdateWithoutModuleInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleItemComponentUncheckedUpdateManyWithoutModuleInput = {
    itemCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleOptionUpdateWithoutModuleInput = {
    option?: OptionUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleOptionUncheckedUpdateWithoutModuleInput = {
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleOptionUncheckedUpdateManyWithoutModuleInput = {
    optionCode?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePriceUpdateWithoutModuleInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUncheckedUpdateWithoutModuleInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ModulePriceUncheckedUpdateManyWithoutModuleInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemCategoryRelationCreateManyItemInput = {
    categoryCode: string
  }

  export type ItemSubcategoryRelationCreateManyItemInput = {
    subcategoryCode: string
  }

  export type ItemPriceCreateManyItemInput = {
    priceUsd?: Decimal | DecimalJsLike | number | string | null
    priceRub?: Decimal | DecimalJsLike | number | string | null
  }

  export type ItemSupplierCreateManyItemInput = {
    supplierCode: string
  }

  export type CabinetItemComponentCreateManyItemInput = {
    cabinetCode: string
    quantity: number
  }

  export type ModuleItemComponentCreateManyItemInput = {
    moduleCode: string
    quantity: number
  }

  export type ItemCategoryRelationUpdateWithoutItemInput = {
    category?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemCategoryRelationUncheckedUpdateWithoutItemInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryRelationUncheckedUpdateManyWithoutItemInput = {
    categoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationUpdateWithoutItemInput = {
    subcategory?: ItemSubcategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemSubcategoryRelationUncheckedUpdateWithoutItemInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSubcategoryRelationUncheckedUpdateManyWithoutItemInput = {
    subcategoryCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemPriceUpdateWithoutItemInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUncheckedUpdateWithoutItemInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemPriceUncheckedUpdateManyWithoutItemInput = {
    priceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRub?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemSupplierUpdateWithoutItemInput = {
    supplier?: SupplierUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemSupplierUncheckedUpdateWithoutItemInput = {
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type ItemSupplierUncheckedUpdateManyWithoutItemInput = {
    supplierCode?: StringFieldUpdateOperationsInput | string
  }

  export type CabinetItemComponentUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cabinet?: CabinetUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CabinetItemComponentUncheckedUpdateWithoutItemInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetItemComponentUncheckedUpdateManyWithoutItemInput = {
    cabinetCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleItemComponentUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ModuleItemComponentUncheckedUpdateWithoutItemInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleItemComponentUncheckedUpdateManyWithoutItemInput = {
    moduleCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}